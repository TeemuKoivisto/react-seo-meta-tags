{"version":3,"file":"stitching.js","names":["ensureExpectedType","maybeType","Error","stitchSlices","htmlString","publicDir","previousStart","undefined","processedHTML","cursor","getSliceContent","sliceHtmlName","fs","readFile","path","join","match","matchAll","groups","index","startOrEndElementOpenening","startOrEndElementClosing","meta","end","length","syntax","id","idElement","type","idComment","startOrEndComment","newCursor","substring","stitchSliceForAPage","pagePath","htmlFilePath","generateHtmlPath","html","writeFile"],"sources":["../../../src/utils/slices/stitching.ts"],"sourcesContent":["import * as path from \"path\"\nimport * as fs from \"fs-extra\"\nimport { generateHtmlPath } from \"gatsby-core-utils/page-html\"\n\ninterface ISliceBoundaryMatch {\n  index: number\n  end: number\n  syntax: \"element\" | \"comment\"\n  id: string\n  type: \"start\" | \"end\"\n}\n\nfunction ensureExpectedType(maybeType: string): \"start\" | \"end\" {\n  if (maybeType === `start` || maybeType === `end`) {\n    return maybeType\n  } else {\n    throw new Error(`Unexpected type: ${maybeType}. Expected \"start\" or \"end\"`)\n  }\n}\n\nasync function stitchSlices(\n  htmlString: string,\n  publicDir: string\n): Promise<string> {\n  let previousStart: ISliceBoundaryMatch | undefined = undefined\n\n  let processedHTML = ``\n  let cursor = 0\n\n  async function getSliceContent(sliceHtmlName: string): Promise<string> {\n    return fs.readFile(\n      path.join(publicDir, `_gatsby`, `slices`, `${sliceHtmlName}.html`),\n      `utf-8`\n    )\n  }\n\n  for (const match of htmlString.matchAll(\n    /(<slice-(?<startOrEndElementOpenening>start|end)\\s[^>]*id=\"(?<idElement>[^\"]+)\"[^>]*><\\/slice-(?<startOrEndElementClosing>[^>]+)>|<!-- slice-(?<startOrEndComment>start|end) id=\"(?<idComment>[^\"]+)\" -->)/g\n  )) {\n    if (!match.groups) {\n      throw new Error(\n        `Invariant: [stitching slices] Capturing groups should be defined`\n      )\n    }\n\n    if (typeof match.index !== `number`) {\n      throw new Error(\n        `Invariant: [stitching slices] There is no location of a match when stitching slices`\n      )\n    }\n\n    if (\n      match.groups.startOrEndElementOpenening &&\n      match.groups.startOrEndElementOpenening !==\n        match.groups.startOrEndElementClosing\n    ) {\n      throw new Error(\n        `Invariant: [stitching slices] start and end tags should be the same. Got: Start: ${match.groups.startOrEndElementOpenening} End: ${match.groups.startOrEndElementClosing}`\n      )\n    }\n\n    const meta: ISliceBoundaryMatch = {\n      index: match.index,\n      end: match.index + match[0].length,\n      ...(match.groups.startOrEndElementOpenening\n        ? {\n            syntax: `element`, // can discard this field\n            id: match.groups.idElement,\n            type: ensureExpectedType(match.groups.startOrEndElementOpenening),\n          }\n        : {\n            syntax: `comment`, // can discard this field\n            id: match.groups.idComment,\n            type: ensureExpectedType(match.groups.startOrEndComment),\n          }),\n    }\n\n    if (meta.type === `start`) {\n      if (previousStart) {\n        // if we are already in a slice, we will replace everything until the outer slice end\n        // so we just ignore those\n        continue\n      }\n      const newCursor = meta.end\n      processedHTML +=\n        htmlString.substring(cursor, meta.index) +\n        `<!-- slice-start id=\"${meta.id}\" -->`\n      cursor = newCursor\n\n      previousStart = meta\n    } else if (meta.type === `end`) {\n      if (!previousStart) {\n        throw new Error(\n          `Invariant: [stitching slices] There was no start tag, but close tag was found`\n        )\n      }\n      if (previousStart.id !== meta.id) {\n        // it's possible to have nested slices - we want to handle just the most outer slice\n        // as stitching it in will recursively handle nested slices as well\n        continue\n      }\n\n      processedHTML += `${await stitchSlices(\n        await getSliceContent(meta.id),\n        publicDir\n      )}<!-- slice-end id=\"${meta.id}\" -->`\n      cursor = meta.end\n\n      previousStart = undefined\n    }\n  }\n\n  if (previousStart) {\n    throw new Error(\n      `Invariant: [stitching slices] There was start tag, but no close tag was found`\n    )\n  }\n\n  // get rest of the html\n  processedHTML += htmlString.substring(cursor)\n\n  return processedHTML\n}\n\nexport async function stitchSliceForAPage({\n  pagePath,\n  publicDir,\n}: {\n  pagePath: string\n  publicDir: string\n}): Promise<void> {\n  const htmlFilePath = generateHtmlPath(publicDir, pagePath)\n\n  const html = await fs.readFile(htmlFilePath, `utf-8`)\n\n  const processedHTML = await stitchSlices(html, publicDir)\n\n  if (html !== processedHTML) {\n    await fs.writeFile(htmlFilePath, processedHTML)\n  }\n}\n"],"mappings":"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"}