{"version":3,"file":"entry.js","names":["tracerReadyPromise","initTracer","process","env","GATSBY_OPEN_TRACING_CONFIG_FILE","getData","pathName","graphqlEngine","req","spanContext","telemetryResolverTimings","getDataWrapperActivity","reporter","phantomActivity","parentSpan","start","page","templateDetails","potentialPagePath","findMetaActivity","span","getPagePathFromPageDataPath","maybePage","findPageByPath","Error","INLINED_TEMPLATE_TO_DETAILS","componentChunkName","end","executionPromises","results","serverData","query","runningQueryActivity","push","runQuery","context","queryName","path","componentPath","forceGraphqlTracing","then","queryResults","errors","length","e","codeFrame","getCodeFrame","locations","line","column","queryRunningError","message","stack","finally","mode","runningGetServerDataActivity","getPageChunk","mod","getServerData","serverDataResults","Promise","all","props","pageContext","searchString","maybeQueryString","Object","entries","map","k","v","encodeURIComponent","join","serverDataHeaders","headers","serverDataStatus","status","getPath","data","matchPath","renderPageData","activity","sliceOverrides","slices","slicesFromBundler","GATSBY_SLICES","Map","key","value","set","slicesUsedByTemplatesFromBundler","GATSBY_SLICES_BY_TEMPLATE","slicesUsedByTemplates","constructPageDataString","staticQueryHashes","JSON","stringify","parse","readStaticQueryContext","templatePath","filePath","__dirname","rawSQContext","fs","readFile","readSliceData","sliceName","rawSliceData","renderHTML","pageData","wrapperActivity","sliceData","readSliceDataActivity","values","slicesMap","readStaticQueryContextActivity","staticQueryContext","uniqueUsedComponentChunkNames","singleSliceData","includes","contextsToMerge","assign","renderHTMLActivity","pagePath","htmlComponentRenderer","webpackCompilationHash","WEBPACK_COMPILATION_HASH","assets","inlinePageData","html","replace","GATSBY_SLICES_SCRIPT"],"sources":["../../../src/utils/page-ssr-module/entry.ts"],"sourcesContent":["// \"engines-fs-provider\" must be first import, as it sets up global\n// fs and this need to happen before anything else tries to import fs\nimport \"../engines-fs-provider\"\n\n// just types - those should not be bundled\nimport type { GraphQLEngine } from \"../../schema/graphql-engine/entry\"\nimport type { IExecutionResult } from \"../../query/types\"\nimport type { IGatsbyPage, IGatsbySlice, IGatsbyState } from \"../../redux/types\"\nimport { IGraphQLTelemetryRecord } from \"../../schema/type-definitions\"\nimport type { IScriptsAndStyles } from \"../client-assets-for-template\"\nimport type { IPageDataWithQueryResult, ISliceData } from \"../page-data\"\nimport type { Request } from \"express\"\nimport type { Span, SpanContext } from \"opentracing\"\n\n// actual imports\nimport * as path from \"path\"\nimport * as fs from \"fs-extra\"\nimport {\n  constructPageDataString,\n  getPagePathFromPageDataPath,\n} from \"../page-data-helpers\"\n// @ts-ignore render-page import will become valid later on (it's marked as external)\nimport htmlComponentRenderer, { getPageChunk } from \"./routes/render-page\"\nimport { getServerData, IServerData } from \"../get-server-data\"\nimport reporter from \"gatsby-cli/lib/reporter\"\nimport { initTracer } from \"../tracer\"\nimport { getCodeFrame } from \"../../query/graphql-errors-codeframe\"\nimport { ICollectedSlice } from \"../babel/find-slices\"\n\nexport interface ITemplateDetails {\n  query: string\n  staticQueryHashes: Array<string>\n  assets: IScriptsAndStyles\n}\nexport interface ISSRData {\n  results: IExecutionResult\n  page: IGatsbyPage\n  templateDetails: ITemplateDetails\n  potentialPagePath: string\n  serverDataHeaders?: Record<string, string>\n  serverDataStatus?: number\n  searchString: string\n}\n\n// just letting TypeScript know about injected data\n// with DefinePlugin\ndeclare global {\n  const INLINED_TEMPLATE_TO_DETAILS: Record<string, ITemplateDetails>\n  const WEBPACK_COMPILATION_HASH: string\n  const GATSBY_SLICES_SCRIPT: string\n}\n\nconst tracerReadyPromise = initTracer(\n  process.env.GATSBY_OPEN_TRACING_CONFIG_FILE ?? ``\n)\n\ntype MaybePhantomActivity =\n  | ReturnType<typeof reporter.phantomActivity>\n  | undefined\n\nexport async function getData({\n  pathName,\n  graphqlEngine,\n  req,\n  spanContext,\n  telemetryResolverTimings,\n}: {\n  graphqlEngine: GraphQLEngine\n  pathName: string\n  req?: Partial<Pick<Request, \"query\" | \"method\" | \"url\" | \"headers\">>\n  spanContext?: Span | SpanContext\n  telemetryResolverTimings?: Array<IGraphQLTelemetryRecord>\n}): Promise<ISSRData> {\n  await tracerReadyPromise\n\n  let getDataWrapperActivity: MaybePhantomActivity\n  try {\n    if (spanContext) {\n      getDataWrapperActivity = reporter.phantomActivity(`Running getData`, {\n        parentSpan: spanContext,\n      })\n      getDataWrapperActivity.start()\n    }\n\n    let page: IGatsbyPage\n    let templateDetails: ITemplateDetails\n    let potentialPagePath: string\n    let findMetaActivity: MaybePhantomActivity\n    try {\n      if (getDataWrapperActivity) {\n        findMetaActivity = reporter.phantomActivity(\n          `Finding details about page and template`,\n          {\n            parentSpan: getDataWrapperActivity.span,\n          }\n        )\n        findMetaActivity.start()\n      }\n      potentialPagePath = getPagePathFromPageDataPath(pathName) || pathName\n\n      // 1. Find a page for pathname\n      const maybePage = graphqlEngine.findPageByPath(potentialPagePath)\n\n      if (!maybePage) {\n        // page not found, nothing to run query for\n        throw new Error(`Page for \"${pathName}\" not found`)\n      }\n\n      page = maybePage\n\n      // 2. Lookup query used for a page (template)\n      templateDetails = INLINED_TEMPLATE_TO_DETAILS[page.componentChunkName]\n      if (!templateDetails) {\n        throw new Error(\n          `Page template details for \"${page.componentChunkName}\" not found`\n        )\n      }\n    } finally {\n      if (findMetaActivity) {\n        findMetaActivity.end()\n      }\n    }\n\n    const executionPromises: Array<Promise<any>> = []\n\n    // 3. Execute query\n    // query-runner handles case when query is not there - so maybe we should consider using that somehow\n    let results: IExecutionResult = {}\n    let serverData: IServerData | undefined\n    if (templateDetails.query) {\n      let runningQueryActivity: MaybePhantomActivity\n      if (getDataWrapperActivity) {\n        runningQueryActivity = reporter.phantomActivity(`Running page query`, {\n          parentSpan: getDataWrapperActivity.span,\n        })\n        runningQueryActivity.start()\n      }\n      executionPromises.push(\n        graphqlEngine\n          .runQuery(\n            templateDetails.query,\n            {\n              ...page,\n              ...page.context,\n            },\n            {\n              queryName: page.path,\n              componentPath: page.componentPath,\n              parentSpan: runningQueryActivity?.span,\n              forceGraphqlTracing: !!runningQueryActivity,\n              telemetryResolverTimings,\n            }\n          )\n          .then(queryResults => {\n            if (queryResults.errors && queryResults.errors.length > 0) {\n              const e = queryResults.errors[0]\n              const codeFrame = getCodeFrame(\n                templateDetails.query,\n                e.locations && e.locations[0].line,\n                e.locations && e.locations[0].column\n              )\n\n              const queryRunningError = new Error(\n                e.message + `\\n\\n` + codeFrame\n              )\n              queryRunningError.stack = e.stack\n              throw queryRunningError\n            } else {\n              results = queryResults\n            }\n          })\n          .finally(() => {\n            if (runningQueryActivity) {\n              runningQueryActivity.end()\n            }\n          })\n      )\n    }\n\n    // 4. (if SSR) run getServerData\n    if (page.mode === `SSR`) {\n      let runningGetServerDataActivity: MaybePhantomActivity\n      if (getDataWrapperActivity) {\n        runningGetServerDataActivity = reporter.phantomActivity(\n          `Running getServerData`,\n          {\n            parentSpan: getDataWrapperActivity.span,\n          }\n        )\n        runningGetServerDataActivity.start()\n      }\n      executionPromises.push(\n        getPageChunk(page)\n          .then(mod => getServerData(req, page, potentialPagePath, mod))\n          .then(serverDataResults => {\n            serverData = serverDataResults\n          })\n          .finally(() => {\n            if (runningGetServerDataActivity) {\n              runningGetServerDataActivity.end()\n            }\n          })\n      )\n    }\n\n    await Promise.all(executionPromises)\n\n    if (serverData) {\n      results.serverData = serverData.props\n    }\n    results.pageContext = page.context\n\n    let searchString = ``\n\n    if (req?.query) {\n      const maybeQueryString = Object.entries(req.query)\n        .map(\n          ([k, v]) =>\n            // Preserve QueryString encoding\n            `${encodeURIComponent(k)}=${encodeURIComponent(v as string)}`\n        )\n        .join(`&`)\n      if (maybeQueryString) {\n        searchString = `?${maybeQueryString}`\n      }\n    }\n\n    return {\n      results,\n      page,\n      templateDetails,\n      potentialPagePath,\n      serverDataHeaders: serverData?.headers,\n      serverDataStatus: serverData?.status,\n      searchString,\n    }\n  } finally {\n    if (getDataWrapperActivity) {\n      getDataWrapperActivity.end()\n    }\n  }\n}\n\nfunction getPath(data: ISSRData): string {\n  return (\n    (data.page.mode !== `SSG` && data.page.matchPath\n      ? data.potentialPagePath\n      : data.page.path) + (data.page.mode === `SSR` ? data.searchString : ``)\n  )\n}\n\nexport async function renderPageData({\n  data,\n  spanContext,\n}: {\n  data: ISSRData\n  spanContext?: Span | SpanContext\n}): Promise<IPageDataWithQueryResult> {\n  await tracerReadyPromise\n\n  let activity: MaybePhantomActivity\n  try {\n    if (spanContext) {\n      activity = reporter.phantomActivity(`Rendering page-data`, {\n        parentSpan: spanContext,\n      })\n      activity.start()\n    }\n\n    const componentPath = data.page.componentPath\n    const sliceOverrides = data.page.slices\n\n    // @ts-ignore GATSBY_SLICES is being \"inlined\" by bundler\n    const slicesFromBundler = GATSBY_SLICES as {\n      [key: string]: IGatsbySlice\n    }\n    const slices: IGatsbyState[\"slices\"] = new Map()\n    for (const [key, value] of Object.entries(slicesFromBundler)) {\n      slices.set(key, value)\n    }\n\n    const slicesUsedByTemplatesFromBundler =\n      // @ts-ignore GATSBY_SLICES_BY_TEMPLATE is being \"inlined\" by bundler\n      GATSBY_SLICES_BY_TEMPLATE as {\n        [key: string]: { [key: string]: ICollectedSlice }\n      }\n    const slicesUsedByTemplates: IGatsbyState[\"slicesByTemplate\"] = new Map()\n    for (const [key, value] of Object.entries(\n      slicesUsedByTemplatesFromBundler\n    )) {\n      slicesUsedByTemplates.set(key, value)\n    }\n\n    // TODO: optimize this to only pass name for slices, as it's only used for validation\n\n    const results = await constructPageDataString(\n      {\n        componentChunkName: data.page.componentChunkName,\n        path: getPath(data),\n        matchPath: data.page.matchPath,\n        staticQueryHashes: data.templateDetails.staticQueryHashes,\n        componentPath,\n        slices: sliceOverrides,\n      },\n      JSON.stringify(data.results),\n      slicesUsedByTemplates,\n      slices\n    )\n\n    return JSON.parse(results)\n  } finally {\n    if (activity) {\n      activity.end()\n    }\n  }\n}\n\nconst readStaticQueryContext = async (\n  templatePath: string\n): Promise<Record<string, { data: unknown }>> => {\n  const filePath = path.join(\n    __dirname,\n    `sq-context`,\n    templatePath,\n    `sq-context.json`\n  )\n  const rawSQContext = await fs.readFile(filePath, `utf-8`)\n\n  return JSON.parse(rawSQContext)\n}\n\nconst readSliceData = async (sliceName: string): Promise<ISliceData> => {\n  const filePath = path.join(__dirname, `slice-data`, `${sliceName}.json`)\n\n  const rawSliceData = await fs.readFile(filePath, `utf-8`)\n  return JSON.parse(rawSliceData)\n}\n\nexport async function renderHTML({\n  data,\n  pageData,\n  spanContext,\n}: {\n  data: ISSRData\n  pageData?: IPageDataWithQueryResult\n  spanContext?: Span | SpanContext\n}): Promise<string> {\n  await tracerReadyPromise\n\n  let wrapperActivity: MaybePhantomActivity\n  try {\n    if (spanContext) {\n      wrapperActivity = reporter.phantomActivity(`Rendering HTML`, {\n        parentSpan: spanContext,\n      })\n      wrapperActivity.start()\n    }\n\n    if (!pageData) {\n      pageData = await renderPageData({\n        data,\n        spanContext: wrapperActivity?.span,\n      })\n    }\n\n    const sliceData: Record<string, ISliceData> = {}\n    if (_CFLAGS_.GATSBY_MAJOR === `5` && process.env.GATSBY_SLICES) {\n      let readSliceDataActivity: MaybePhantomActivity\n      try {\n        if (wrapperActivity) {\n          readSliceDataActivity = reporter.phantomActivity(\n            `Preparing slice-data`,\n            {\n              parentSpan: wrapperActivity.span,\n            }\n          )\n          readSliceDataActivity.start()\n        }\n        for (const sliceName of Object.values(pageData.slicesMap)) {\n          sliceData[sliceName] = await readSliceData(sliceName)\n        }\n      } finally {\n        if (readSliceDataActivity) {\n          readSliceDataActivity.end()\n        }\n      }\n    }\n\n    let readStaticQueryContextActivity: MaybePhantomActivity\n    let staticQueryContext: Record<string, { data: unknown }>\n    try {\n      if (wrapperActivity) {\n        readStaticQueryContextActivity = reporter.phantomActivity(\n          `Preparing StaticQueries context`,\n          {\n            parentSpan: wrapperActivity.span,\n          }\n        )\n        readStaticQueryContextActivity.start()\n      }\n\n      const uniqueUsedComponentChunkNames = [data.page.componentChunkName]\n      for (const singleSliceData of Object.values(sliceData)) {\n        if (\n          singleSliceData.componentChunkName &&\n          !uniqueUsedComponentChunkNames.includes(\n            singleSliceData.componentChunkName\n          )\n        ) {\n          uniqueUsedComponentChunkNames.push(singleSliceData.componentChunkName)\n        }\n      }\n\n      const contextsToMerge = await Promise.all(\n        uniqueUsedComponentChunkNames.map(readStaticQueryContext)\n      )\n\n      staticQueryContext = Object.assign({}, ...contextsToMerge)\n    } finally {\n      if (readStaticQueryContextActivity) {\n        readStaticQueryContextActivity.end()\n      }\n    }\n\n    let renderHTMLActivity: MaybePhantomActivity\n    try {\n      if (wrapperActivity) {\n        renderHTMLActivity = reporter.phantomActivity(\n          `Actually rendering HTML`,\n          {\n            parentSpan: wrapperActivity.span,\n          }\n        )\n        renderHTMLActivity.start()\n      }\n\n      const pagePath = getPath(data)\n      const results = await htmlComponentRenderer({\n        pagePath,\n        pageData,\n        staticQueryContext,\n        webpackCompilationHash: WEBPACK_COMPILATION_HASH,\n        ...data.templateDetails.assets,\n        inlinePageData: data.page.mode === `SSR` && data.results.serverData,\n        sliceData,\n      })\n\n      return results.html.replace(\n        `<slice-start id=\"_gatsby-scripts-1\"></slice-start><slice-end id=\"_gatsby-scripts-1\"></slice-end>`,\n        GATSBY_SLICES_SCRIPT\n      )\n    } finally {\n      if (renderHTMLActivity) {\n        renderHTMLActivity.end()\n      }\n    }\n  } finally {\n    if (wrapperActivity) {\n      wrapperActivity.end()\n    }\n  }\n}\n"],"mappings":"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"}