{"version":3,"file":"filter-using-index.js","names":["BinaryInfinityNegative","Buffer","from","BinaryInfinityPositive","String","fromCharCode","repeat","ValueEdges","filterUsingIndex","args","context","createFilteringContext","ranges","getIndexRanges","entries","length","performRangeScan","performFullScan","usedQueries","size","dbQueries","narrowResultsIfPossible","isMultiKeyIndex","needsDeduplication","deduplicate","getIdentifier","usedLimit","usedSkip","countUsingIndexOnly","databases","indexes","indexMetadata","keyPrefix","Error","range","start","end","getValueEdgeAfter","snapshot","getKeysCount","count","undefined","Set","multiKeyFields","fieldsWithAppliedEq","forEach","q","filter","getFilterStatement","comparator","DbComparator","EQ","add","dbQueryToDottedField","some","fieldName","has","stats","reverse","limit","skip","offset","maxKeysPerItem","lmdbRanges","push","GatsbyIterable","traverseRanges","undefinedSymbol","undefinedToEnd","topToUndefined","getRange","indexFields","Map","keyFields","positionInKey","set","filtersToApply","query","get","isNegatedQuery","key","fieldPositionInIndex","value","matchesFilter","getSupportedQueries","isSupported","IN","GTE","LTE","GT","LT","NIN","NE","supportedQueries","sortBySpecificity","isEqualityQuery","rangeStarts","rangeEndings","indexFieldInfo","getMostSpecificQuery","result","resolveIndexFieldRanges","i","rangeStartsProduct","cartesianProduct","rangeEndingsProduct","getFieldQueries","queries","indexField","fieldQueries","field","sortDirection","Array","isArray","arr","sort","a","b","hasNull","item","toIndexFieldValue","resolveRangeEdge","AFTER","rangeHead","rangeTail","predicate","edge","dbQuery","filterStatement","getValueEdgeBefore","filterValue","inspect","entry","id","out"],"sources":["../../../../src/datastore/lmdb/query/filter-using-index.ts"],"sourcesContent":["import { GatsbyIterable } from \"../../common/iterable\"\nimport {\n  DbComparator,\n  DbComparatorValue,\n  DbQuery,\n  dbQueryToDottedField,\n  getFilterStatement,\n  IDbFilterStatement,\n  sortBySpecificity,\n} from \"../../common/query\"\nimport { IDataStore, ILmdbDatabases, NodeId } from \"../../types\"\nimport {\n  IIndexMetadata,\n  IndexFieldValue,\n  IndexKey,\n  undefinedSymbol,\n} from \"./create-index\"\nimport { cartesianProduct, matchesFilter } from \"./common\"\nimport { inspect } from \"util\"\n\n// JS values encoded by ordered-binary never start with 0 or 255 byte\nexport const BinaryInfinityNegative = Buffer.from([0])\nexport const BinaryInfinityPositive = String.fromCharCode(255).repeat(4)\n\ntype RangeEdgeAfter = [IndexFieldValue, typeof BinaryInfinityPositive]\ntype RangeEdgeBefore = [typeof undefinedSymbol, IndexFieldValue]\ntype RangeValue =\n  | IndexFieldValue\n  | RangeEdgeAfter\n  | RangeEdgeBefore\n  | typeof BinaryInfinityPositive\n  | typeof BinaryInfinityNegative\ntype RangeBoundary = Array<RangeValue>\n\nexport interface IIndexEntry {\n  key: IndexKey\n  value: NodeId\n}\n\ninterface IIndexRange {\n  start: RangeBoundary\n  end: RangeBoundary\n}\n\nenum ValueEdges {\n  BEFORE = -1,\n  EQ = 0,\n  AFTER = 1,\n}\n\nexport interface IFilterArgs {\n  datastore: IDataStore\n  databases: ILmdbDatabases\n  dbQueries: Array<DbQuery>\n  indexMetadata: IIndexMetadata\n  limit?: number\n  skip?: number\n  reverse?: boolean\n}\n\ninterface IFilterContext extends IFilterArgs {\n  usedLimit: number | undefined\n  usedSkip: number\n  usedQueries: Set<DbQuery>\n}\n\nexport interface IFilterResult {\n  entries: GatsbyIterable<IIndexEntry>\n  usedQueries: Set<DbQuery>\n  usedLimit: number | undefined\n  usedSkip: number\n}\n\ninterface ILmdbStoreRangeOptions {\n  start?: any\n  end?: any\n  limit?: number | undefined\n  offset?: number | undefined\n  revers?: boolean\n  snapshot?: boolean\n}\n\nexport function filterUsingIndex(args: IFilterArgs): IFilterResult {\n  const context = createFilteringContext(args)\n  const ranges = getIndexRanges(context)\n\n  let entries =\n    ranges.length > 0\n      ? performRangeScan(context, ranges)\n      : performFullScan(context)\n\n  if (context.usedQueries.size !== args.dbQueries.length) {\n    // Try to additionally filter out results using data stored in index\n    entries = narrowResultsIfPossible(context, entries)\n  }\n  if (isMultiKeyIndex(context) && needsDeduplication(context)) {\n    entries = entries.deduplicate(getIdentifier)\n  }\n  return {\n    entries,\n    usedQueries: context.usedQueries,\n    usedLimit: context.usedLimit,\n    usedSkip: context.usedSkip,\n  }\n}\n\nexport function countUsingIndexOnly(args: IFilterArgs): number {\n  const context = createFilteringContext(args)\n  const {\n    databases: { indexes },\n    dbQueries,\n    indexMetadata: { keyPrefix },\n  } = args\n\n  const ranges = getIndexRanges(context)\n\n  if (context.usedQueries.size !== dbQueries.length) {\n    throw new Error(`Cannot count using index only`)\n  }\n  if (isMultiKeyIndex(context) && needsDeduplication(context)) {\n    throw new Error(`Cannot count using MultiKey index.`)\n  }\n  if (ranges.length === 0) {\n    const range: ILmdbStoreRangeOptions = {\n      start: [keyPrefix],\n      end: [getValueEdgeAfter(keyPrefix)],\n      snapshot: false,\n    }\n    return indexes.getKeysCount(range)\n  }\n  let count = 0\n  for (let { start, end } of ranges) {\n    start = [keyPrefix, ...start]\n    end = [keyPrefix, ...end]\n    // Assuming ranges are not overlapping\n    const range: ILmdbStoreRangeOptions = { start, end, snapshot: false }\n    count += indexes.getKeysCount(range)\n  }\n  return count\n}\n\nfunction createFilteringContext(args: IFilterArgs): IFilterContext {\n  return {\n    ...args,\n    usedLimit: undefined,\n    usedSkip: 0,\n    usedQueries: new Set<DbQuery>(),\n  }\n}\n\nfunction isMultiKeyIndex(context: IFilterContext): boolean {\n  return context.indexMetadata.multiKeyFields.length > 0\n}\n\nfunction needsDeduplication(context: IFilterContext): boolean {\n  if (!isMultiKeyIndex(context)) {\n    return false\n  }\n  // Deduplication is not needed if all multiKeyFields have applied `eq` filters\n  const fieldsWithAppliedEq = new Set<string>()\n  context.usedQueries.forEach(q => {\n    const filter = getFilterStatement(q)\n    if (filter.comparator === DbComparator.EQ) {\n      fieldsWithAppliedEq.add(dbQueryToDottedField(q))\n    }\n  })\n  return context.indexMetadata.multiKeyFields.some(\n    fieldName => !fieldsWithAppliedEq.has(fieldName)\n  )\n}\n\nfunction performRangeScan(\n  context: IFilterContext,\n  ranges: Array<IIndexRange>\n): GatsbyIterable<IIndexEntry> {\n  const {\n    indexMetadata: { keyPrefix, stats },\n    reverse,\n  } = context\n\n  let { limit, skip: offset = 0 } = context\n\n  if (context.dbQueries.length !== context.usedQueries.size) {\n    // Since this query is not fully satisfied by the index, we can't use limit/skip\n    limit = undefined\n    offset = 0\n  }\n  if (ranges.length > 1) {\n    // e.g. { in: [1, 2] }\n    // Cannot use offset: we will run several range queries and it's not clear which one to offset\n    // TODO: assuming ranges are sorted and not overlapping it should be possible to use offsets in this case\n    //   by running first range query, counting results while lazily iterating and\n    //   running the next range query when the previous iterator is done (and count is known)\n    //   with offset = offset - previousRangeCount, limit = limit - previousRangeCount\n    limit = typeof limit !== `undefined` ? offset + limit : undefined\n    offset = 0\n  }\n  if (limit && isMultiKeyIndex(context) && needsDeduplication(context)) {\n    // Cannot use limit:\n    // MultiKey index may contain duplicates - we can only set a safe upper bound\n    limit *= stats.maxKeysPerItem\n  }\n\n  // Assuming ranges are sorted and not overlapping, we can yield results sequentially\n  const lmdbRanges: Array<ILmdbStoreRangeOptions> = []\n  for (let { start, end } of ranges) {\n    start = [keyPrefix, ...start]\n    end = [keyPrefix, ...end]\n    const range = !reverse\n      ? { start, end, limit, offset, snapshot: false }\n      : { start: end, end: start, limit, offset, reverse, snapshot: false }\n\n    lmdbRanges.push(range)\n  }\n  context.usedLimit = limit\n  context.usedSkip = offset\n  return new GatsbyIterable(() => traverseRanges(context, lmdbRanges))\n}\n\nfunction performFullScan(context: IFilterContext): GatsbyIterable<IIndexEntry> {\n  // *Caveat*: our old query implementation was putting undefined and null values at the end\n  //   of the list when ordered ascending. But lmdb-store keeps them at the top.\n  //   So in LMDB case, need to concat two ranges to conform to our old format:\n  //     concat(undefinedToEnd, topToUndefined)\n  const {\n    reverse,\n    indexMetadata: { keyPrefix },\n  } = context\n\n  let start: RangeBoundary = [keyPrefix, getValueEdgeAfter(undefinedSymbol)]\n  let end: RangeBoundary = [getValueEdgeAfter(keyPrefix)]\n  let range = !reverse\n    ? { start, end, snapshot: false }\n    : { start: end, end: start, reverse, snapshot: false }\n\n  const undefinedToEnd = range\n\n  // Concat null/undefined values\n  end = start\n  start = [keyPrefix, null]\n  range = !reverse\n    ? { start, end, snapshot: false }\n    : { start: end, end: start, reverse, snapshot: false }\n\n  const topToUndefined = range\n\n  const ranges: Array<ILmdbStoreRangeOptions> = !reverse\n    ? [undefinedToEnd, topToUndefined]\n    : [topToUndefined, undefinedToEnd]\n\n  return new GatsbyIterable(() => traverseRanges(context, ranges))\n}\n\nfunction* traverseRanges(\n  context: IFilterContext,\n  ranges: Array<ILmdbStoreRangeOptions>\n): Generator<IIndexEntry> {\n  const {\n    databases: { indexes },\n  } = context\n\n  for (const range of ranges) {\n    // @ts-ignore\n    yield* indexes.getRange(range)\n  }\n}\n\n/**\n * Takes results after the index scan and tries to filter them additionally with unused parts of the query.\n *\n * This is O(N) but the advantage is that it uses data available in the index.\n * So it effectively bypasses the `getNode()` call for such filters (with all associated deserialization complexity).\n *\n * Example:\n *   Imagine the index is: { foo: 1, bar: 1 }\n *\n * Now we run the query:\n *   sort: [`foo`]\n *   filter: { bar: { eq: `test` }}\n *\n * Initial filtering pass will have to perform a full index scan (because `bar` is the last field in the index).\n *\n * But we still have values of `bar` stored in the index itself,\n * so can filter by this value without loading the full node contents.\n */\nfunction narrowResultsIfPossible(\n  context: IFilterContext,\n  entries: GatsbyIterable<IIndexEntry>\n): GatsbyIterable<IIndexEntry> {\n  const { indexMetadata, dbQueries, usedQueries } = context\n\n  const indexFields = new Map<string, number>()\n  indexMetadata.keyFields.forEach(([fieldName], positionInKey) => {\n    // Every index key is [indexId, field1, field2, ...] and `indexMetadata.keyFields` contains [field1, field2, ...]\n    // As `indexId` is in the first column the fields need to be offset by +1 for correct addressing\n    indexFields.set(fieldName, positionInKey + 1)\n  })\n\n  type Filter = [filter: IDbFilterStatement, fieldPositionInIndex: number]\n  const filtersToApply: Array<Filter> = []\n\n  for (const query of dbQueries) {\n    const fieldName = dbQueryToDottedField(query)\n    const positionInKey = indexFields.get(fieldName)\n\n    if (typeof positionInKey === `undefined`) {\n      // No data for this field in index\n      continue\n    }\n    if (usedQueries.has(query)) {\n      // Filter is already applied\n      continue\n    }\n    if (isMultiKeyIndex(context) && isNegatedQuery(query)) {\n      // NE/NIN not supported with MultiKey indexes:\n      //   MultiKey indexes include duplicates; negated queries will only filter some of those\n      //   but may still incorrectly include others in final results\n      continue\n    }\n    const filter = getFilterStatement(query)\n    filtersToApply.push([filter, positionInKey])\n    usedQueries.add(query)\n  }\n\n  return filtersToApply.length === 0\n    ? entries\n    : entries.filter(({ key }) => {\n        for (const [filter, fieldPositionInIndex] of filtersToApply) {\n          const value =\n            key[fieldPositionInIndex] === undefinedSymbol\n              ? undefined\n              : key[fieldPositionInIndex]\n\n          if (!matchesFilter(filter, value)) {\n            // Mimic AND semantics\n            return false\n          }\n        }\n        return true\n      })\n}\n\n/**\n * Returns query clauses that can potentially use index.\n * Returned list is sorted by query specificity\n */\nfunction getSupportedQueries(\n  context: IFilterContext,\n  dbQueries: Array<DbQuery>\n): Array<DbQuery> {\n  const isSupported = new Set([\n    DbComparator.EQ,\n    DbComparator.IN,\n    DbComparator.GTE,\n    DbComparator.LTE,\n    DbComparator.GT,\n    DbComparator.LT,\n    DbComparator.NIN,\n    DbComparator.NE,\n  ])\n  let supportedQueries = dbQueries.filter(query =>\n    isSupported.has(getFilterStatement(query).comparator)\n  )\n  if (isMultiKeyIndex(context)) {\n    // Note:\n    // NE and NIN are not supported by multi-key indexes. Why?\n    //   Imagine a node { id: 1, field: [`foo`, `bar`] }\n    //   Then the filter { field: { ne: `foo` } } should completely remove this node from results.\n    //   But multikey index contains separate entries for `foo` and `bar` values.\n    //   Final range will exclude entry \"foo\" but it will still include entry for \"bar\" hence\n    //   will incorrectly include our node in results.\n    supportedQueries = supportedQueries.filter(query => !isNegatedQuery(query))\n  }\n  return sortBySpecificity(supportedQueries)\n}\n\nfunction isEqualityQuery(query: DbQuery): boolean {\n  const filter = getFilterStatement(query)\n  return (\n    filter.comparator === DbComparator.EQ ||\n    filter.comparator === DbComparator.IN\n  )\n}\n\nfunction isNegatedQuery(query: DbQuery): boolean {\n  const filter = getFilterStatement(query)\n  return (\n    filter.comparator === DbComparator.NE ||\n    filter.comparator === DbComparator.NIN\n  )\n}\n\nexport function getIndexRanges(context: IFilterContext): Array<IIndexRange> {\n  const {\n    dbQueries,\n    indexMetadata: { keyFields },\n  } = context\n  const rangeStarts: Array<RangeBoundary> = []\n  const rangeEndings: Array<RangeBoundary> = []\n  const supportedQueries = getSupportedQueries(context, dbQueries)\n\n  for (const indexFieldInfo of new Map(keyFields)) {\n    const query = getMostSpecificQuery(supportedQueries, indexFieldInfo)\n    if (!query) {\n      // Use index prefix, not all index fields\n      break\n    }\n    const result = resolveIndexFieldRanges(context, query, indexFieldInfo)\n    rangeStarts.push(result.rangeStarts)\n    rangeEndings.push(result.rangeEndings)\n\n    if (!isEqualityQuery(query)) {\n      // Compound index { a: 1, b: 1, c: 1 } supports only one non-eq (range) operator. E.g.:\n      //  Supported: { a: { eq: `foo` }, b: { eq: 8 }, c: { gt: 5 } }\n      //  Not supported: { a: { eq: `foo` }, b: { gt: 5 }, c: { eq: 5 } }\n      //  (or to be precise, can do a range scan only for { a: { eq: `foo` }, b: { gt: 5 } })\n      break\n    }\n  }\n  if (!rangeStarts.length) {\n    return []\n  }\n  // Only the last segment encloses the whole range.\n  // For example, given an index { a: 1, b: 1 } and a filter { a: { eq: `foo` }, b: { eq: `bar` } },\n  // It should produce this range:\n  // {\n  //   start: [`foo`, `bar`],\n  //   end: [`foo`, [`bar`, BinaryInfinityPositive]]\n  // }\n  //\n  // Not this:\n  // {\n  //   start: [`foo`, `bar`],\n  //   end: [[`foo`, BinaryInfinityPositive], [`bar`, BinaryInfinityPositive]]\n  // }\n  for (let i = 0; i < rangeStarts.length - 1; i++) {\n    rangeEndings[i] = rangeStarts[i]\n  }\n\n  // Example:\n  //   rangeStarts: [\n  //     [field1Start1, field1Start2],\n  //     [field2Start1],\n  //   ]\n  //   rangeEnds: [\n  //     [field1End1, field1End2],\n  //     [field2End1],\n  //   ]\n  // Need:\n  //   rangeStartsProduct: [\n  //     [field1Start1, field2Start1],\n  //     [field1Start2, field2Start1],\n  //   ]\n  //   rangeEndingsProduct: [\n  //     [field1End1, field2End1],\n  //     [field1End2, field2End1],\n  //   ]\n  const rangeStartsProduct = cartesianProduct(...rangeStarts)\n  const rangeEndingsProduct = cartesianProduct(...rangeEndings)\n\n  const ranges: Array<IIndexRange> = []\n  for (let i = 0; i < rangeStartsProduct.length; i++) {\n    ranges.push({\n      start: rangeStartsProduct[i],\n      end: rangeEndingsProduct[i],\n    })\n  }\n  // TODO: sort and intersect ranges. Also, we may want this at some point:\n  //   https://docs.mongodb.com/manual/core/multikey-index-bounds/\n  return ranges\n}\n\nfunction getFieldQueries(\n  queries: Array<DbQuery>,\n  fieldName: string\n): Array<DbQuery> {\n  return queries.filter(q => dbQueryToDottedField(q) === fieldName)\n}\n\nfunction getMostSpecificQuery(\n  queries: Array<DbQuery>,\n  [indexField]: [fieldName: string, sortDirection: number]\n): DbQuery | undefined {\n  const fieldQueries = getFieldQueries(queries, indexField)\n  // Assuming queries are sorted by specificity, the best bet is to pick the first query\n  return fieldQueries[0]\n}\n\nfunction resolveIndexFieldRanges(\n  context: IFilterContext,\n  query: DbQuery,\n  [field, sortDirection]: [fieldName: string, sortDirection: number]\n): {\n  rangeStarts: RangeBoundary\n  rangeEndings: RangeBoundary\n} {\n  // Tracking starts and ends separately instead of doing Array<[start, end]>\n  //  to simplify cartesian product creation later\n  const rangeStarts: RangeBoundary = []\n  const rangeEndings: RangeBoundary = []\n\n  const filter = getFilterStatement(query)\n\n  if (filter.comparator === DbComparator.IN && !Array.isArray(filter.value)) {\n    throw new Error(\"The argument to the `in` predicate should be an array\")\n  }\n\n  context.usedQueries.add(query)\n\n  switch (filter.comparator) {\n    case DbComparator.EQ:\n    case DbComparator.IN: {\n      const arr = Array.isArray(filter.value)\n        ? [...filter.value]\n        : [filter.value]\n\n      // Sort ranges by index sort direction\n      arr.sort((a: any, b: any): number => {\n        if (a === b) return 0\n        if (sortDirection === 1) return a > b ? 1 : -1\n        return a < b ? 1 : -1\n      })\n\n      let hasNull = false\n      for (const item of new Set(arr)) {\n        const value = toIndexFieldValue(item, filter)\n        if (value === null) hasNull = true\n        rangeStarts.push(value)\n        rangeEndings.push(getValueEdgeAfter(value))\n      }\n      // Special case: { eq: null } or { in: [null, `any`]} must also include values for undefined!\n      if (hasNull) {\n        rangeStarts.push(undefinedSymbol)\n        rangeEndings.push(getValueEdgeAfter(undefinedSymbol))\n      }\n      break\n    }\n    case DbComparator.LT:\n    case DbComparator.LTE: {\n      if (Array.isArray(filter.value))\n        throw new Error(`${filter.comparator} value must not be an array`)\n\n      const value = toIndexFieldValue(filter.value, filter)\n      const end =\n        filter.comparator === DbComparator.LT ? value : getValueEdgeAfter(value)\n\n      // Try to find matching GTE/GT filter\n      const start =\n        resolveRangeEdge(context, field, DbComparator.GTE) ??\n        resolveRangeEdge(context, field, DbComparator.GT, ValueEdges.AFTER)\n\n      // Do not include null or undefined in results unless null was requested explicitly\n      //\n      // Index ordering:\n      //  BinaryInfinityNegative\n      //  null\n      //  Symbol(`undef`)\n      //  -10\n      //  10\n      //  `Hello`\n      //  [`Hello`]\n      //  BinaryInfinityPositive\n      const rangeHead =\n        value === null\n          ? BinaryInfinityNegative\n          : getValueEdgeAfter(undefinedSymbol)\n\n      rangeStarts.push(start ?? rangeHead)\n      rangeEndings.push(end)\n      break\n    }\n    case DbComparator.GT:\n    case DbComparator.GTE: {\n      if (Array.isArray(filter.value))\n        throw new Error(`${filter.comparator} value must not be an array`)\n\n      const value = toIndexFieldValue(filter.value, filter)\n      const start =\n        filter.comparator === DbComparator.GTE\n          ? value\n          : getValueEdgeAfter(value)\n\n      // Try to find matching LT/LTE\n      const end =\n        resolveRangeEdge(context, field, DbComparator.LTE, ValueEdges.AFTER) ??\n        resolveRangeEdge(context, field, DbComparator.LT)\n\n      const rangeTail =\n        value === null ? getValueEdgeAfter(null) : BinaryInfinityPositive\n\n      rangeStarts.push(start)\n      rangeEndings.push(end ?? rangeTail)\n      break\n    }\n    case DbComparator.NE:\n    case DbComparator.NIN: {\n      const arr = Array.isArray(filter.value)\n        ? [...filter.value]\n        : [filter.value]\n\n      // Sort ranges by index sort direction\n      arr.sort((a: any, b: any): number => {\n        if (a === b) return 0\n        if (sortDirection === 1) return a > b ? 1 : -1\n        return a < b ? 1 : -1\n      })\n      const hasNull = arr.some(value => value === null)\n\n      if (hasNull) {\n        rangeStarts.push(getValueEdgeAfter(undefinedSymbol))\n      } else {\n        rangeStarts.push(BinaryInfinityNegative)\n      }\n      for (const item of new Set(arr)) {\n        const value = toIndexFieldValue(item, filter)\n        if (value === null) continue // already handled via hasNull case above\n        rangeEndings.push(value)\n        rangeStarts.push(getValueEdgeAfter(value))\n      }\n      rangeEndings.push(BinaryInfinityPositive)\n      break\n    }\n    default:\n      throw new Error(`Unsupported predicate: ${filter.comparator}`)\n  }\n  return { rangeStarts, rangeEndings }\n}\n\nfunction resolveRangeEdge(\n  context: IFilterContext,\n  indexField: string,\n  predicate: DbComparator,\n  edge: ValueEdges = ValueEdges.EQ\n): IndexFieldValue | RangeEdgeBefore | RangeEdgeAfter | undefined {\n  const fieldQueries = getFieldQueries(context.dbQueries, indexField)\n  for (const dbQuery of fieldQueries) {\n    if (context.usedQueries.has(dbQuery)) {\n      continue\n    }\n    const filterStatement = getFilterStatement(dbQuery)\n    if (filterStatement.comparator !== predicate) {\n      continue\n    }\n    context.usedQueries.add(dbQuery)\n    const value = filterStatement.value\n    if (Array.isArray(value)) {\n      throw new Error(`Range filter ${predicate} should not have array value`)\n    }\n    if (typeof value === `object` && value !== null) {\n      throw new Error(\n        `Range filter ${predicate} should not have value of type ${typeof value}`\n      )\n    }\n    if (edge === 0) {\n      return value\n    }\n    return edge < 0 ? getValueEdgeBefore(value) : getValueEdgeAfter(value)\n  }\n  return undefined\n}\n\n/**\n * Returns the edge after the given value, suitable for lmdb range queries.\n *\n * Example:\n * Get all items from index starting with [\"foo\"] prefix up to the next existing prefix:\n *\n * ```js\n *   db.getRange({ start: [\"foo\"], end: [getValueEdgeAfter(\"foo\")] })\n * ```\n *\n * This method relies on ordered-binary format used by lmdb-store to persist keys\n * and assumes keys are composite and represented as arrays.\n *\n * Implementation detail: ordered-binary treats `null` as multipart separator within binary sequence\n */\nfunction getValueEdgeAfter(value: IndexFieldValue): RangeEdgeAfter {\n  return [value, BinaryInfinityPositive]\n}\nfunction getValueEdgeBefore(value: IndexFieldValue): RangeEdgeBefore {\n  return [undefinedSymbol, value]\n}\n\nfunction toIndexFieldValue(\n  filterValue: DbComparatorValue,\n  filter: IDbFilterStatement\n): IndexFieldValue {\n  if (typeof filterValue === `object` && filterValue !== null) {\n    throw new Error(\n      `Bad filter value for predicate ${filter.comparator}: ${inspect(\n        filter.value\n      )}`\n    )\n  }\n  return filterValue\n}\n\nfunction getIdentifier(entry: IIndexEntry): number | string {\n  const id = entry.key[entry.key.length - 1]\n  if (typeof id !== `number` && typeof id !== `string`) {\n    const out = inspect(id)\n    throw new Error(\n      `Last element of index key is expected to be numeric or string id, got ${out}`\n    )\n  }\n  return id\n}\n"],"mappings":";;;;;;;AAAA;AACA;AAUA;AAMA;AACA;AAEA;AACO,MAAMA,sBAAsB,GAAGC,MAAM,CAACC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;AAAA;AAC/C,MAAMC,sBAAsB,GAAGC,MAAM,CAACC,YAAY,CAAC,GAAG,CAAC,CAACC,MAAM,CAAC,CAAC,CAAC;AAAA;AAAA,IAsBnEC,UAAU;AAAA,WAAVA,UAAU;EAAVA,UAAU,CAAVA,UAAU;EAAVA,UAAU,CAAVA,UAAU;EAAVA,UAAU,CAAVA,UAAU;AAAA,GAAVA,UAAU,KAAVA,UAAU;AAsCR,SAASC,gBAAgB,CAACC,IAAiB,EAAiB;EACjE,MAAMC,OAAO,GAAGC,sBAAsB,CAACF,IAAI,CAAC;EAC5C,MAAMG,MAAM,GAAGC,cAAc,CAACH,OAAO,CAAC;EAEtC,IAAII,OAAO,GACTF,MAAM,CAACG,MAAM,GAAG,CAAC,GACbC,gBAAgB,CAACN,OAAO,EAAEE,MAAM,CAAC,GACjCK,eAAe,CAACP,OAAO,CAAC;EAE9B,IAAIA,OAAO,CAACQ,WAAW,CAACC,IAAI,KAAKV,IAAI,CAACW,SAAS,CAACL,MAAM,EAAE;IACtD;IACAD,OAAO,GAAGO,uBAAuB,CAACX,OAAO,EAAEI,OAAO,CAAC;EACrD;EACA,IAAIQ,eAAe,CAACZ,OAAO,CAAC,IAAIa,kBAAkB,CAACb,OAAO,CAAC,EAAE;IAC3DI,OAAO,GAAGA,OAAO,CAACU,WAAW,CAACC,aAAa,CAAC;EAC9C;EACA,OAAO;IACLX,OAAO;IACPI,WAAW,EAAER,OAAO,CAACQ,WAAW;IAChCQ,SAAS,EAAEhB,OAAO,CAACgB,SAAS;IAC5BC,QAAQ,EAAEjB,OAAO,CAACiB;EACpB,CAAC;AACH;AAEO,SAASC,mBAAmB,CAACnB,IAAiB,EAAU;EAC7D,MAAMC,OAAO,GAAGC,sBAAsB,CAACF,IAAI,CAAC;EAC5C,MAAM;IACJoB,SAAS,EAAE;MAAEC;IAAQ,CAAC;IACtBV,SAAS;IACTW,aAAa,EAAE;MAAEC;IAAU;EAC7B,CAAC,GAAGvB,IAAI;EAER,MAAMG,MAAM,GAAGC,cAAc,CAACH,OAAO,CAAC;EAEtC,IAAIA,OAAO,CAACQ,WAAW,CAACC,IAAI,KAAKC,SAAS,CAACL,MAAM,EAAE;IACjD,MAAM,IAAIkB,KAAK,CAAE,+BAA8B,CAAC;EAClD;EACA,IAAIX,eAAe,CAACZ,OAAO,CAAC,IAAIa,kBAAkB,CAACb,OAAO,CAAC,EAAE;IAC3D,MAAM,IAAIuB,KAAK,CAAE,oCAAmC,CAAC;EACvD;EACA,IAAIrB,MAAM,CAACG,MAAM,KAAK,CAAC,EAAE;IACvB,MAAMmB,KAA6B,GAAG;MACpCC,KAAK,EAAE,CAACH,SAAS,CAAC;MAClBI,GAAG,EAAE,CAACC,iBAAiB,CAACL,SAAS,CAAC,CAAC;MACnCM,QAAQ,EAAE;IACZ,CAAC;IACD,OAAOR,OAAO,CAACS,YAAY,CAACL,KAAK,CAAC;EACpC;EACA,IAAIM,KAAK,GAAG,CAAC;EACb,KAAK,IAAI;IAAEL,KAAK;IAAEC;EAAI,CAAC,IAAIxB,MAAM,EAAE;IACjCuB,KAAK,GAAG,CAACH,SAAS,EAAE,GAAGG,KAAK,CAAC;IAC7BC,GAAG,GAAG,CAACJ,SAAS,EAAE,GAAGI,GAAG,CAAC;IACzB;IACA,MAAMF,KAA6B,GAAG;MAAEC,KAAK;MAAEC,GAAG;MAAEE,QAAQ,EAAE;IAAM,CAAC;IACrEE,KAAK,IAAIV,OAAO,CAACS,YAAY,CAACL,KAAK,CAAC;EACtC;EACA,OAAOM,KAAK;AACd;AAEA,SAAS7B,sBAAsB,CAACF,IAAiB,EAAkB;EACjE,OAAO;IACL,GAAGA,IAAI;IACPiB,SAAS,EAAEe,SAAS;IACpBd,QAAQ,EAAE,CAAC;IACXT,WAAW,EAAE,IAAIwB,GAAG;EACtB,CAAC;AACH;AAEA,SAASpB,eAAe,CAACZ,OAAuB,EAAW;EACzD,OAAOA,OAAO,CAACqB,aAAa,CAACY,cAAc,CAAC5B,MAAM,GAAG,CAAC;AACxD;AAEA,SAASQ,kBAAkB,CAACb,OAAuB,EAAW;EAC5D,IAAI,CAACY,eAAe,CAACZ,OAAO,CAAC,EAAE;IAC7B,OAAO,KAAK;EACd;EACA;EACA,MAAMkC,mBAAmB,GAAG,IAAIF,GAAG,EAAU;EAC7ChC,OAAO,CAACQ,WAAW,CAAC2B,OAAO,CAACC,CAAC,IAAI;IAC/B,MAAMC,MAAM,GAAG,IAAAC,yBAAkB,EAACF,CAAC,CAAC;IACpC,IAAIC,MAAM,CAACE,UAAU,KAAKC,mBAAY,CAACC,EAAE,EAAE;MACzCP,mBAAmB,CAACQ,GAAG,CAAC,IAAAC,2BAAoB,EAACP,CAAC,CAAC,CAAC;IAClD;EACF,CAAC,CAAC;EACF,OAAOpC,OAAO,CAACqB,aAAa,CAACY,cAAc,CAACW,IAAI,CAC9CC,SAAS,IAAI,CAACX,mBAAmB,CAACY,GAAG,CAACD,SAAS,CAAC,CACjD;AACH;AAEA,SAASvC,gBAAgB,CACvBN,OAAuB,EACvBE,MAA0B,EACG;EAC7B,MAAM;IACJmB,aAAa,EAAE;MAAEC,SAAS;MAAEyB;IAAM,CAAC;IACnCC;EACF,CAAC,GAAGhD,OAAO;EAEX,IAAI;IAAEiD,KAAK;IAAEC,IAAI,EAAEC,MAAM,GAAG;EAAE,CAAC,GAAGnD,OAAO;EAEzC,IAAIA,OAAO,CAACU,SAAS,CAACL,MAAM,KAAKL,OAAO,CAACQ,WAAW,CAACC,IAAI,EAAE;IACzD;IACAwC,KAAK,GAAGlB,SAAS;IACjBoB,MAAM,GAAG,CAAC;EACZ;EACA,IAAIjD,MAAM,CAACG,MAAM,GAAG,CAAC,EAAE;IACrB;IACA;IACA;IACA;IACA;IACA;IACA4C,KAAK,GAAG,OAAOA,KAAK,KAAM,WAAU,GAAGE,MAAM,GAAGF,KAAK,GAAGlB,SAAS;IACjEoB,MAAM,GAAG,CAAC;EACZ;EACA,IAAIF,KAAK,IAAIrC,eAAe,CAACZ,OAAO,CAAC,IAAIa,kBAAkB,CAACb,OAAO,CAAC,EAAE;IACpE;IACA;IACAiD,KAAK,IAAIF,KAAK,CAACK,cAAc;EAC/B;;EAEA;EACA,MAAMC,UAAyC,GAAG,EAAE;EACpD,KAAK,IAAI;IAAE5B,KAAK;IAAEC;EAAI,CAAC,IAAIxB,MAAM,EAAE;IACjCuB,KAAK,GAAG,CAACH,SAAS,EAAE,GAAGG,KAAK,CAAC;IAC7BC,GAAG,GAAG,CAACJ,SAAS,EAAE,GAAGI,GAAG,CAAC;IACzB,MAAMF,KAAK,GAAG,CAACwB,OAAO,GAClB;MAAEvB,KAAK;MAAEC,GAAG;MAAEuB,KAAK;MAAEE,MAAM;MAAEvB,QAAQ,EAAE;IAAM,CAAC,GAC9C;MAAEH,KAAK,EAAEC,GAAG;MAAEA,GAAG,EAAED,KAAK;MAAEwB,KAAK;MAAEE,MAAM;MAAEH,OAAO;MAAEpB,QAAQ,EAAE;IAAM,CAAC;IAEvEyB,UAAU,CAACC,IAAI,CAAC9B,KAAK,CAAC;EACxB;EACAxB,OAAO,CAACgB,SAAS,GAAGiC,KAAK;EACzBjD,OAAO,CAACiB,QAAQ,GAAGkC,MAAM;EACzB,OAAO,IAAII,wBAAc,CAAC,MAAMC,cAAc,CAACxD,OAAO,EAAEqD,UAAU,CAAC,CAAC;AACtE;AAEA,SAAS9C,eAAe,CAACP,OAAuB,EAA+B;EAC7E;EACA;EACA;EACA;EACA,MAAM;IACJgD,OAAO;IACP3B,aAAa,EAAE;MAAEC;IAAU;EAC7B,CAAC,GAAGtB,OAAO;EAEX,IAAIyB,KAAoB,GAAG,CAACH,SAAS,EAAEK,iBAAiB,CAAC8B,4BAAe,CAAC,CAAC;EAC1E,IAAI/B,GAAkB,GAAG,CAACC,iBAAiB,CAACL,SAAS,CAAC,CAAC;EACvD,IAAIE,KAAK,GAAG,CAACwB,OAAO,GAChB;IAAEvB,KAAK;IAAEC,GAAG;IAAEE,QAAQ,EAAE;EAAM,CAAC,GAC/B;IAAEH,KAAK,EAAEC,GAAG;IAAEA,GAAG,EAAED,KAAK;IAAEuB,OAAO;IAAEpB,QAAQ,EAAE;EAAM,CAAC;EAExD,MAAM8B,cAAc,GAAGlC,KAAK;;EAE5B;EACAE,GAAG,GAAGD,KAAK;EACXA,KAAK,GAAG,CAACH,SAAS,EAAE,IAAI,CAAC;EACzBE,KAAK,GAAG,CAACwB,OAAO,GACZ;IAAEvB,KAAK;IAAEC,GAAG;IAAEE,QAAQ,EAAE;EAAM,CAAC,GAC/B;IAAEH,KAAK,EAAEC,GAAG;IAAEA,GAAG,EAAED,KAAK;IAAEuB,OAAO;IAAEpB,QAAQ,EAAE;EAAM,CAAC;EAExD,MAAM+B,cAAc,GAAGnC,KAAK;EAE5B,MAAMtB,MAAqC,GAAG,CAAC8C,OAAO,GAClD,CAACU,cAAc,EAAEC,cAAc,CAAC,GAChC,CAACA,cAAc,EAAED,cAAc,CAAC;EAEpC,OAAO,IAAIH,wBAAc,CAAC,MAAMC,cAAc,CAACxD,OAAO,EAAEE,MAAM,CAAC,CAAC;AAClE;AAEA,UAAUsD,cAAc,CACtBxD,OAAuB,EACvBE,MAAqC,EACb;EACxB,MAAM;IACJiB,SAAS,EAAE;MAAEC;IAAQ;EACvB,CAAC,GAAGpB,OAAO;EAEX,KAAK,MAAMwB,KAAK,IAAItB,MAAM,EAAE;IAC1B;IACA,OAAOkB,OAAO,CAACwC,QAAQ,CAACpC,KAAK,CAAC;EAChC;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASb,uBAAuB,CAC9BX,OAAuB,EACvBI,OAAoC,EACP;EAC7B,MAAM;IAAEiB,aAAa;IAAEX,SAAS;IAAEF;EAAY,CAAC,GAAGR,OAAO;EAEzD,MAAM6D,WAAW,GAAG,IAAIC,GAAG,EAAkB;EAC7CzC,aAAa,CAAC0C,SAAS,CAAC5B,OAAO,CAAC,CAAC,CAACU,SAAS,CAAC,EAAEmB,aAAa,KAAK;IAC9D;IACA;IACAH,WAAW,CAACI,GAAG,CAACpB,SAAS,EAAEmB,aAAa,GAAG,CAAC,CAAC;EAC/C,CAAC,CAAC;EAGF,MAAME,cAA6B,GAAG,EAAE;EAExC,KAAK,MAAMC,KAAK,IAAIzD,SAAS,EAAE;IAC7B,MAAMmC,SAAS,GAAG,IAAAF,2BAAoB,EAACwB,KAAK,CAAC;IAC7C,MAAMH,aAAa,GAAGH,WAAW,CAACO,GAAG,CAACvB,SAAS,CAAC;IAEhD,IAAI,OAAOmB,aAAa,KAAM,WAAU,EAAE;MACxC;MACA;IACF;IACA,IAAIxD,WAAW,CAACsC,GAAG,CAACqB,KAAK,CAAC,EAAE;MAC1B;MACA;IACF;IACA,IAAIvD,eAAe,CAACZ,OAAO,CAAC,IAAIqE,cAAc,CAACF,KAAK,CAAC,EAAE;MACrD;MACA;MACA;MACA;IACF;IACA,MAAM9B,MAAM,GAAG,IAAAC,yBAAkB,EAAC6B,KAAK,CAAC;IACxCD,cAAc,CAACZ,IAAI,CAAC,CAACjB,MAAM,EAAE2B,aAAa,CAAC,CAAC;IAC5CxD,WAAW,CAACkC,GAAG,CAACyB,KAAK,CAAC;EACxB;EAEA,OAAOD,cAAc,CAAC7D,MAAM,KAAK,CAAC,GAC9BD,OAAO,GACPA,OAAO,CAACiC,MAAM,CAAC,CAAC;IAAEiC;EAAI,CAAC,KAAK;IAC1B,KAAK,MAAM,CAACjC,MAAM,EAAEkC,oBAAoB,CAAC,IAAIL,cAAc,EAAE;MAC3D,MAAMM,KAAK,GACTF,GAAG,CAACC,oBAAoB,CAAC,KAAKd,4BAAe,GACzC1B,SAAS,GACTuC,GAAG,CAACC,oBAAoB,CAAC;MAE/B,IAAI,CAAC,IAAAE,qBAAa,EAACpC,MAAM,EAAEmC,KAAK,CAAC,EAAE;QACjC;QACA,OAAO,KAAK;MACd;IACF;IACA,OAAO,IAAI;EACb,CAAC,CAAC;AACR;;AAEA;AACA;AACA;AACA;AACA,SAASE,mBAAmB,CAC1B1E,OAAuB,EACvBU,SAAyB,EACT;EAChB,MAAMiE,WAAW,GAAG,IAAI3C,GAAG,CAAC,CAC1BQ,mBAAY,CAACC,EAAE,EACfD,mBAAY,CAACoC,EAAE,EACfpC,mBAAY,CAACqC,GAAG,EAChBrC,mBAAY,CAACsC,GAAG,EAChBtC,mBAAY,CAACuC,EAAE,EACfvC,mBAAY,CAACwC,EAAE,EACfxC,mBAAY,CAACyC,GAAG,EAChBzC,mBAAY,CAAC0C,EAAE,CAChB,CAAC;EACF,IAAIC,gBAAgB,GAAGzE,SAAS,CAAC2B,MAAM,CAAC8B,KAAK,IAC3CQ,WAAW,CAAC7B,GAAG,CAAC,IAAAR,yBAAkB,EAAC6B,KAAK,CAAC,CAAC5B,UAAU,CAAC,CACtD;EACD,IAAI3B,eAAe,CAACZ,OAAO,CAAC,EAAE;IAC5B;IACA;IACA;IACA;IACA;IACA;IACA;IACAmF,gBAAgB,GAAGA,gBAAgB,CAAC9C,MAAM,CAAC8B,KAAK,IAAI,CAACE,cAAc,CAACF,KAAK,CAAC,CAAC;EAC7E;EACA,OAAO,IAAAiB,wBAAiB,EAACD,gBAAgB,CAAC;AAC5C;AAEA,SAASE,eAAe,CAAClB,KAAc,EAAW;EAChD,MAAM9B,MAAM,GAAG,IAAAC,yBAAkB,EAAC6B,KAAK,CAAC;EACxC,OACE9B,MAAM,CAACE,UAAU,KAAKC,mBAAY,CAACC,EAAE,IACrCJ,MAAM,CAACE,UAAU,KAAKC,mBAAY,CAACoC,EAAE;AAEzC;AAEA,SAASP,cAAc,CAACF,KAAc,EAAW;EAC/C,MAAM9B,MAAM,GAAG,IAAAC,yBAAkB,EAAC6B,KAAK,CAAC;EACxC,OACE9B,MAAM,CAACE,UAAU,KAAKC,mBAAY,CAAC0C,EAAE,IACrC7C,MAAM,CAACE,UAAU,KAAKC,mBAAY,CAACyC,GAAG;AAE1C;AAEO,SAAS9E,cAAc,CAACH,OAAuB,EAAsB;EAC1E,MAAM;IACJU,SAAS;IACTW,aAAa,EAAE;MAAE0C;IAAU;EAC7B,CAAC,GAAG/D,OAAO;EACX,MAAMsF,WAAiC,GAAG,EAAE;EAC5C,MAAMC,YAAkC,GAAG,EAAE;EAC7C,MAAMJ,gBAAgB,GAAGT,mBAAmB,CAAC1E,OAAO,EAAEU,SAAS,CAAC;EAEhE,KAAK,MAAM8E,cAAc,IAAI,IAAI1B,GAAG,CAACC,SAAS,CAAC,EAAE;IAC/C,MAAMI,KAAK,GAAGsB,oBAAoB,CAACN,gBAAgB,EAAEK,cAAc,CAAC;IACpE,IAAI,CAACrB,KAAK,EAAE;MACV;MACA;IACF;IACA,MAAMuB,MAAM,GAAGC,uBAAuB,CAAC3F,OAAO,EAAEmE,KAAK,EAAEqB,cAAc,CAAC;IACtEF,WAAW,CAAChC,IAAI,CAACoC,MAAM,CAACJ,WAAW,CAAC;IACpCC,YAAY,CAACjC,IAAI,CAACoC,MAAM,CAACH,YAAY,CAAC;IAEtC,IAAI,CAACF,eAAe,CAAClB,KAAK,CAAC,EAAE;MAC3B;MACA;MACA;MACA;MACA;IACF;EACF;EACA,IAAI,CAACmB,WAAW,CAACjF,MAAM,EAAE;IACvB,OAAO,EAAE;EACX;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA,KAAK,IAAIuF,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGN,WAAW,CAACjF,MAAM,GAAG,CAAC,EAAEuF,CAAC,EAAE,EAAE;IAC/CL,YAAY,CAACK,CAAC,CAAC,GAAGN,WAAW,CAACM,CAAC,CAAC;EAClC;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA,MAAMC,kBAAkB,GAAG,IAAAC,wBAAgB,EAAC,GAAGR,WAAW,CAAC;EAC3D,MAAMS,mBAAmB,GAAG,IAAAD,wBAAgB,EAAC,GAAGP,YAAY,CAAC;EAE7D,MAAMrF,MAA0B,GAAG,EAAE;EACrC,KAAK,IAAI0F,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGC,kBAAkB,CAACxF,MAAM,EAAEuF,CAAC,EAAE,EAAE;IAClD1F,MAAM,CAACoD,IAAI,CAAC;MACV7B,KAAK,EAAEoE,kBAAkB,CAACD,CAAC,CAAC;MAC5BlE,GAAG,EAAEqE,mBAAmB,CAACH,CAAC;IAC5B,CAAC,CAAC;EACJ;EACA;EACA;EACA,OAAO1F,MAAM;AACf;AAEA,SAAS8F,eAAe,CACtBC,OAAuB,EACvBpD,SAAiB,EACD;EAChB,OAAOoD,OAAO,CAAC5D,MAAM,CAACD,CAAC,IAAI,IAAAO,2BAAoB,EAACP,CAAC,CAAC,KAAKS,SAAS,CAAC;AACnE;AAEA,SAAS4C,oBAAoB,CAC3BQ,OAAuB,EACvB,CAACC,UAAU,CAA6C,EACnC;EACrB,MAAMC,YAAY,GAAGH,eAAe,CAACC,OAAO,EAAEC,UAAU,CAAC;EACzD;EACA,OAAOC,YAAY,CAAC,CAAC,CAAC;AACxB;AAEA,SAASR,uBAAuB,CAC9B3F,OAAuB,EACvBmE,KAAc,EACd,CAACiC,KAAK,EAAEC,aAAa,CAA6C,EAIlE;EACA;EACA;EACA,MAAMf,WAA0B,GAAG,EAAE;EACrC,MAAMC,YAA2B,GAAG,EAAE;EAEtC,MAAMlD,MAAM,GAAG,IAAAC,yBAAkB,EAAC6B,KAAK,CAAC;EAExC,IAAI9B,MAAM,CAACE,UAAU,KAAKC,mBAAY,CAACoC,EAAE,IAAI,CAAC0B,KAAK,CAACC,OAAO,CAAClE,MAAM,CAACmC,KAAK,CAAC,EAAE;IACzE,MAAM,IAAIjD,KAAK,CAAC,uDAAuD,CAAC;EAC1E;EAEAvB,OAAO,CAACQ,WAAW,CAACkC,GAAG,CAACyB,KAAK,CAAC;EAE9B,QAAQ9B,MAAM,CAACE,UAAU;IACvB,KAAKC,mBAAY,CAACC,EAAE;IACpB,KAAKD,mBAAY,CAACoC,EAAE;MAAE;QACpB,MAAM4B,GAAG,GAAGF,KAAK,CAACC,OAAO,CAAClE,MAAM,CAACmC,KAAK,CAAC,GACnC,CAAC,GAAGnC,MAAM,CAACmC,KAAK,CAAC,GACjB,CAACnC,MAAM,CAACmC,KAAK,CAAC;;QAElB;QACAgC,GAAG,CAACC,IAAI,CAAC,CAACC,CAAM,EAAEC,CAAM,KAAa;UACnC,IAAID,CAAC,KAAKC,CAAC,EAAE,OAAO,CAAC;UACrB,IAAIN,aAAa,KAAK,CAAC,EAAE,OAAOK,CAAC,GAAGC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;UAC9C,OAAOD,CAAC,GAAGC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;QACvB,CAAC,CAAC;QAEF,IAAIC,OAAO,GAAG,KAAK;QACnB,KAAK,MAAMC,IAAI,IAAI,IAAI7E,GAAG,CAACwE,GAAG,CAAC,EAAE;UAC/B,MAAMhC,KAAK,GAAGsC,iBAAiB,CAACD,IAAI,EAAExE,MAAM,CAAC;UAC7C,IAAImC,KAAK,KAAK,IAAI,EAAEoC,OAAO,GAAG,IAAI;UAClCtB,WAAW,CAAChC,IAAI,CAACkB,KAAK,CAAC;UACvBe,YAAY,CAACjC,IAAI,CAAC3B,iBAAiB,CAAC6C,KAAK,CAAC,CAAC;QAC7C;QACA;QACA,IAAIoC,OAAO,EAAE;UACXtB,WAAW,CAAChC,IAAI,CAACG,4BAAe,CAAC;UACjC8B,YAAY,CAACjC,IAAI,CAAC3B,iBAAiB,CAAC8B,4BAAe,CAAC,CAAC;QACvD;QACA;MACF;IACA,KAAKjB,mBAAY,CAACwC,EAAE;IACpB,KAAKxC,mBAAY,CAACsC,GAAG;MAAE;QAAA;QACrB,IAAIwB,KAAK,CAACC,OAAO,CAAClE,MAAM,CAACmC,KAAK,CAAC,EAC7B,MAAM,IAAIjD,KAAK,CAAE,GAAEc,MAAM,CAACE,UAAW,6BAA4B,CAAC;QAEpE,MAAMiC,KAAK,GAAGsC,iBAAiB,CAACzE,MAAM,CAACmC,KAAK,EAAEnC,MAAM,CAAC;QACrD,MAAMX,GAAG,GACPW,MAAM,CAACE,UAAU,KAAKC,mBAAY,CAACwC,EAAE,GAAGR,KAAK,GAAG7C,iBAAiB,CAAC6C,KAAK,CAAC;;QAE1E;QACA,MAAM/C,KAAK,wBACTsF,gBAAgB,CAAC/G,OAAO,EAAEoG,KAAK,EAAE5D,mBAAY,CAACqC,GAAG,CAAC,iEAClDkC,gBAAgB,CAAC/G,OAAO,EAAEoG,KAAK,EAAE5D,mBAAY,CAACuC,EAAE,EAAElF,UAAU,CAACmH,KAAK,CAAC;;QAErE;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,MAAMC,SAAS,GACbzC,KAAK,KAAK,IAAI,GACVlF,sBAAsB,GACtBqC,iBAAiB,CAAC8B,4BAAe,CAAC;QAExC6B,WAAW,CAAChC,IAAI,CAAC7B,KAAK,aAALA,KAAK,cAALA,KAAK,GAAIwF,SAAS,CAAC;QACpC1B,YAAY,CAACjC,IAAI,CAAC5B,GAAG,CAAC;QACtB;MACF;IACA,KAAKc,mBAAY,CAACuC,EAAE;IACpB,KAAKvC,mBAAY,CAACqC,GAAG;MAAE;QAAA;QACrB,IAAIyB,KAAK,CAACC,OAAO,CAAClE,MAAM,CAACmC,KAAK,CAAC,EAC7B,MAAM,IAAIjD,KAAK,CAAE,GAAEc,MAAM,CAACE,UAAW,6BAA4B,CAAC;QAEpE,MAAMiC,KAAK,GAAGsC,iBAAiB,CAACzE,MAAM,CAACmC,KAAK,EAAEnC,MAAM,CAAC;QACrD,MAAMZ,KAAK,GACTY,MAAM,CAACE,UAAU,KAAKC,mBAAY,CAACqC,GAAG,GAClCL,KAAK,GACL7C,iBAAiB,CAAC6C,KAAK,CAAC;;QAE9B;QACA,MAAM9C,GAAG,yBACPqF,gBAAgB,CAAC/G,OAAO,EAAEoG,KAAK,EAAE5D,mBAAY,CAACsC,GAAG,EAAEjF,UAAU,CAACmH,KAAK,CAAC,mEACpED,gBAAgB,CAAC/G,OAAO,EAAEoG,KAAK,EAAE5D,mBAAY,CAACwC,EAAE,CAAC;QAEnD,MAAMkC,SAAS,GACb1C,KAAK,KAAK,IAAI,GAAG7C,iBAAiB,CAAC,IAAI,CAAC,GAAGlC,sBAAsB;QAEnE6F,WAAW,CAAChC,IAAI,CAAC7B,KAAK,CAAC;QACvB8D,YAAY,CAACjC,IAAI,CAAC5B,GAAG,aAAHA,GAAG,cAAHA,GAAG,GAAIwF,SAAS,CAAC;QACnC;MACF;IACA,KAAK1E,mBAAY,CAAC0C,EAAE;IACpB,KAAK1C,mBAAY,CAACyC,GAAG;MAAE;QACrB,MAAMuB,GAAG,GAAGF,KAAK,CAACC,OAAO,CAAClE,MAAM,CAACmC,KAAK,CAAC,GACnC,CAAC,GAAGnC,MAAM,CAACmC,KAAK,CAAC,GACjB,CAACnC,MAAM,CAACmC,KAAK,CAAC;;QAElB;QACAgC,GAAG,CAACC,IAAI,CAAC,CAACC,CAAM,EAAEC,CAAM,KAAa;UACnC,IAAID,CAAC,KAAKC,CAAC,EAAE,OAAO,CAAC;UACrB,IAAIN,aAAa,KAAK,CAAC,EAAE,OAAOK,CAAC,GAAGC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;UAC9C,OAAOD,CAAC,GAAGC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;QACvB,CAAC,CAAC;QACF,MAAMC,OAAO,GAAGJ,GAAG,CAAC5D,IAAI,CAAC4B,KAAK,IAAIA,KAAK,KAAK,IAAI,CAAC;QAEjD,IAAIoC,OAAO,EAAE;UACXtB,WAAW,CAAChC,IAAI,CAAC3B,iBAAiB,CAAC8B,4BAAe,CAAC,CAAC;QACtD,CAAC,MAAM;UACL6B,WAAW,CAAChC,IAAI,CAAChE,sBAAsB,CAAC;QAC1C;QACA,KAAK,MAAMuH,IAAI,IAAI,IAAI7E,GAAG,CAACwE,GAAG,CAAC,EAAE;UAC/B,MAAMhC,KAAK,GAAGsC,iBAAiB,CAACD,IAAI,EAAExE,MAAM,CAAC;UAC7C,IAAImC,KAAK,KAAK,IAAI,EAAE,SAAQ,CAAC;UAC7Be,YAAY,CAACjC,IAAI,CAACkB,KAAK,CAAC;UACxBc,WAAW,CAAChC,IAAI,CAAC3B,iBAAiB,CAAC6C,KAAK,CAAC,CAAC;QAC5C;QACAe,YAAY,CAACjC,IAAI,CAAC7D,sBAAsB,CAAC;QACzC;MACF;IACA;MACE,MAAM,IAAI8B,KAAK,CAAE,0BAAyBc,MAAM,CAACE,UAAW,EAAC,CAAC;EAAA;EAElE,OAAO;IAAE+C,WAAW;IAAEC;EAAa,CAAC;AACtC;AAEA,SAASwB,gBAAgB,CACvB/G,OAAuB,EACvBkG,UAAkB,EAClBiB,SAAuB,EACvBC,IAAgB,GAAGvH,UAAU,CAAC4C,EAAE,EACgC;EAChE,MAAM0D,YAAY,GAAGH,eAAe,CAAChG,OAAO,CAACU,SAAS,EAAEwF,UAAU,CAAC;EACnE,KAAK,MAAMmB,OAAO,IAAIlB,YAAY,EAAE;IAClC,IAAInG,OAAO,CAACQ,WAAW,CAACsC,GAAG,CAACuE,OAAO,CAAC,EAAE;MACpC;IACF;IACA,MAAMC,eAAe,GAAG,IAAAhF,yBAAkB,EAAC+E,OAAO,CAAC;IACnD,IAAIC,eAAe,CAAC/E,UAAU,KAAK4E,SAAS,EAAE;MAC5C;IACF;IACAnH,OAAO,CAACQ,WAAW,CAACkC,GAAG,CAAC2E,OAAO,CAAC;IAChC,MAAM7C,KAAK,GAAG8C,eAAe,CAAC9C,KAAK;IACnC,IAAI8B,KAAK,CAACC,OAAO,CAAC/B,KAAK,CAAC,EAAE;MACxB,MAAM,IAAIjD,KAAK,CAAE,gBAAe4F,SAAU,8BAA6B,CAAC;IAC1E;IACA,IAAI,OAAO3C,KAAK,KAAM,QAAO,IAAIA,KAAK,KAAK,IAAI,EAAE;MAC/C,MAAM,IAAIjD,KAAK,CACZ,gBAAe4F,SAAU,kCAAiC,OAAO3C,KAAM,EAAC,CAC1E;IACH;IACA,IAAI4C,IAAI,KAAK,CAAC,EAAE;MACd,OAAO5C,KAAK;IACd;IACA,OAAO4C,IAAI,GAAG,CAAC,GAAGG,kBAAkB,CAAC/C,KAAK,CAAC,GAAG7C,iBAAiB,CAAC6C,KAAK,CAAC;EACxE;EACA,OAAOzC,SAAS;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASJ,iBAAiB,CAAC6C,KAAsB,EAAkB;EACjE,OAAO,CAACA,KAAK,EAAE/E,sBAAsB,CAAC;AACxC;AACA,SAAS8H,kBAAkB,CAAC/C,KAAsB,EAAmB;EACnE,OAAO,CAACf,4BAAe,EAAEe,KAAK,CAAC;AACjC;AAEA,SAASsC,iBAAiB,CACxBU,WAA8B,EAC9BnF,MAA0B,EACT;EACjB,IAAI,OAAOmF,WAAW,KAAM,QAAO,IAAIA,WAAW,KAAK,IAAI,EAAE;IAC3D,MAAM,IAAIjG,KAAK,CACZ,kCAAiCc,MAAM,CAACE,UAAW,KAAI,IAAAkF,aAAO,EAC7DpF,MAAM,CAACmC,KAAK,CACZ,EAAC,CACJ;EACH;EACA,OAAOgD,WAAW;AACpB;AAEA,SAASzG,aAAa,CAAC2G,KAAkB,EAAmB;EAC1D,MAAMC,EAAE,GAAGD,KAAK,CAACpD,GAAG,CAACoD,KAAK,CAACpD,GAAG,CAACjE,MAAM,GAAG,CAAC,CAAC;EAC1C,IAAI,OAAOsH,EAAE,KAAM,QAAO,IAAI,OAAOA,EAAE,KAAM,QAAO,EAAE;IACpD,MAAMC,GAAG,GAAG,IAAAH,aAAO,EAACE,EAAE,CAAC;IACvB,MAAM,IAAIpG,KAAK,CACZ,yEAAwEqG,GAAI,EAAC,CAC/E;EACH;EACA,OAAOD,EAAE;AACX"}