{"version":3,"file":"create-index.js","names":["undefinedSymbol","Symbol","for","createIndex","context","typeName","indexFields","indexName","buildIndexName","meta","getIndexMetadata","state","indexReady","lockIndex","err","doCreateIndex","assertReady","databases","metadata","get","toMetadataKey","Error","datastore","indexes","label","console","time","resolvedNodes","store","getState","resolvedNodesCache","stats","maxKeysPerItem","keyCount","itemCount","indexMetadata","keyFields","multiKeyFields","keyPrefix","i","node","iterateNodesByType","resolvedFields","id","keys","prepareIndexKeys","length","Math","max","push","indexKey","put","Promise","resolve","setTimeout","Set","timeEnd","e","error","String","indexKeyElements","dottedField","fieldValue","resolveFieldValue","indexFieldValue","jsValueToLmdbKey","path","internal","type","inspect","Array","isArray","flat","counter","cartesianProduct","justLocked","ifNoExists","reject","retries","timeout","poll","min","fields","tokens","field","sortDirection","join","value","result","item","lmdbKey","undefined","JSON","stringify"],"sources":["../../../../src/datastore/lmdb/query/create-index.ts"],"sourcesContent":["import { inspect } from \"util\"\nimport { store } from \"../../../redux\"\nimport { IGatsbyNode } from \"../../../redux/types\"\nimport { IDataStore, ILmdbDatabases } from \"../../types\"\nimport { cartesianProduct, resolveFieldValue } from \"./common\"\n\ninterface IIndexingContext {\n  databases: ILmdbDatabases\n  datastore: IDataStore\n}\n\nexport type IndexFields = Map<string, number> // name, direction\n\nexport interface IIndexMetadata {\n  state: \"ready\" | \"building\" | \"stale\" | \"error\" | \"initial\"\n  error?: string\n  typeName: string\n  keyPrefix: number | string\n  keyFields: Array<[fieldName: string, orderDirection: number]>\n  multiKeyFields: Array<string>\n\n  // Stats for multi-key indexes\n  // (e.g. when node is { id: `id`, foo: [1,2] } it translates into two index keys: [1,`id`], [2,`id`])\n  stats: {\n    keyCount: number\n    itemCount: number\n    maxKeysPerItem: number\n  }\n}\n\nexport const undefinedSymbol = Symbol.for(`undef`)\n\nexport type IndexFieldValue =\n  | number\n  | string\n  | boolean\n  | null\n  | typeof undefinedSymbol\n  | Array<IndexFieldValue>\n\nexport type IndexKey = Array<IndexFieldValue>\n\nexport async function createIndex(\n  context: IIndexingContext,\n  typeName: string,\n  indexFields: IndexFields\n): Promise<IIndexMetadata> {\n  const indexName = buildIndexName(typeName, indexFields)\n  const meta = getIndexMetadata(context, typeName, indexFields, false)\n\n  switch (meta?.state) {\n    case `ready`:\n      return meta\n    case `building`: {\n      return indexReady(context, indexName)\n    }\n    case `initial`:\n    default: {\n      try {\n        await lockIndex(context, indexName)\n      } catch (err) {\n        // Index is being updated in some other process.\n        // Wait and assume it's in a good state when done\n        return indexReady(context, indexName)\n      }\n      return doCreateIndex(context, typeName, indexFields)\n    }\n  }\n}\n\nexport function getIndexMetadata(\n  context: IIndexingContext,\n  typeName: string,\n  indexFields: IndexFields,\n  assertReady = true\n): IIndexMetadata {\n  const { databases } = context\n  const indexName = buildIndexName(typeName, indexFields)\n  const meta: IIndexMetadata = databases.metadata.get(toMetadataKey(indexName))\n\n  if (assertReady && meta?.state !== `ready`) {\n    throw new Error(\n      `Index ${indexName} is not ready yet. State: ${meta?.state ?? `unknown`}`\n    )\n  }\n  return meta\n}\n\nasync function doCreateIndex(\n  context: IIndexingContext,\n  typeName: string,\n  indexFields: IndexFields\n): Promise<IIndexMetadata> {\n  const { datastore, databases } = context\n  const { indexes, metadata } = databases\n  const indexName = buildIndexName(typeName, indexFields)\n\n  const label = `Indexing ${indexName}`\n  console.time(label)\n\n  // Assuming materialization was run before creating index\n  const resolvedNodes = store.getState().resolvedNodesCache.get(typeName)\n\n  // TODO: iterate only over dirty nodes\n  // TODO: wrap in async transaction?\n  const stats: IIndexMetadata[\"stats\"] = {\n    maxKeysPerItem: 0,\n    keyCount: 0,\n    itemCount: 0,\n  }\n  const indexMetadata: IIndexMetadata = {\n    state: `building`,\n    typeName,\n    keyFields: [...indexFields],\n    multiKeyFields: [],\n    keyPrefix: indexName, // FIXME\n    stats,\n  }\n\n  try {\n    let i = 0\n    for (const node of datastore.iterateNodesByType(typeName)) {\n      // Assuming materialization was run (executing custom resolvers for fields in `filter` and `sort` clauses)\n      //  And materialized values of those fields are stored in resolvedNodes\n      const resolvedFields = resolvedNodes?.get(node.id)\n      const { keys, multiKeyFields } = prepareIndexKeys(\n        node,\n        resolvedFields,\n        indexName,\n        indexFields\n      )\n      stats.keyCount += keys.length\n      stats.itemCount++\n      stats.maxKeysPerItem = Math.max(stats.maxKeysPerItem, keys.length)\n      indexMetadata.multiKeyFields.push(...multiKeyFields)\n\n      for (const indexKey of keys) {\n        // Note: this may throw if indexKey exceeds 1978 chars (lmdb limit) or contain objects/buffers/etc\n        indexes.put(indexKey, node.id)\n      }\n      if (++i % 5000 === 0) {\n        // Do not block event loop too much\n        await new Promise(resolve => setTimeout(resolve, 3))\n      }\n    }\n    indexMetadata.state = `ready`\n    indexMetadata.multiKeyFields = [...new Set(indexMetadata.multiKeyFields)]\n\n    await metadata.put(toMetadataKey(indexName), indexMetadata)\n    console.timeEnd(label)\n\n    return indexMetadata\n  } catch (e) {\n    indexMetadata.state = `error`\n    indexMetadata.error = String(e)\n    await metadata.put(toMetadataKey(indexName), indexMetadata)\n    throw e\n  }\n}\n\n/**\n * Returns a list of index keys for a given node.\n * One node may produce multiple index entries when indexing over array values.\n *\n * For example:\n *  Node: { foo: [{ bar: `bar1`}, { bar: `bar2` }] }\n *  Index fields: [`foo.bar`] will produce the following elements: [`bar1`, `bar2`]\n *\n * Keys are prefixed with index name and suffixed with node counter for stable sort.\n *\n * If materialization result (resolvedFields) exists for a given index field\n *  it is used as a key element, otherwise the a raw node value is used.\n */\nfunction prepareIndexKeys(\n  node: IGatsbyNode,\n  resolvedFields: { [field: string]: unknown } | undefined,\n  indexName: string,\n  indexFields: IndexFields\n): { keys: Array<IndexKey>; multiKeyFields: Array<string> } {\n  // TODO: use index id vs index name (shorter)\n  const indexKeyElements: Array<Array<IndexFieldValue>> = []\n  const multiKeyFields: Array<string> = []\n\n  indexKeyElements.push([indexName])\n  for (const dottedField of indexFields.keys()) {\n    const fieldValue = resolveFieldValue(dottedField, node, resolvedFields)\n    let indexFieldValue = jsValueToLmdbKey(fieldValue)\n\n    // Got value that can't be stored in lmdb key\n    if (typeof indexFieldValue === `undefined`) {\n      const path = `${node.internal.type}.${dottedField} (id: ${node.id})`\n      throw new Error(`Bad value at ${path}: ${inspect(fieldValue)}`)\n    }\n    indexFieldValue = Array.isArray(indexFieldValue)\n      ? indexFieldValue.flat() // FIXME\n      : [indexFieldValue]\n\n    indexKeyElements.push(indexFieldValue)\n\n    if (indexFieldValue.length > 1) {\n      multiKeyFields.push(dottedField)\n    }\n  }\n  indexKeyElements.push([node.internal.counter])\n\n  return { keys: cartesianProduct(...indexKeyElements), multiKeyFields }\n}\n\nasync function lockIndex(\n  context: IIndexingContext,\n  indexName: string\n): Promise<void> {\n  const { metadata } = context.databases\n  const indexKey = toMetadataKey(indexName)\n\n  const justLocked = await metadata.ifNoExists(indexKey, () => {\n    metadata.put(indexKey, null)\n  })\n  if (!justLocked) {\n    throw new Error(`Index is already locked`)\n  }\n}\n\nasync function indexReady(\n  context: IIndexingContext,\n  indexName: string\n): Promise<IIndexMetadata> {\n  return new Promise((resolve, reject) => {\n    const { metadata } = context.databases\n\n    let retries = 0\n    let timeout = 16\n    function poll(): void {\n      const indexMetadata = metadata.get(toMetadataKey(indexName))\n      if (indexMetadata?.state === `ready`) {\n        resolve(indexMetadata)\n        return\n      }\n      if (retries++ > 1000) {\n        reject(new Error(`Index ${indexName} is locked for too long`))\n        return\n      }\n      setTimeout(poll, timeout)\n      timeout = Math.min(200, timeout * 1.5)\n    }\n    poll()\n  })\n}\n\n/**\n * Autogenerate index name based on parameters.\n *\n * Example:\n *\n * buildIndexName(`Foo`, { foo: 1, bar: -1 }) -> `Foo/foo:1/bar:-1\n */\nfunction buildIndexName(typeName: string, fields: IndexFields): string {\n  const tokens: Array<string> = [typeName]\n\n  for (const [field, sortDirection] of fields) {\n    tokens.push(`${field}:${sortDirection}`)\n  }\n\n  return tokens.join(`/`)\n}\n\nfunction toMetadataKey(indexName: string): string {\n  return `index:${indexName}`\n}\n\nfunction jsValueToLmdbKey(value: unknown): IndexFieldValue | undefined {\n  if (\n    typeof value === `number` ||\n    typeof value === `string` ||\n    typeof value === `boolean` ||\n    value === null\n  ) {\n    return value\n  }\n  if (typeof value === `undefined`) {\n    // Array keys containing `undefined` are not supported by lmdb-store\n    //  But we can't exclude those nodes from an index because\n    //  filters { eq: null, gte: null, lte: null } are expected to return such nodes\n    // Furthermore, lmdb-store puts those keys before others and we want them to be below\n    //  so need to add additional padding\n    return undefinedSymbol\n  }\n  if (Array.isArray(value)) {\n    const result: Array<IndexFieldValue> = []\n    for (const item of value) {\n      const lmdbKey = jsValueToLmdbKey(item)\n      if (typeof lmdbKey === `undefined`) {\n        return undefined // bad value\n      }\n      result.push(lmdbKey)\n    }\n    return result\n  }\n  // FIXME: not sure if we want this but there are tests for this :/\n  if (typeof value === `object`) {\n    return JSON.stringify(value)\n  }\n  return undefined\n}\n"],"mappings":"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"}