{"version":3,"file":"resolvers.js","names":["getMaybeResolvedValue","node","field","nodeInterfaceName","pathObjectToPathString","path","fieldPathNeedToResolve","selector","type","getValueAt","getResolvedFields","findOne","typeName","findOneResolver","_source","args","context","info","stats","totalRunQuery","nodeModel","query","filter","schema","getType","tracer","findManyPaginated","findManyPaginatedResolver","group","getProjectedField","distinct","max","min","sum","skip","Math","limit","undefined","extendedArgs","totalPluralRunQuery","result","findAll","connectionType","paginate","resultOffset","createDistinctResolver","distinctResolver","source","edges","values","Set","forEach","value","Array","isArray","subValue","add","Date","toISOString","from","sort","createMinResolver","minResolver","Number","MAX_SAFE_INTEGER","isNaN","createMaxResolver","maxResolver","MIN_SAFE_INTEGER","createSumResolver","sumResolver","reduce","prev","createGroupResolver","groupResolver","groupedResults","acc","key","concat","Object","create","keys","fieldValue","entries","push","GatsbyIterable","totalCount","length","results","params","Error","allItems","start","items","slice","pageCount","count","ceil","currentPage","hasPreviousPage","hasNextPage","map","item","i","arr","next","previous","nodes","pageInfo","itemCount","perPage","link","options","by","fieldConfig","linkResolver","resolver","resolve","defaultFieldResolver","fieldValueOrPromise","fromNode","then","linkResolverValue","returnType","getNullableType","getNamedType","getNodesByIds","ids","getNodeById","id","runQueryArgs","split","reduceRight","obj","in","eq","firstOnly","GraphQLList","linkResolverQueryResult","queryResult","find","fileByPath","fileByPathResolver","parentFileNode","findRootNodeAncestor","internal","queryNodesByPath","relPaths","queryNodeByPath","relPath","absolutePath","normalize","systemPath","dir","fieldName","selectionSet","fieldNodes","getFieldNodeByNameInSelectionSet","isObjectType","isInterfaceType","getFields","fieldArg","arg","name","fieldTC","isEnumType","isInputObjectType","fieldNode","arguments","kind","Kind","ENUM","enumKey","enumValue","getValue","currentValue","OBJECT","fields","sortPath","join","selections","selection","FRAGMENT_SPREAD","fragmentDef","fragments","INLINE_FRAGMENT","property","WARNED_ABOUT_RESOLVERS","badResolverInvocationMessage","missingVar","resolverName","pathToArray","wrappingResolver","wrappedTracingResolver","parent","reporter","warn","activity","time","createResolverActivity","parentType","telemetryResolverTimings","process","hrtime","bigint","endActivity","duration","end","isTracingResolver","defaultResolver"],"sources":["../../src/schema/resolvers.ts"],"sourcesContent":["import systemPath from \"path\"\nimport normalize from \"normalize-path\"\nimport {\n  GraphQLList,\n  GraphQLType,\n  getNullableType,\n  getNamedType,\n  Kind,\n  GraphQLFieldConfig,\n  GraphQLResolveInfo,\n  isObjectType,\n  isInterfaceType,\n  isEnumType,\n  isInputObjectType,\n  SelectionSetNode,\n  SelectionNode,\n  FieldNode,\n} from \"graphql\"\nimport { Path } from \"graphql/jsutils/Path\"\nimport reporter from \"gatsby-cli/lib/reporter\"\nimport { pathToArray } from \"../query/utils\"\nimport { getValueAt } from \"../utils/get-value-at\"\nimport {\n  GatsbyResolver,\n  IGatsbyConnection,\n  IGatsbyResolverContext,\n} from \"./type-definitions\"\nimport { IGatsbyNode } from \"../redux/types\"\nimport { IQueryResult } from \"../datastore/types\"\nimport { GatsbyIterable } from \"../datastore/common/iterable\"\nimport {\n  getResolvedFields,\n  fieldPathNeedToResolve,\n  INestedPathStructureNode,\n  pathObjectToPathString,\n} from \"./utils\"\n\ntype ResolvedLink = IGatsbyNode | Array<IGatsbyNode> | null\n\ntype nestedListOfStrings = Array<string | nestedListOfStrings>\ntype nestedListOfNodes = Array<IGatsbyNode | nestedListOfNodes>\n\nexport function getMaybeResolvedValue(\n  node: IGatsbyNode,\n  field: string | INestedPathStructureNode,\n  nodeInterfaceName: string\n): any {\n  if (typeof field !== `string`) {\n    field = pathObjectToPathString(field).path\n  }\n\n  if (\n    fieldPathNeedToResolve({\n      selector: field,\n      type: nodeInterfaceName,\n    })\n  ) {\n    return getValueAt(getResolvedFields(node) as Record<string, unknown>, field)\n  } else {\n    return getValueAt(node, field)\n  }\n}\n\nexport function findOne<TSource, TArgs>(\n  typeName: string\n): GatsbyResolver<TSource, TArgs> {\n  return function findOneResolver(_source, args, context, info): any {\n    if (context.stats) {\n      context.stats.totalRunQuery++\n    }\n    return context.nodeModel.findOne(\n      {\n        query: { filter: args },\n        type: info.schema.getType(typeName),\n        stats: context.stats,\n        tracer: context.tracer,\n      },\n      { path: context.path }\n    )\n  }\n}\n\ntype PaginatedArgs<TArgs> = TArgs & { skip?: number; limit?: number; sort: any }\n\nexport function findManyPaginated<TSource, TArgs>(\n  typeName: string\n): GatsbyResolver<TSource, PaginatedArgs<TArgs>> {\n  return async function findManyPaginatedResolver(\n    _source,\n    args,\n    context,\n    info\n  ): Promise<IGatsbyConnection<IGatsbyNode>> {\n    // Peek into selection set and pass on the `field` arg of `group` and\n    // `distinct` which might need to be resolved.\n    const group = getProjectedField(info, `group`)\n    const distinct = getProjectedField(info, `distinct`)\n    const max = getProjectedField(info, `max`)\n    const min = getProjectedField(info, `min`)\n    const sum = getProjectedField(info, `sum`)\n\n    // Apply paddings for pagination\n    // (for previous/next node and also to detect if there is a previous/next page)\n    const skip = typeof args.skip === `number` ? Math.max(0, args.skip - 1) : 0\n    const limit = typeof args.limit === `number` ? args.limit + 2 : undefined\n\n    const extendedArgs = {\n      ...args,\n      group: group || [],\n      distinct: distinct || [],\n      max: max || [],\n      min: min || [],\n      sum: sum || [],\n      skip,\n      limit,\n    }\n    // Note: stats are passed to telemetry in src/commands/build.ts\n    if (context.stats) {\n      context.stats.totalRunQuery++\n      context.stats.totalPluralRunQuery++\n    }\n    const result = await context.nodeModel.findAll(\n      {\n        query: extendedArgs,\n        type: info.schema.getType(typeName),\n        stats: context.stats,\n        tracer: context.tracer,\n      },\n      { path: context.path, connectionType: typeName }\n    )\n    return paginate(result, {\n      resultOffset: skip,\n      skip: args.skip,\n      limit: args.limit,\n    })\n  }\n}\n\ninterface IFieldConnectionArgs {\n  field: string | INestedPathStructureNode\n}\n\nexport function createDistinctResolver(\n  nodeInterfaceName: string\n): GatsbyResolver<IGatsbyConnection<IGatsbyNode>, IFieldConnectionArgs> {\n  return function distinctResolver(source, args): Array<string> {\n    const { field } = args\n    const { edges } = source\n\n    const values = new Set<string>()\n    edges.forEach(({ node }) => {\n      const value = getMaybeResolvedValue(node, field, nodeInterfaceName)\n      if (value === null || value === undefined) {\n        return\n      }\n      if (Array.isArray(value)) {\n        value.forEach(subValue =>\n          values.add(\n            subValue instanceof Date ? subValue.toISOString() : subValue\n          )\n        )\n      } else if (value instanceof Date) {\n        values.add(value.toISOString())\n      } else {\n        values.add(value)\n      }\n    })\n    return Array.from(values).sort()\n  }\n}\n\nexport function createMinResolver(\n  nodeInterfaceName: string\n): GatsbyResolver<IGatsbyConnection<IGatsbyNode>, IFieldConnectionArgs> {\n  return function minResolver(source, args): number | null {\n    const { field } = args\n    const { edges } = source\n\n    let min = Number.MAX_SAFE_INTEGER\n\n    edges.forEach(({ node }) => {\n      let value = getMaybeResolvedValue(node, field, nodeInterfaceName)\n\n      if (typeof value !== `number`) {\n        value = Number(value)\n      }\n      if (!isNaN(value) && value < min) {\n        min = value\n      }\n    })\n    if (min === Number.MAX_SAFE_INTEGER) {\n      return null\n    }\n    return min\n  }\n}\n\nexport function createMaxResolver(\n  nodeInterfaceName: string\n): GatsbyResolver<IGatsbyConnection<IGatsbyNode>, IFieldConnectionArgs> {\n  return function maxResolver(source, args): number | null {\n    const { field } = args\n    const { edges } = source\n\n    let max = Number.MIN_SAFE_INTEGER\n\n    edges.forEach(({ node }) => {\n      let value = getMaybeResolvedValue(node, field, nodeInterfaceName)\n      if (typeof value !== `number`) {\n        value = Number(value)\n      }\n      if (!isNaN(value) && value > max) {\n        max = value\n      }\n    })\n    if (max === Number.MIN_SAFE_INTEGER) {\n      return null\n    }\n    return max\n  }\n}\n\nexport function createSumResolver(\n  nodeInterfaceName: string\n): GatsbyResolver<IGatsbyConnection<IGatsbyNode>, IFieldConnectionArgs> {\n  return function sumResolver(source, args): number | null {\n    const { field } = args\n    const { edges } = source\n\n    return edges.reduce<number | null>((prev, { node }) => {\n      let value = getMaybeResolvedValue(node, field, nodeInterfaceName)\n\n      if (typeof value !== `number`) {\n        value = Number(value)\n      }\n      if (!isNaN(value)) {\n        return (prev || 0) + value\n      }\n      return prev\n    }, null)\n  }\n}\n\ntype IGatsbyGroupReturnValue<NodeType> = Array<\n  IGatsbyConnection<NodeType> & {\n    field: string\n    fieldValue: string | undefined\n  }\n>\n\nexport function createGroupResolver(\n  nodeInterfaceName: string\n): GatsbyResolver<\n  IGatsbyConnection<IGatsbyNode>,\n  PaginatedArgs<IFieldConnectionArgs>\n> {\n  return function groupResolver(\n    source,\n    args\n  ): IGatsbyGroupReturnValue<IGatsbyNode> {\n    const { field } = args\n    const { edges } = source\n    const groupedResults: Record<string, Array<IGatsbyNode>> = edges.reduce(\n      (acc, { node }) => {\n        const value = getMaybeResolvedValue(node, field, nodeInterfaceName)\n        const values = Array.isArray(value) ? value : [value]\n        values\n          .filter(value => value != null)\n          .forEach(value => {\n            const key = value instanceof Date ? value.toISOString() : value\n            acc[key] = (acc[key] || []).concat(node)\n          })\n        return acc\n        // Note: using Object.create on purpose:\n        //   object key may be arbitrary string including reserved words (i.e. `constructor`)\n        //   see: https://github.com/gatsbyjs/gatsby/issues/22508\n      },\n      Object.create(null)\n    )\n\n    return Object.keys(groupedResults)\n      .sort()\n      .reduce(\n        (acc: IGatsbyGroupReturnValue<IGatsbyNode>, fieldValue: string) => {\n          const entries = groupedResults[fieldValue] || []\n          acc.push({\n            ...paginate(\n              {\n                entries: new GatsbyIterable(entries),\n                totalCount: async () => entries.length,\n              },\n              args\n            ),\n            field:\n              typeof field === `string`\n                ? field\n                : pathObjectToPathString(field).path,\n            fieldValue,\n          })\n          return acc\n        },\n        []\n      )\n  }\n}\n\nexport function paginate(\n  results: IQueryResult,\n  params: { skip?: number; limit?: number; resultOffset?: number }\n): IGatsbyConnection<IGatsbyNode> {\n  const { resultOffset = 0, skip = 0, limit } = params\n  if (resultOffset > skip) {\n    throw new Error(\"Result offset cannot be greater than `skip` argument\")\n  }\n  const allItems = Array.from(results.entries)\n\n  const start = skip - resultOffset\n  const items = allItems.slice(start, limit && start + limit)\n\n  const totalCount = results.totalCount\n  const pageCount = async (): Promise<number> => {\n    const count = await totalCount()\n    return limit\n      ? Math.ceil(skip / limit) + Math.ceil((count - skip) / limit)\n      : skip\n      ? 2\n      : 1\n  }\n  const currentPage = limit ? Math.ceil(skip / limit) + 1 : skip ? 2 : 1\n  const hasPreviousPage = currentPage > 1\n  const hasNextPage = limit ? allItems.length - start > limit : false\n\n  return {\n    totalCount,\n    edges: items.map((item, i, arr) => {\n      return {\n        node: item,\n        next: arr[i + 1],\n        previous: arr[i - 1],\n      }\n    }),\n    nodes: items,\n    pageInfo: {\n      currentPage,\n      hasPreviousPage,\n      hasNextPage,\n      itemCount: items.length,\n      pageCount,\n      perPage: limit,\n      totalCount,\n    },\n  }\n}\n\nexport function link<TSource, TArgs>(\n  options: {\n    by: string\n    type?: GraphQLType\n    from?: string\n    fromNode?: boolean\n  } = {\n    by: `id`,\n  },\n  fieldConfig: GraphQLFieldConfig<\n    TSource,\n    IGatsbyResolverContext<TSource, TArgs>,\n    TArgs\n  >\n): GatsbyResolver<TSource, TArgs> {\n  // Note: we explicitly make an attempt to prevent using the `async` keyword because often\n  //       it does not return a promise and this makes a significant difference at scale.\n\n  return function linkResolver(\n    source,\n    args,\n    context,\n    info\n  ): ResolvedLink | Promise<ResolvedLink> {\n    const resolver = fieldConfig.resolve || context.defaultFieldResolver\n    const fieldValueOrPromise = resolver(source, args, context, {\n      ...info,\n      from: options.from || info.from,\n      fromNode: options.from ? options.fromNode : info.fromNode,\n    })\n\n    // Note: for this function, at scale, conditional .then is more efficient than generic await\n    if (typeof fieldValueOrPromise?.then === `function`) {\n      return fieldValueOrPromise.then(fieldValue =>\n        linkResolverValue(fieldValue, args, context, info)\n      )\n    }\n\n    return linkResolverValue(fieldValueOrPromise, args, context, info)\n  }\n\n  function linkResolverValue(\n    fieldValue,\n    args,\n    context,\n    info\n  ): ResolvedLink | Promise<ResolvedLink> {\n    if (fieldValue == null) {\n      return null\n    }\n\n    const returnType = getNullableType(options.type || info.returnType)\n    const type = getNamedType(returnType)\n\n    if (options.by === `id`) {\n      if (Array.isArray(fieldValue)) {\n        return context.nodeModel.getNodesByIds(\n          { ids: fieldValue, type: type },\n          { path: context.path }\n        )\n      } else {\n        return context.nodeModel.getNodeById(\n          { id: fieldValue, type: type },\n          { path: context.path }\n        )\n      }\n    }\n\n    // Return early if fieldValue is [] since { in: [] } doesn't make sense\n    if (Array.isArray(fieldValue) && fieldValue.length === 0) {\n      return fieldValue\n    }\n\n    const runQueryArgs = args as TArgs & { filter: Record<string, any> }\n    runQueryArgs.filter = options.by.split(`.`).reduceRight(\n      (acc: Record<string, any>, key: string) => {\n        const obj = {}\n        obj[key] = acc\n        return obj\n      },\n      Array.isArray(fieldValue) ? { in: fieldValue } : { eq: fieldValue }\n    )\n\n    const firstOnly = !(returnType instanceof GraphQLList)\n\n    if (context.stats) {\n      context.stats.totalRunQuery++\n      if (firstOnly) {\n        context.stats.totalPluralRunQuery++\n      }\n    }\n\n    if (firstOnly) {\n      return context.nodeModel\n        .findOne(\n          {\n            query: runQueryArgs,\n            type,\n            stats: context.stats,\n            tracer: context.tracer,\n          },\n          { path: context.path }\n        )\n        .then(result => linkResolverQueryResult(fieldValue, result, returnType))\n    }\n\n    return context.nodeModel\n      .findAll(\n        {\n          query: runQueryArgs,\n          type,\n          stats: context.stats,\n          tracer: context.tracer,\n        },\n        { path: context.path }\n      )\n      .then(({ entries }) =>\n        linkResolverQueryResult(fieldValue, Array.from(entries), returnType)\n      )\n  }\n\n  function linkResolverQueryResult(\n    fieldValue,\n    queryResult,\n    returnType\n  ): IGatsbyNode | Array<IGatsbyNode> {\n    if (\n      returnType instanceof GraphQLList &&\n      Array.isArray(fieldValue) &&\n      Array.isArray(queryResult)\n    ) {\n      return fieldValue.map(value =>\n        queryResult.find(obj => getValueAt(obj, options.by) === value)\n      )\n    } else {\n      return queryResult\n    }\n  }\n}\n\nexport function fileByPath<TSource, TArgs>(\n  options: {\n    from?: string\n    fromNode?: boolean\n  } = {},\n  fieldConfig\n): GatsbyResolver<TSource, TArgs> {\n  return async function fileByPathResolver(\n    source,\n    args,\n    context,\n    info\n  ): Promise<IGatsbyNode | nestedListOfNodes | null> {\n    const resolver = fieldConfig.resolve || context.defaultFieldResolver\n    const fieldValue: nestedListOfStrings = await resolver(\n      source,\n      args,\n      context,\n      {\n        ...info,\n        from: options.from || info.from,\n        fromNode: options.from ? options.fromNode : info.fromNode,\n      }\n    )\n\n    if (fieldValue == null) {\n      return null\n    }\n\n    // Find the File node for this node (we assume the node is something\n    // like markdown which would be a child node of a File node).\n    const parentFileNode = context.nodeModel.findRootNodeAncestor(\n      source,\n      node => node.internal && node.internal.type === `File`\n    )\n\n    async function queryNodesByPath(\n      relPaths: nestedListOfStrings\n    ): Promise<nestedListOfNodes> {\n      const arr: nestedListOfNodes = []\n      for (let i = 0; i < relPaths.length; ++i) {\n        arr[i] = await (Array.isArray(relPaths[i])\n          ? queryNodesByPath(relPaths[i] as nestedListOfStrings)\n          : queryNodeByPath(relPaths[i] as string))\n      }\n      return arr\n    }\n\n    function queryNodeByPath(relPath: string): Promise<IGatsbyNode> {\n      return context.nodeModel.findOne({\n        query: {\n          filter: {\n            absolutePath: {\n              eq: normalize(systemPath.resolve(parentFileNode.dir, relPath)),\n            },\n          },\n        },\n        type: `File`,\n      })\n    }\n\n    if (Array.isArray(fieldValue)) {\n      return queryNodesByPath(fieldValue)\n    } else {\n      return queryNodeByPath(fieldValue)\n    }\n  }\n}\n\nfunction getProjectedField(\n  info: GraphQLResolveInfo,\n  fieldName: string\n): Array<string> {\n  const selectionSet = info.fieldNodes[0].selectionSet\n  if (selectionSet) {\n    const fieldNodes = getFieldNodeByNameInSelectionSet(\n      selectionSet,\n      fieldName,\n      info\n    )\n\n    if (fieldNodes.length === 0) {\n      return []\n    }\n\n    const returnType = getNullableType(info.returnType)\n\n    if (isObjectType(returnType) || isInterfaceType(returnType)) {\n      const field = returnType.getFields()[fieldName]\n      const fieldArg = field?.args?.find(arg => arg.name === `field`)\n      if (fieldArg) {\n        const fieldTC = getNullableType(fieldArg.type)\n\n        if (isEnumType(fieldTC) || isInputObjectType(fieldTC)) {\n          return fieldNodes.reduce(\n            (acc: Array<string>, fieldNode: FieldNode) => {\n              const fieldArg = fieldNode.arguments?.find(\n                arg => arg.name.value === `field`\n              )\n              if (isEnumType(fieldTC)) {\n                if (fieldArg?.value.kind === Kind.ENUM) {\n                  const enumKey = fieldArg.value.value\n                  const enumValue = fieldTC.getValue(enumKey)\n                  if (enumValue) {\n                    acc.push(enumValue.value)\n                  }\n                }\n              } else if (isInputObjectType(fieldTC)) {\n                const path: Array<string> = []\n                let currentValue = fieldArg?.value\n                while (currentValue) {\n                  if (currentValue.kind === Kind.OBJECT) {\n                    if (currentValue.fields.length !== 1) {\n                      throw new Error(`Invalid field arg`)\n                    }\n\n                    const fieldArg = currentValue.fields[0]\n                    path.push(fieldArg.name.value)\n                    currentValue = fieldArg.value\n                  } else {\n                    currentValue = undefined\n                  }\n                }\n\n                if (path.length > 0) {\n                  const sortPath = path.join(`.`)\n                  acc.push(sortPath)\n                }\n              }\n              return acc\n            },\n            []\n          )\n        }\n      }\n    }\n  }\n\n  return []\n}\n\nfunction getFieldNodeByNameInSelectionSet(\n  selectionSet: SelectionSetNode,\n  fieldName: string,\n  info: GraphQLResolveInfo\n): Array<FieldNode> {\n  return selectionSet.selections.reduce(\n    (acc: Array<FieldNode>, selection: SelectionNode) => {\n      if (selection.kind === Kind.FRAGMENT_SPREAD) {\n        const fragmentDef = info.fragments[selection.name.value]\n        if (fragmentDef) {\n          return [\n            ...acc,\n            ...getFieldNodeByNameInSelectionSet(\n              fragmentDef.selectionSet,\n              fieldName,\n              info\n            ),\n          ]\n        }\n      } else if (selection.kind === Kind.INLINE_FRAGMENT) {\n        return [\n          ...acc,\n          ...getFieldNodeByNameInSelectionSet(\n            selection.selectionSet,\n            fieldName,\n            info\n          ),\n        ]\n      } /* FIELD_NODE */ else {\n        if (selection.name.value === fieldName) {\n          return [...acc, selection]\n        }\n      }\n      return acc\n    },\n    []\n  )\n}\n\nexport const defaultFieldResolver: GatsbyResolver<any, any> =\n  function defaultFieldResolver(source, args, context, info) {\n    if (\n      (typeof source == `object` && source !== null) ||\n      typeof source === `function`\n    ) {\n      if (info.from) {\n        if (info.fromNode) {\n          const node = context.nodeModel.findRootNodeAncestor(source)\n          if (!node) return null\n          return getValueAt(node, info.from)\n        }\n        return getValueAt(source, info.from)\n      }\n      const property = source[info.fieldName]\n      if (typeof property === `function`) {\n        return source[info.fieldName](args, context, info)\n      }\n      return property\n    }\n\n    return null\n  }\n\nlet WARNED_ABOUT_RESOLVERS = false\nfunction badResolverInvocationMessage(missingVar: string, path?: Path): string {\n  const resolverName = path ? `${pathToArray(path)} ` : ``\n  return `GraphQL Resolver ${resolverName}got called without \"${missingVar}\" argument. This might cause unexpected errors.\n\nIt's likely that this has happened in a schemaCustomization with manually invoked resolver. If manually invoking resolvers, it's best to invoke them as follows:\n\n  resolve(parent, args, context, info)\n\n`\n}\n\nexport function wrappingResolver<TSource, TArgs>(\n  resolver: GatsbyResolver<TSource, TArgs>\n): GatsbyResolver<TSource, TArgs> {\n  // Note: we explicitly make an attempt to prevent using the `async` keyword because often\n  //       it does not return a promise and this makes a significant difference at scale.\n  //       GraphQL will gracefully handle the resolver result of a promise or non-promise.\n\n  if (resolver[`isTracingResolver`]) {\n    return resolver\n  }\n\n  const wrappedTracingResolver = function wrappedTracingResolver(\n    parent,\n    args,\n    context,\n    info\n  ): Promise<any> {\n    if (!WARNED_ABOUT_RESOLVERS) {\n      if (!info) {\n        reporter.warn(badResolverInvocationMessage(`info`))\n        WARNED_ABOUT_RESOLVERS = true\n      } else if (!context) {\n        reporter.warn(badResolverInvocationMessage(`context`, info.path))\n        WARNED_ABOUT_RESOLVERS = true\n      }\n    }\n\n    let activity\n    let time\n    if (context?.tracer) {\n      activity = context.tracer.createResolverActivity(\n        info.path,\n        `${info.parentType.name}.${info.fieldName}`\n      )\n      activity.start()\n    }\n    if (context?.telemetryResolverTimings) {\n      time = process.hrtime.bigint()\n    }\n\n    const result = resolver(parent, args, context, info)\n\n    if (!activity && !time) {\n      return result\n    }\n\n    const endActivity = (): void => {\n      if (context?.telemetryResolverTimings) {\n        context.telemetryResolverTimings.push({\n          name: `${info.parentType}.${info.fieldName}`,\n          duration: Number(process.hrtime.bigint() - time) / 1000 / 1000,\n        })\n      }\n      if (activity) {\n        activity.end()\n      }\n    }\n    if (typeof result?.then === `function`) {\n      result.then(endActivity, endActivity)\n    } else {\n      endActivity()\n    }\n    return result\n  }\n\n  wrappedTracingResolver.isTracingResolver = true\n\n  return wrappedTracingResolver\n}\n\nexport const defaultResolver = wrappingResolver(defaultFieldResolver)\n"],"mappings":"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"}