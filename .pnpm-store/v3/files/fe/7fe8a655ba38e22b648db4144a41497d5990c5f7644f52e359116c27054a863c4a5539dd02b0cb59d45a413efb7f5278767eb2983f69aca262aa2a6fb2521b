{"version":3,"file":"find-page-by-path.js","names":["findBestMatchingPage","pages","path","pagesByMatchPath","page","values","matchPath","routes","Object","keys","map","picked","pick","route","findPageByPath","state","fallbackTo404","decodeURIComponent","get","hasLeadingSlash","startsWith","hasTrailingSlash","endsWith","bare","slice","length","some","potentialPath","matchingPage","undefined"],"sources":["../../src/utils/find-page-by-path.ts"],"sourcesContent":["import { IGatsbyPage, IGatsbyState } from \"../redux/types\"\nimport { pick } from \"@gatsbyjs/reach-router\"\n\n// Ranks and picks the best page to match. Each segment gets the highest\n// amount of points, then the type of segment gets an additional amount of\n// points where\n//\n//     static > dynamic > splat > root\n//\n// This way we don't have to worry about the order of our pages, let the\n// computers do it.\n//\n// In the future, we could move this pagesByMatchPath computation outside this\n// function and save some processing power\nconst findBestMatchingPage = (\n  pages: Map<string, IGatsbyPage>,\n  path: string\n): IGatsbyPage | null => {\n  // Pick only routes with matchPath for better performance.\n  // Exact match should have already been checked\n  const pagesByMatchPath: Record<string, IGatsbyPage> = {}\n  for (const page of pages.values()) {\n    const matchPath = page.matchPath\n    if (matchPath) {\n      pagesByMatchPath[matchPath] = page\n    }\n  }\n\n  const routes = Object.keys(pagesByMatchPath).map(path => {\n    return { path }\n  })\n\n  // picks best matching route with reach router's algorithm\n  const picked = pick(routes, path)\n\n  if (picked) {\n    return pagesByMatchPath[picked.route.path]\n  }\n\n  return null\n}\n\nexport function findPageByPath(\n  state: IGatsbyState,\n  path: string,\n  fallbackTo404: boolean = false\n): IGatsbyPage | undefined {\n  const { pages } = state\n\n  try {\n    path = decodeURIComponent(path)\n  } catch {\n    // no handling, just continue using path as-is\n  }\n\n  // first check by exact path\n  let page = pages.get(path)\n  if (page) {\n    return page\n  }\n\n  if (path === ``) {\n    // from my tests I never was able to make request with\n    // completely empty pathname, but just for the sake\n    // of completeness - try available alternative\n    page = pages.get(`/`)\n    if (page) {\n      return page\n    }\n  }\n  // Gatsby doesn't allow for page path to be empty string,\n  // so skipping trying to get page for \"\" path if we can't\n  // find page for `/`\n  else if (path !== `/`) {\n    // check various trailing/leading slashes combinations\n    const hasLeadingSlash = path.startsWith(`/`)\n    const hasTrailingSlash = path.endsWith(`/`)\n\n    const bare = path.slice(\n      hasLeadingSlash ? 1 : 0,\n      hasTrailingSlash ? -1 : path.length\n    )\n\n    ;[bare, `/` + bare, bare + `/`, `/` + bare + `/`].some(potentialPath => {\n      page = pages.get(potentialPath)\n      return !!page\n    })\n    if (page) {\n      return page\n    }\n  }\n\n  // we didn't find exact static page, time to check matchPaths\n  // TODO: consider using `match-paths.json` generated by `requires-writer`\n  // to avoid looping through all pages again. Ideally generate smaller `match-paths.json`\n  // variant that doesn't including overlapping static pages in `requires-writer` as well\n  // as this function already checked static paths at this point\n  const matchingPage = findBestMatchingPage(pages, path)\n\n  if (matchingPage) {\n    return matchingPage\n  }\n\n  if (fallbackTo404) {\n    return (\n      findPageByPath(state, `/dev-404-page/`, false) ??\n      findPageByPath(state, `/404.html`, false)\n    )\n  }\n  return undefined\n}\n"],"mappings":";;;;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMA,oBAAoB,GAAG,CAC3BC,KAA+B,EAC/BC,IAAY,KACW;EACvB;EACA;EACA,MAAMC,gBAA6C,GAAG,CAAC,CAAC;EACxD,KAAK,MAAMC,IAAI,IAAIH,KAAK,CAACI,MAAM,EAAE,EAAE;IACjC,MAAMC,SAAS,GAAGF,IAAI,CAACE,SAAS;IAChC,IAAIA,SAAS,EAAE;MACbH,gBAAgB,CAACG,SAAS,CAAC,GAAGF,IAAI;IACpC;EACF;EAEA,MAAMG,MAAM,GAAGC,MAAM,CAACC,IAAI,CAACN,gBAAgB,CAAC,CAACO,GAAG,CAACR,IAAI,IAAI;IACvD,OAAO;MAAEA;IAAK,CAAC;EACjB,CAAC,CAAC;;EAEF;EACA,MAAMS,MAAM,GAAG,IAAAC,iBAAI,EAACL,MAAM,EAAEL,IAAI,CAAC;EAEjC,IAAIS,MAAM,EAAE;IACV,OAAOR,gBAAgB,CAACQ,MAAM,CAACE,KAAK,CAACX,IAAI,CAAC;EAC5C;EAEA,OAAO,IAAI;AACb,CAAC;AAEM,SAASY,cAAc,CAC5BC,KAAmB,EACnBb,IAAY,EACZc,aAAsB,GAAG,KAAK,EACL;EACzB,MAAM;IAAEf;EAAM,CAAC,GAAGc,KAAK;EAEvB,IAAI;IACFb,IAAI,GAAGe,kBAAkB,CAACf,IAAI,CAAC;EACjC,CAAC,CAAC,MAAM;IACN;EAAA;;EAGF;EACA,IAAIE,IAAI,GAAGH,KAAK,CAACiB,GAAG,CAAChB,IAAI,CAAC;EAC1B,IAAIE,IAAI,EAAE;IACR,OAAOA,IAAI;EACb;EAEA,IAAIF,IAAI,KAAM,EAAC,EAAE;IACf;IACA;IACA;IACAE,IAAI,GAAGH,KAAK,CAACiB,GAAG,CAAE,GAAE,CAAC;IACrB,IAAId,IAAI,EAAE;MACR,OAAOA,IAAI;IACb;EACF;EACA;EACA;EACA;EAAA,KACK,IAAIF,IAAI,KAAM,GAAE,EAAE;IACrB;IACA,MAAMiB,eAAe,GAAGjB,IAAI,CAACkB,UAAU,CAAE,GAAE,CAAC;IAC5C,MAAMC,gBAAgB,GAAGnB,IAAI,CAACoB,QAAQ,CAAE,GAAE,CAAC;IAE3C,MAAMC,IAAI,GAAGrB,IAAI,CAACsB,KAAK,CACrBL,eAAe,GAAG,CAAC,GAAG,CAAC,EACvBE,gBAAgB,GAAG,CAAC,CAAC,GAAGnB,IAAI,CAACuB,MAAM,CACpC;IAEA,CAACF,IAAI,EAAG,GAAE,GAAGA,IAAI,EAAEA,IAAI,GAAI,GAAE,EAAG,GAAE,GAAGA,IAAI,GAAI,GAAE,CAAC,CAACG,IAAI,CAACC,aAAa,IAAI;MACtEvB,IAAI,GAAGH,KAAK,CAACiB,GAAG,CAACS,aAAa,CAAC;MAC/B,OAAO,CAAC,CAACvB,IAAI;IACf,CAAC,CAAC;IACF,IAAIA,IAAI,EAAE;MACR,OAAOA,IAAI;IACb;EACF;;EAEA;EACA;EACA;EACA;EACA;EACA,MAAMwB,YAAY,GAAG5B,oBAAoB,CAACC,KAAK,EAAEC,IAAI,CAAC;EAEtD,IAAI0B,YAAY,EAAE;IAChB,OAAOA,YAAY;EACrB;EAEA,IAAIZ,aAAa,EAAE;IAAA;IACjB,0BACEF,cAAc,CAACC,KAAK,EAAG,gBAAe,EAAE,KAAK,CAAC,6DAC9CD,cAAc,CAACC,KAAK,EAAG,WAAU,EAAE,KAAK,CAAC;EAE7C;EACA,OAAOc,SAAS;AAClB"}