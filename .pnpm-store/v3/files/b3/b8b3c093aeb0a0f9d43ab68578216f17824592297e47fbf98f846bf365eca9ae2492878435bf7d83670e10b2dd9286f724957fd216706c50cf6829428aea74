{"version":3,"file":"restricted.js","names":["actions","addThirdPartySchema","schema","plugin","traceId","type","payload","createTypes","types","Array","isArray","map","parseTypeDef","createFieldExtension","extension","dispatch","getState","name","fieldExtensions","schemaCustomization","report","error","reservedExtensionNames","includes","printTypeDefinitions","path","include","exclude","withFieldTypes","createResolverContext","context","camelCase","replace","createSlice","process","env","GATSBY_SLICES","id","message","panic","pluginName","sliceObject","slices","store","panicOnBuild","validateComponent","input","errorIdMap","noPath","notAbsolute","doesNotExist","empty","noDefaultExport","NODE_ENV","trackFeatureIsUsed","componentPath","normalizePath","component","oldSlice","get","contextModified","isEqual","componentModified","componentChunkName","generateComponentChunkName","updatedAt","Date","now","Error","withDeprecationWarning","actionName","action","api","allowedIn","args","warn","a","join","withErrorMessage","nodeAPIs","Object","keys","require","ALLOWED_IN","DEPRECATED_IN","set","availableActionsByAPI","mapAvailableActionsToAPIs","restrictions","actionNames","forEach","deprecatedIn","forbiddenIn","filter"],"sources":["../../../src/redux/actions/restricted.ts"],"sourcesContent":["import camelCase from \"lodash/camelCase\"\nimport isEqual from \"lodash/isEqual\"\n\nimport { GraphQLSchema, GraphQLOutputType } from \"graphql\"\nimport { ActionCreator } from \"redux\"\nimport { ThunkAction } from \"redux-thunk\"\nimport report from \"gatsby-cli/lib/reporter\"\nimport { parseTypeDef } from \"../../schema/types/type-defs\"\nimport {\n  GraphQLFieldExtensionDefinition,\n  reservedExtensionNames,\n} from \"../../schema/extensions\"\nimport { GatsbyGraphQLType } from \"../../schema/types/type-builders\"\nimport {\n  IGatsbyPlugin,\n  ActionsUnion,\n  IAddThirdPartySchema,\n  ICreateTypes,\n  IGatsbyState,\n  ICreateFieldExtension,\n  IPrintTypeDefinitions,\n  ICreateResolverContext,\n  IGatsbyPluginContext,\n  ICreateSliceAction,\n} from \"../types\"\nimport { generateComponentChunkName } from \"../../utils/js-chunk-names\"\nimport { store } from \"../index\"\nimport normalizePath from \"normalize-path\"\nimport { trackFeatureIsUsed } from \"gatsby-telemetry\"\nimport { validateComponent } from \"../../utils/validate-component\"\n\ntype RestrictionActionNames =\n  | \"createFieldExtension\"\n  | \"createTypes\"\n  | \"createResolverContext\"\n  | \"addThirdPartySchema\"\n  | \"printTypeDefinitions\"\n  | \"createSlice\"\n\ntype SomeActionCreator =\n  | ActionCreator<ActionsUnion>\n  | ActionCreator<ThunkAction<any, IGatsbyState, any, ActionsUnion>>\n\nexport interface ICreateSliceInput {\n  id: string\n  component: string\n  context: Record<string, unknown>\n}\n\nexport const actions = {\n  /**\n   * Add a third-party schema to be merged into main schema. Schema has to be a\n   * graphql-js GraphQLSchema object.\n   *\n   * This schema is going to be merged as-is. Merging it in this way will\n   * easily break the main Gatsby Schema. Since we do not want that, therefore\n   * it is the user's responsibility to make sure that it does not happen.\n   * One such way of avoiding it is by namespacing the schema.\n   *\n   * @availableIn [createSchemaCustomization, sourceNodes]\n   *\n   * @param {Object} $0\n   * @param {GraphQLSchema} $0.schema GraphQL schema to add\n   */\n  addThirdPartySchema: (\n    { schema }: { schema: GraphQLSchema },\n    plugin: IGatsbyPlugin,\n    traceId?: string\n  ): IAddThirdPartySchema => {\n    return {\n      type: `ADD_THIRD_PARTY_SCHEMA`,\n      plugin,\n      traceId,\n      payload: schema,\n    }\n  },\n\n  /**\n   * Add type definitions to the GraphQL schema.\n   *\n   * @availableIn [createSchemaCustomization, sourceNodes]\n   *\n   * @param {string | GraphQLOutputType | GatsbyGraphQLType | string[] | GraphQLOutputType[] | GatsbyGraphQLType[]} types Type definitions\n   *\n   * Type definitions can be provided either as\n   * [`graphql-js` types](https://graphql.org/graphql-js/), in\n   * [GraphQL schema definition language (SDL)](https://graphql.org/learn/)\n   * or using Gatsby Type Builders available on the `schema` API argument.\n   *\n   * Things to note:\n   * * type definitions targeting node types, i.e. `MarkdownRemark` and others\n   *   added in `sourceNodes` or `onCreateNode` APIs, need to implement the\n   *   `Node` interface. Interface fields will be added automatically, but it\n   *   is mandatory to label those types with `implements Node`.\n   * * by default, explicit type definitions from `createTypes` will be merged\n   *   with inferred field types, and default field resolvers for `Date` (which\n   *   adds formatting options) and `File` (which resolves the field value as\n   *   a `relativePath` foreign-key field) are added. This behavior can be\n   *   customised with `@infer`, `@dontInfer` directives or extensions. Fields\n   *   may be assigned resolver (and other option like args) with additional\n   *   directives. Currently `@dateformat`, `@link`, `@fileByRelativePath` and\n   *   `@proxy` are available.\n   *\n   *\n   * Schema customization controls:\n   * * `@infer` - run inference on the type and add fields that don't exist on the\n   * defined type to it.\n   * * `@dontInfer` - don't run any inference on the type\n   *\n   * Extensions to add resolver options:\n   * * `@dateformat` - add date formatting arguments. Accepts `formatString` and\n   *   `locale` options that sets the defaults for this field\n   * * `@link` - connect to a different Node. Arguments `by` and `from`, which\n   *   define which field to compare to on a remote node and which field to use on\n   *   the source node\n   * * `@fileByRelativePath` - connect to a File node. Same arguments. The\n   *   difference from link is that this normalizes the relative path to be\n   *   relative from the path where source node is found.\n   * * `@proxy` - in case the underlying node data contains field names with\n   *   characters that are invalid in GraphQL, `proxy` allows to explicitly\n   *   proxy those properties to fields with valid field names. Takes a `from` arg.\n   *\n   *\n   * @example\n   * exports.createSchemaCustomization = ({ actions }) => {\n   *   const { createTypes } = actions\n   *   const typeDefs = `\n   *     \"\"\"\n   *     Markdown Node\n   *     \"\"\"\n   *     type MarkdownRemark implements Node @infer {\n   *       frontmatter: Frontmatter!\n   *     }\n   *\n   *     \"\"\"\n   *     Markdown Frontmatter\n   *     \"\"\"\n   *     type Frontmatter @infer {\n   *       title: String!\n   *       author: AuthorJson! @link\n   *       date: Date! @dateformat\n   *       published: Boolean!\n   *       tags: [String!]!\n   *     }\n   *\n   *     \"\"\"\n   *     Author information\n   *     \"\"\"\n   *     # Does not include automatically inferred fields\n   *     type AuthorJson implements Node @dontInfer {\n   *       name: String!\n   *       birthday: Date! @dateformat(locale: \"ru\")\n   *     }\n   *   `\n   *   createTypes(typeDefs)\n   * }\n   *\n   * // using Gatsby Type Builder API\n   * exports.createSchemaCustomization = ({ actions, schema }) => {\n   *   const { createTypes } = actions\n   *   const typeDefs = [\n   *     schema.buildObjectType({\n   *       name: 'MarkdownRemark',\n   *       fields: {\n   *         frontmatter: 'Frontmatter!'\n   *       },\n   *       interfaces: ['Node'],\n   *       extensions: {\n   *         infer: true,\n   *       },\n   *     }),\n   *     schema.buildObjectType({\n   *       name: 'Frontmatter',\n   *       fields: {\n   *         title: {\n   *           type: 'String!',\n   *           resolve(parent) {\n   *             return parent.title || '(Untitled)'\n   *           }\n   *         },\n   *         author: {\n   *           type: 'AuthorJson'\n   *           extensions: {\n   *             link: {},\n   *           },\n   *         }\n   *         date: {\n   *           type: 'Date!'\n   *           extensions: {\n   *             dateformat: {},\n   *           },\n   *         },\n   *         published: 'Boolean!',\n   *         tags: '[String!]!',\n   *       }\n   *     }),\n   *     schema.buildObjectType({\n   *       name: 'AuthorJson',\n   *       fields: {\n   *         name: 'String!'\n   *         birthday: {\n   *           type: 'Date!'\n   *           extensions: {\n   *             dateformat: {\n   *               locale: 'ru',\n   *             },\n   *           },\n   *         },\n   *       },\n   *       interfaces: ['Node'],\n   *       extensions: {\n   *         infer: false,\n   *       },\n   *     }),\n   *   ]\n   *   createTypes(typeDefs)\n   * }\n   */\n  createTypes: (\n    types:\n      | string\n      | GraphQLOutputType\n      | GatsbyGraphQLType<any, any>\n      | Array<string | GraphQLOutputType | GatsbyGraphQLType<any, any>>,\n    plugin: IGatsbyPlugin,\n    traceId?: string\n  ): ICreateTypes => {\n    return {\n      type: `CREATE_TYPES`,\n      plugin,\n      traceId,\n      payload: Array.isArray(types)\n        ? types.map(parseTypeDef)\n        : parseTypeDef(types),\n    }\n  },\n\n  /**\n   * Add a field extension to the GraphQL schema.\n   *\n   * Extensions allow defining custom behavior which can be added to fields\n   * via directive (in SDL) or on the `extensions` prop (with Type Builders).\n   *\n   * The extension definition takes a `name`, an `extend` function, and optional\n   * extension `args` for options. The `extend` function has to return a (partial)\n   * field config, and receives the extension options and the previous field config\n   * as arguments.\n   *\n   * @availableIn [createSchemaCustomization, sourceNodes]\n   *\n   * @param {GraphQLFieldExtensionDefinition} extension The field extension definition\n   * @example\n   * exports.createSchemaCustomization = ({ actions }) => {\n   *   const { createFieldExtension } = actions\n   *   createFieldExtension({\n   *     name: 'motivate',\n   *     args: {\n   *       caffeine: 'Int'\n   *     },\n   *     extend(options, prevFieldConfig) {\n   *       return {\n   *         type: 'String',\n   *         args: {\n   *           sunshine: {\n   *             type: 'Int',\n   *             defaultValue: 0,\n   *           },\n   *         },\n   *         resolve(source, args, context, info) {\n   *           const motivation = (options.caffeine || 0) - args.sunshine\n   *           if (motivation > 5) return 'Work! Work! Work!'\n   *           return 'Maybe tomorrow.'\n   *         },\n   *       }\n   *     },\n   *   })\n   * }\n   */\n  createFieldExtension:\n    (\n      extension: GraphQLFieldExtensionDefinition,\n      plugin: IGatsbyPlugin,\n      traceId?: string\n    ): ThunkAction<\n      void,\n      IGatsbyState,\n      Record<string, unknown>,\n      ICreateFieldExtension\n    > =>\n    (dispatch, getState): void => {\n      const { name } = extension || {}\n      const { fieldExtensions } = getState().schemaCustomization\n\n      if (!name) {\n        report.error(\n          `The provided field extension must have a \\`name\\` property.`\n        )\n      } else if (reservedExtensionNames.includes(name)) {\n        report.error(\n          `The field extension name \\`${name}\\` is reserved for internal use.`\n        )\n      } else if (fieldExtensions[name]) {\n        report.error(\n          `A field extension with the name \\`${name}\\` has already been registered.`\n        )\n      } else {\n        dispatch({\n          type: `CREATE_FIELD_EXTENSION`,\n          plugin,\n          traceId,\n          payload: { name, extension },\n        })\n      }\n    },\n\n  /**\n   * Write GraphQL schema to file\n   *\n   * Writes out inferred and explicitly specified type definitions. This is not\n   * the full GraphQL schema, but only the types necessary to recreate all type\n   * definitions, i.e. it does not include directives, built-ins, and derived\n   * types for filtering, sorting, pagination etc. Optionally, you can define a\n   * list of types to include/exclude. This is recommended to avoid including\n   * definitions for plugin-created types.\n   *\n   * The first object parameter is required, however all the fields in the object are optional.\n   *\n   * @availableIn [createSchemaCustomization]\n   *\n   * @param {object} $0\n   * @param {string} [$0.path] The path to the output file, defaults to `schema.gql`\n   * @param {object} [$0.include] Configure types to include\n   * @param {string[]} [$0.include.types] Only include these types\n   * @param {string[]} [$0.include.plugins] Only include types owned by these plugins\n   * @param {object} [$0.exclude] Configure types to exclude\n   * @param {string[]} [$0.exclude.types] Do not include these types\n   * @param {string[]} [$0.exclude.plugins] Do not include types owned by these plugins\n   * @param {boolean} [$0.withFieldTypes] Include field types, defaults to `true`\n   * @example\n   * exports.createSchemaCustomization = ({ actions }) => {\n   *   // This code writes a GraphQL schema to a file named `schema.gql`.\n   *   actions.printTypeDefinitions({})\n   * }\n   * @example\n   * exports.createSchemaCustomization = ({ actions }) => {\n   *   // This code writes a GraphQL schema to a file named `schema.gql`, but this time it does not include field types.\n   *   actions.printTypeDefinitions({ withFieldTypes: false })\n   * }\n   */\n  printTypeDefinitions: (\n    {\n      path = `schema.gql`,\n      include,\n      exclude,\n      withFieldTypes = true,\n    }: {\n      path?: string\n      include?: { types?: Array<string>; plugins?: Array<string> }\n      exclude?: { types?: Array<string>; plugins?: Array<string> }\n      withFieldTypes?: boolean\n    },\n    plugin: IGatsbyPlugin,\n    traceId?: string\n  ): IPrintTypeDefinitions => {\n    return {\n      type: `PRINT_SCHEMA_REQUESTED`,\n      plugin,\n      traceId,\n      payload: {\n        path,\n        include,\n        exclude,\n        withFieldTypes,\n      },\n    }\n  },\n\n  /**\n   * Make functionality available on field resolver `context`\n   *\n   * @availableIn [createSchemaCustomization]\n   *\n   * @param {object} context Object to make available on `context`.\n   * When called from a plugin, the context value will be namespaced under\n   * the camel-cased plugin name without the \"gatsby-\" prefix\n   * @example\n   * const getHtml = md => remark().use(html).process(md)\n   * exports.createSchemaCustomization = ({ actions }) => {\n   *   actions.createResolverContext({ getHtml })\n   * }\n   * // The context value can then be accessed in any field resolver like this:\n   * exports.createSchemaCustomization = ({ actions, schema }) => {\n   *   actions.createTypes(schema.buildObjectType({\n   *     name: 'Test',\n   *     interfaces: ['Node'],\n   *     fields: {\n   *       md: {\n   *         type: 'String!',\n   *         async resolve(source, args, context, info) {\n   *           const processed = await context.transformerRemark.getHtml(source.internal.contents)\n   *           return processed.contents\n   *         }\n   *       }\n   *     }\n   *   }))\n   * }\n   */\n  createResolverContext:\n    (\n      context: IGatsbyPluginContext,\n      plugin: IGatsbyPlugin,\n      traceId?: string\n    ): ThunkAction<\n      void,\n      IGatsbyState,\n      Record<string, unknown>,\n      ICreateResolverContext\n    > =>\n    (dispatch): void => {\n      if (!context || typeof context !== `object`) {\n        report.error(\n          `Expected context value passed to \\`createResolverContext\\` to be an object. Received \"${context}\".`\n        )\n      } else {\n        const { name } = plugin || {}\n        const payload =\n          !name || name === `default-site-plugin`\n            ? context\n            : { [camelCase(name.replace(/^gatsby-/, ``))]: context }\n        dispatch({\n          type: `CREATE_RESOLVER_CONTEXT`,\n          plugin,\n          traceId,\n          payload,\n        })\n      }\n    },\n\n  /**\n   * Create a new Slice. See the technical docs for the [Gatsby Slice API](/docs/reference/built-in-components/gatsby-slice).\n   *\n   * @availableIn [createPages]\n   *\n   * @param {object} $0\n   * @param {Object} slice a slice object\n   * @param {string} slice.id The unique ID for this slice\n   * @param {string} slice.component The absolute path to the component for this slice\n   * @param {Object} slice.context Context data for this slice. Passed as props\n   * to the component `this.props.sliceContext` as well as to the graphql query\n   * as graphql arguments.\n   * @example\n   * exports.createPages = ({ actions }) => {\n   *   actions.createSlice({\n   *     id: `navigation-bar`,\n   *     component: path.resolve(`./src/components/navigation-bar.js`),\n   *   })\n   * }\n   */\n  createSlice: (\n    payload: ICreateSliceInput,\n    plugin: IGatsbyPlugin,\n    traceId?: string\n  ): ICreateSliceAction => {\n    if (_CFLAGS_.GATSBY_MAJOR === `5` && process.env.GATSBY_SLICES) {\n      let name = `The plugin \"${plugin.name}\"`\n      if (plugin.name === `default-site-plugin`) {\n        name = `Your site's \"gatsby-node.js\"`\n      }\n\n      if (!payload.id) {\n        const message = `${name} must set the page path when creating a slice`\n        report.panic({\n          id: `11334`,\n          context: {\n            pluginName: name,\n            sliceObject: payload,\n            message,\n          },\n        })\n      }\n\n      const { slices } = store.getState()\n\n      const { error, panicOnBuild } = validateComponent({\n        input: payload,\n        pluginName: name,\n        errorIdMap: {\n          noPath: `11333`,\n          notAbsolute: `11335`,\n          doesNotExist: `11336`,\n          empty: `11337`,\n          noDefaultExport: `11338`,\n        },\n      })\n\n      if (error && process.env.NODE_ENV !== `test`) {\n        if (panicOnBuild) {\n          report.panicOnBuild(error)\n        } else {\n          report.panic(error)\n        }\n      }\n\n      trackFeatureIsUsed(`SliceAPI`)\n\n      const componentPath = normalizePath(payload.component)\n\n      const oldSlice = slices.get(payload.id)\n      const contextModified =\n        !!oldSlice && !isEqual(oldSlice.context, payload.context)\n      const componentModified =\n        !!oldSlice && !isEqual(oldSlice.componentPath, componentPath)\n\n      return {\n        type: `CREATE_SLICE`,\n        plugin,\n        payload: {\n          componentChunkName: generateComponentChunkName(\n            payload.component,\n            `slice`\n          ),\n          componentPath,\n          // note: we use \"name\" internally instead of id\n          name: payload.id,\n          context: payload.context || {},\n          updatedAt: Date.now(),\n        },\n        traceId,\n        componentModified,\n        contextModified,\n      }\n    } else {\n      throw new Error(`createSlice is only available in Gatsby v5`)\n    }\n  },\n}\n\nconst withDeprecationWarning =\n  (\n    actionName: RestrictionActionNames,\n    action: SomeActionCreator,\n    api: API,\n    allowedIn: Array<API>\n  ): SomeActionCreator =>\n  (...args: Array<any>): ReturnType<ActionCreator<any>> => {\n    report.warn(\n      `Calling \\`${actionName}\\` in the \\`${api}\\` API is deprecated. ` +\n        `Please use: ${allowedIn.map(a => `\\`${a}\\``).join(`, `)}.`\n    )\n    return action(...args)\n  }\n\nconst withErrorMessage =\n  (actionName: RestrictionActionNames, api: API, allowedIn: Array<API>) =>\n  () =>\n  // return a thunk that does not dispatch anything\n  (): void => {\n    report.error(\n      `\\`${actionName}\\` is not available in the \\`${api}\\` API. ` +\n        `Please use: ${allowedIn.map(a => `\\`${a}\\``).join(`, `)}.`\n    )\n  }\n\nconst nodeAPIs = Object.keys(require(`../../utils/api-node-docs`))\n\nconst ALLOWED_IN = `ALLOWED_IN`\nconst DEPRECATED_IN = `DEPRECATED_IN`\n\ntype API = string\n\ntype Restrictions = Record<\n  RestrictionActionNames,\n  Partial<{\n    ALLOWED_IN: Array<API>\n    DEPRECATED_IN: Array<API>\n  }>\n>\n\ntype AvailableActionsByAPI = Record<\n  API,\n  { [K in RestrictionActionNames]: SomeActionCreator }\n>\n\nconst set = (\n  availableActionsByAPI: Record<string, any>,\n  api: API,\n  actionName: RestrictionActionNames,\n  action: SomeActionCreator\n): void => {\n  availableActionsByAPI[api] = availableActionsByAPI[api] || {}\n  availableActionsByAPI[api][actionName] = action\n}\n\nconst mapAvailableActionsToAPIs = (\n  restrictions: Restrictions\n): AvailableActionsByAPI => {\n  const availableActionsByAPI: AvailableActionsByAPI = {}\n\n  const actionNames = Object.keys(restrictions) as Array<\n    keyof typeof restrictions\n  >\n  actionNames.forEach(actionName => {\n    const action = actions[actionName]\n\n    const allowedIn: Array<API> = restrictions[actionName][ALLOWED_IN] || []\n    allowedIn.forEach(api =>\n      set(availableActionsByAPI, api, actionName, action)\n    )\n\n    const deprecatedIn: Array<API> =\n      restrictions[actionName][DEPRECATED_IN] || []\n    deprecatedIn.forEach(api =>\n      set(\n        availableActionsByAPI,\n        api,\n        actionName,\n        withDeprecationWarning(actionName, action, api, allowedIn)\n      )\n    )\n\n    const forbiddenIn = nodeAPIs.filter(\n      api => ![...allowedIn, ...deprecatedIn].includes(api)\n    )\n    forbiddenIn.forEach(api =>\n      set(\n        availableActionsByAPI,\n        api,\n        actionName,\n        withErrorMessage(actionName, api, allowedIn)\n      )\n    )\n  })\n\n  return availableActionsByAPI\n}\n\nexport const availableActionsByAPI = mapAvailableActionsToAPIs({\n  createFieldExtension: {\n    [ALLOWED_IN]: [`createSchemaCustomization`],\n    [DEPRECATED_IN]: [`sourceNodes`],\n  },\n  createTypes: {\n    [ALLOWED_IN]: [`createSchemaCustomization`],\n    [DEPRECATED_IN]: [`onPreInit`, `onPreBootstrap`, `sourceNodes`],\n  },\n  createResolverContext: {\n    [ALLOWED_IN]: [`createSchemaCustomization`],\n  },\n  addThirdPartySchema: {\n    [ALLOWED_IN]: [`createSchemaCustomization`],\n    [DEPRECATED_IN]: [`onPreInit`, `onPreBootstrap`, `sourceNodes`],\n  },\n  printTypeDefinitions: {\n    [ALLOWED_IN]: [`createSchemaCustomization`],\n  },\n  createSlice: {\n    [ALLOWED_IN]: [`createPages`],\n  },\n})\n"],"mappings":";;;;;AAAA;AACA;AAKA;AACA;AACA;AAiBA;AACA;AACA;AACA;AACA;AAoBO,MAAMA,OAAO,GAAG;EACrB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,mBAAmB,EAAE,CACnB;IAAEC;EAAkC,CAAC,EACrCC,MAAqB,EACrBC,OAAgB,KACS;IACzB,OAAO;MACLC,IAAI,EAAG,wBAAuB;MAC9BF,MAAM;MACNC,OAAO;MACPE,OAAO,EAAEJ;IACX,CAAC;EACH,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEK,WAAW,EAAE,CACXC,KAImE,EACnEL,MAAqB,EACrBC,OAAgB,KACC;IACjB,OAAO;MACLC,IAAI,EAAG,cAAa;MACpBF,MAAM;MACNC,OAAO;MACPE,OAAO,EAAEG,KAAK,CAACC,OAAO,CAACF,KAAK,CAAC,GACzBA,KAAK,CAACG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"}