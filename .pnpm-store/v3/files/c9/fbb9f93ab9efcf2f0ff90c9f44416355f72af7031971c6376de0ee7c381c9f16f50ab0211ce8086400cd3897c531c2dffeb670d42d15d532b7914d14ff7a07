{"version":3,"file":"schema-hot-reloader.js","names":["inferredTypesChanged","typeMap","prevTypeMap","Object","keys","some","type","dirty","haveEqualFields","lastMetadata","maybeRebuildSchema","inferenceMetadata","store","getState","activity","report","activityTimer","start","rebuild","parentSpan","updateStateAndRunQueries","span","end","snapshotInferenceMetadata","bootstrapSchemaHotReloader","emitter","on","startSchemaHotReloader","stopSchemaHotReloader","off","cancel"],"sources":["../../src/bootstrap/schema-hot-reloader.ts"],"sourcesContent":["import { debounce, cloneDeep } from \"lodash\"\nimport { emitter, store } from \"../redux\"\nimport { rebuild } from \"../schema\"\nimport { haveEqualFields } from \"../schema/infer/inference-metadata\"\nimport { updateStateAndRunQueries } from \"../query/query-watcher\"\nimport report from \"gatsby-cli/lib/reporter\"\nimport { IGatsbyState } from \"../redux/types\"\n\ntype TypeMap = IGatsbyState[\"inferenceMetadata\"][\"typeMap\"]\ntype InferenceMetadata = IGatsbyState[\"inferenceMetadata\"]\n\nconst inferredTypesChanged = (\n  typeMap: TypeMap,\n  prevTypeMap: TypeMap\n): boolean =>\n  Object.keys(typeMap).some(\n    type =>\n      typeMap[type].dirty && !haveEqualFields(typeMap[type], prevTypeMap[type])\n  )\n\nlet lastMetadata: InferenceMetadata\n\n// API_RUNNING_QUEUE_EMPTY could be emitted multiple types\n// in a short period of time, so debounce seems reasonable\nconst maybeRebuildSchema = debounce(async (): Promise<void> => {\n  const { inferenceMetadata } = store.getState()\n\n  if (!inferredTypesChanged(inferenceMetadata.typeMap, lastMetadata.typeMap)) {\n    return\n  }\n\n  const activity = report.activityTimer(`rebuild schema`)\n  activity.start()\n  await rebuild({ parentSpan: activity })\n  await updateStateAndRunQueries(false, { parentSpan: activity.span })\n  activity.end()\n}, 1000)\n\nfunction snapshotInferenceMetadata(): void {\n  const { inferenceMetadata } = store.getState()\n  lastMetadata = cloneDeep(inferenceMetadata)\n}\n\nexport function bootstrapSchemaHotReloader(): void {\n  // Snapshot inference metadata at the time of the last schema rebuild\n  // (even if schema was rebuilt elsewhere)\n  // Using the snapshot later to check if inferred types actually changed since the last rebuild\n  snapshotInferenceMetadata()\n  emitter.on(`SET_SCHEMA`, snapshotInferenceMetadata)\n\n  startSchemaHotReloader()\n}\n\nexport function startSchemaHotReloader(): void {\n  // Listen for node changes outside of a regular sourceNodes API call,\n  // e.g. markdown file update via watcher\n  emitter.on(`API_RUNNING_QUEUE_EMPTY`, maybeRebuildSchema)\n}\n\nexport function stopSchemaHotReloader(): void {\n  emitter.off(`API_RUNNING_QUEUE_EMPTY`, maybeRebuildSchema)\n  maybeRebuildSchema.cancel()\n}\n"],"mappings":";;;;;;;;;AACA;AACA;AACA;AACA;AACA;AAMA,MAAMA,oBAAoB,GAAG,CAC3BC,OAAgB,EAChBC,WAAoB,KAEpBC,MAAM,CAACC,IAAI,CAACH,OAAO,CAAC,CAACI,IAAI,CACvBC,IAAI,IACFL,OAAO,CAACK,IAAI,CAAC,CAACC,KAAK,IAAI,CAAC,IAAAC,kCAAe,EAACP,OAAO,CAACK,IAAI,CAAC,EAAEJ,WAAW,CAACI,IAAI,CAAC,CAAC,CAC5E;AAEH,IAAIG,YAA+B;;AAEnC;AACA;AACA,MAAMC,kBAAkB,GAAG,wBAAS,YAA2B;EAC7D,MAAM;IAAEC;EAAkB,CAAC,GAAGC,YAAK,CAACC,QAAQ,EAAE;EAE9C,IAAI,CAACb,oBAAoB,CAACW,iBAAiB,CAACV,OAAO,EAAEQ,YAAY,CAACR,OAAO,CAAC,EAAE;IAC1E;EACF;EAEA,MAAMa,QAAQ,GAAGC,iBAAM,CAACC,aAAa,CAAE,gBAAe,CAAC;EACvDF,QAAQ,CAACG,KAAK,EAAE;EAChB,MAAM,IAAAC,eAAO,EAAC;IAAEC,UAAU,EAAEL;EAAS,CAAC,CAAC;EACvC,MAAM,IAAAM,sCAAwB,EAAC,KAAK,EAAE;IAAED,UAAU,EAAEL,QAAQ,CAACO;EAAK,CAAC,CAAC;EACpEP,QAAQ,CAACQ,GAAG,EAAE;AAChB,CAAC,EAAE,IAAI,CAAC;AAER,SAASC,yBAAyB,GAAS;EACzC,MAAM;IAAEZ;EAAkB,CAAC,GAAGC,YAAK,CAACC,QAAQ,EAAE;EAC9CJ,YAAY,GAAG,yBAAUE,iBAAiB,CAAC;AAC7C;AAEO,SAASa,0BAA0B,GAAS;EACjD;EACA;EACA;EACAD,yBAAyB,EAAE;EAC3BE,cAAO,CAACC,EAAE,CAAE,YAAW,EAAEH,yBAAyB,CAAC;EAEnDI,sBAAsB,EAAE;AAC1B;AAEO,SAASA,sBAAsB,GAAS;EAC7C;EACA;EACAF,cAAO,CAACC,EAAE,CAAE,yBAAwB,EAAEhB,kBAAkB,CAAC;AAC3D;AAEO,SAASkB,qBAAqB,GAAS;EAC5CH,cAAO,CAACI,GAAG,CAAE,yBAAwB,EAAEnB,kBAAkB,CAAC;EAC1DA,kBAAkB,CAACoB,MAAM,EAAE;AAC7B"}