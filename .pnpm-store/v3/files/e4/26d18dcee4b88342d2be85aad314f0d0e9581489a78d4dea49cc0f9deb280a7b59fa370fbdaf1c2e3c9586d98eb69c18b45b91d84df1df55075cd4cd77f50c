{"version":3,"file":"node-manifest.js","names":["getNodeManifestFileLimit","defaultLimit","overrideLimit","process","env","NODE_MANIFEST_FILE_LIMIT","Number","findPageOwnedByNode","nodeId","fullNode","slug","state","store","getState","pages","staticQueryComponents","byNode","byConnection","trackedComponents","queries","nodeType","internal","type","firstPagePathWithNodeAsDataDependency","get","values","next","value","firstPagePathWithNodeInGraphQLListField","pagePath","startsWith","staticQueryComponentPath","componentPath","firstPagePathUsingStaticQueryComponent","foundPageBy","ownerPagePath","foundOwnerNodeId","pageObject","path","fullPage","ownerNodeId","foundPageIdInContext","context","id","foundPageSlugInContext","pageCreatedByPluginName","getNode","pluginCreatorId","name","pageCreatedByFilesystemPlugin","page","foundPageByToLogIds","none","queryTracking","warnAboutNodeManifestMappingProblems","inputManifest","verbose","logId","reporter","error","Error","processNodeManifest","listOfUniqueErrorIds","nodeManifestPagePathMap","verboseLogs","previouslyWrittenNodeManifests","node","noNodeWarningId","pluginName","add","nodeManifestPage","nodeManifestMappingProblemsContext","finalManifest","gatsbySiteDirectory","program","directory","fileNameBase","manifestId","platform","replace","manifestFilePath","join","manifestFileDir","dirname","fs","ensureDir","previouslyWrittenNodeManifest","shouldWriteManifest","writePromise","writeJSON","set","Promise","resolve","then","info","nodeManifestSortComparerAscendingUpdatedAt","a","b","updatedAtUTC","Date","parse","processNodeManifests","gatsby_log_level","VERBOSE_NODE_MANIFEST","startTime","now","nodeManifests","totalManifests","length","totalProcessedManifests","totalFailedManifests","Map","Set","processNodeManifestTask","manifest","cb","processedManifest","setImmediate","processNodeManifestQueue","fastq","sort","slice","push","idle","drain","pluralize","endTime","size","dispatch","internalActions","deleteNodeManifests"],"sources":["../../src/utils/node-manifest.ts"],"sourcesContent":["import type { ErrorId } from \"gatsby-cli/lib/structured-errors/error-map\"\nimport { getNode } from \"./../datastore\"\nimport { IGatsbyNode, IGatsbyPage, INodeManifest } from \"./../redux/types\"\nimport reporter from \"gatsby-cli/lib/reporter\"\nimport { store } from \"../redux/\"\nimport { internalActions } from \"../redux/actions\"\nimport path from \"path\"\nimport fs from \"fs-extra\"\nimport fastq from \"fastq\"\n\ninterface INodeManifestPage {\n  path?: string\n}\n\n/**\n * This it the output after processing calls to the public unstable_createNodeManifest action\n */\ninterface INodeManifestOut {\n  page: INodeManifestPage\n  node: {\n    id: string\n  }\n  foundPageBy: FoundPageBy\n}\n\ntype FoundPageBy =\n  | `ownerNodeId`\n  | `filesystem-route-api`\n  // for these three we warn to use ownerNodeId instead\n  | `context.id`\n  | `context.slug`\n  | `queryTracking`\n  | `none`\n\ntype PreviouslyWrittenNodeManifests = Map<string, Promise<INodeManifestOut>>\n\nfunction getNodeManifestFileLimit(): number {\n  const defaultLimit = 10000\n\n  const overrideLimit =\n    process.env.NODE_MANIFEST_FILE_LIMIT &&\n    Number(process.env.NODE_MANIFEST_FILE_LIMIT)\n\n  return overrideLimit || defaultLimit\n}\n/**\n * This defines a limit to the number number of node manifest files that will be written to disk\n */\nconst NODE_MANIFEST_FILE_LIMIT = getNodeManifestFileLimit()\n\n/**\n * Finds a final built page by nodeId or by node.slug as a fallback.\n *\n * Note that this function wont work properly in `gatsby develop`\n * since develop no longer runs all page queries when creating pages.\n * We use the node id to query mapping to find the right page but\n * this mapping only exists once you've visited a page in your browser.\n * When this fn is being used for routing to previews the user wont necessarily have\n * visited the page in the browser yet.\n */\nasync function findPageOwnedByNode({\n  nodeId,\n  fullNode,\n  slug,\n}: {\n  nodeId: string\n  fullNode: IGatsbyNode\n  slug?: string\n}): Promise<{\n  page: INodeManifestPage\n  foundPageBy: FoundPageBy\n}> {\n  const state = store.getState()\n  const { pages, staticQueryComponents } = state\n  const { byNode, byConnection, trackedComponents } = state.queries\n\n  const nodeType = fullNode?.internal?.type\n\n  const firstPagePathWithNodeAsDataDependency =\n    // the first page found in node id to page query path tracking\n    byNode?.get(nodeId)?.values()?.next()?.value\n\n  const firstPagePathWithNodeInGraphQLListField =\n    // the first page that queries for a list of this node type.\n    // we don't currently store a list of node ids for connection fields to queries\n    // we just store the query id or page path mapped to the connected GraphQL typename.\n    byConnection?.get(nodeType)?.values()?.next()?.value\n\n  let pagePath =\n    firstPagePathWithNodeAsDataDependency ||\n    firstPagePathWithNodeInGraphQLListField\n\n  // for static queries, we can only find the first page using that static query\n  // the reason we would find `sq--` here is because byConnection (above) can return a page path or a static query ID (which starts with `sq--`)\n  if (pagePath?.startsWith(`sq--`)) {\n    const staticQueryComponentPath =\n      staticQueryComponents?.get(pagePath)?.componentPath\n\n    const firstPagePathUsingStaticQueryComponent: string | null =\n      staticQueryComponentPath\n        ? trackedComponents\n            ?.get(staticQueryComponentPath)\n            ?.pages?.values()\n            ?.next()?.value\n        : null\n\n    pagePath = firstPagePathUsingStaticQueryComponent\n  }\n\n  let foundPageBy: FoundPageBy = pagePath ? `queryTracking` : `none`\n\n  if (pages) {\n    let ownerPagePath: string | undefined\n    let foundOwnerNodeId = false\n\n    // for each page this nodeId is queried in\n    for (const pageObject of pages.values()) {\n      // if we haven't found a page with this nodeId\n      // set as page.ownerNodeId then run this logic.\n      // this condition is on foundOwnerNodeId instead of ownerPagePath\n      // in case we find a page with the nodeId in page.context.id/context.slug\n      // and then later in the loop there's a page with this nodeId\n      // set on page.ownerNodeId.\n      // We always want to prefer ownerPagePath over context.id/context.slug\n      if (foundOwnerNodeId) {\n        break\n      }\n\n      const path = pageObject.path\n\n      const fullPage: IGatsbyPage | undefined = pages.get(path)\n\n      foundOwnerNodeId = fullPage?.ownerNodeId === nodeId\n\n      const foundPageIdInContext = fullPage?.context?.id === nodeId\n\n      // querying by node.slug in GraphQL queries is common enough that we can search for it as a fallback after ownerNodeId, filesystem routes, and context.id\n      const foundPageSlugInContext = slug && fullPage?.context?.slug === slug\n\n      if (foundOwnerNodeId) {\n        foundPageBy = `ownerNodeId`\n      } else if (foundPageIdInContext && fullPage) {\n        const pageCreatedByPluginName = getNode(fullPage.pluginCreatorId)?.name\n\n        const pageCreatedByFilesystemPlugin =\n          pageCreatedByPluginName === `gatsby-plugin-page-creator`\n\n        foundPageBy = pageCreatedByFilesystemPlugin\n          ? `filesystem-route-api`\n          : `context.id`\n      } else if (foundPageSlugInContext && fullPage) {\n        foundPageBy = `context.slug`\n      }\n\n      if (\n        fullPage &&\n        // first check for the ownerNodeId on the page. this is\n        // the defacto owner. Can't get more specific than this\n        (foundOwnerNodeId ||\n          // if there's no specified owner look to see if\n          // pageContext has an `id` variable which matches our\n          // nodeId. Using an \"id\" as a variable in queries is common\n          // and if we don't have an owner this is a better guess\n          // of an owner than grabbing the first page query we find\n          // that's mapped to this node id.\n          // this also makes this work with the filesystem Route API without\n          // changing that API.\n          foundPageIdInContext ||\n          foundPageSlugInContext)\n      ) {\n        // save this path to use in our manifest!\n        ownerPagePath = fullPage.path\n      }\n    }\n\n    if (ownerPagePath) {\n      pagePath = ownerPagePath\n    }\n  }\n\n  return {\n    page: {\n      path: pagePath || null,\n    },\n    foundPageBy,\n  }\n}\n\n// these id's correspond to error id's in\n// packages/gatsby-cli/src/structured-errors/error-map.ts\nexport const foundPageByToLogIds = {\n  none: `11801`,\n  [`context.id`]: `11802`,\n  [`context.slug`]: `11805`,\n  queryTracking: `11803`,\n  [`filesystem-route-api`]: `success`,\n  ownerNodeId: `success`,\n}\n\n/**\n * Takes in some info about a node manifest and the page we did or didn't find for it, then warns and returns the warning string\n */\nexport function warnAboutNodeManifestMappingProblems({\n  inputManifest,\n  pagePath,\n  foundPageBy,\n  verbose,\n}: {\n  inputManifest: INodeManifest\n  pagePath?: string\n  foundPageBy: FoundPageBy\n  verbose: boolean\n}): { logId: string } {\n  let logId: ErrorId | `success`\n\n  switch (foundPageBy) {\n    case `none`:\n    case `context.id`:\n    case `context.slug`:\n    case `queryTracking`: {\n      logId = foundPageByToLogIds[foundPageBy]\n      if (verbose) {\n        reporter.error({\n          id: logId,\n          context: {\n            inputManifest,\n            pagePath,\n          },\n        })\n      }\n      break\n    }\n\n    case `filesystem-route-api`:\n    case `ownerNodeId`:\n      logId = `success`\n      break\n\n    default: {\n      throw Error(`Node Manifest mapping is in an impossible state`)\n    }\n  }\n\n  return {\n    logId,\n  }\n}\n\n/**\n * Prepares and then writes out an individual node manifest file to be used for routing to previews. Manifest files are added via the public unstable_createNodeManifest action\n */\nexport async function processNodeManifest(\n  inputManifest: INodeManifest,\n  listOfUniqueErrorIds: Set<string>,\n  nodeManifestPagePathMap: Map<string, string>,\n  verboseLogs: boolean,\n  previouslyWrittenNodeManifests: PreviouslyWrittenNodeManifests\n): Promise<null | INodeManifestOut> {\n  const nodeId = inputManifest.node.id\n  const fullNode = getNode(nodeId)\n  const noNodeWarningId = `11804`\n\n  if (!fullNode) {\n    if (verboseLogs) {\n      reporter.error({\n        id: noNodeWarningId,\n        context: {\n          pluginName: inputManifest.pluginName,\n          nodeId,\n        },\n      })\n    } else {\n      listOfUniqueErrorIds.add(noNodeWarningId)\n    }\n\n    return null\n  }\n\n  // map the node to a page that was created\n  const { page: nodeManifestPage, foundPageBy } = await findPageOwnedByNode({\n    nodeId,\n    fullNode,\n    // querying by node.slug in GraphQL queries is common enough that we can search for it as a fallback after ownerNodeId, filesystem routes, and context.id\n    slug: fullNode?.slug as string,\n  })\n\n  const nodeManifestMappingProblemsContext = {\n    inputManifest,\n    pagePath: nodeManifestPage.path,\n    foundPageBy,\n    verbose: verboseLogs,\n  }\n\n  if (verboseLogs) {\n    warnAboutNodeManifestMappingProblems(nodeManifestMappingProblemsContext)\n  } else {\n    const { logId } = warnAboutNodeManifestMappingProblems(\n      nodeManifestMappingProblemsContext\n    )\n\n    if (logId !== `success`) {\n      listOfUniqueErrorIds.add(logId)\n    }\n  }\n\n  const finalManifest: INodeManifestOut = {\n    node: inputManifest.node,\n    page: nodeManifestPage,\n    foundPageBy,\n  }\n\n  const gatsbySiteDirectory = store.getState().program.directory\n\n  let fileNameBase = inputManifest.manifestId\n\n  /**\n   * Windows has a handful of special/reserved characters that are not valid in a file path\n   * @reference https://superuser.com/questions/358855/what-characters-are-safe-in-cross-platform-file-names-for-linux-windows-and-os\n   *\n   * The two exceptions to the list linked above are\n   * - the colon that is part of the hard disk partition name at the beginning of a file path (i.e. C:)\n   * - backslashes. We don't want to replace backslashes because those are used to delineate what the actual file path is\n   *\n   * During local development, node manifests can be written to disk but are generally unused as they are only used\n   * for Content Sync which runs in Gatsby Cloud. Gatsby cloud is a Linux environment in which these special chars are valid in\n   * filepaths. To avoid errors on Windows, we replace all instances of the special chars in the filepath (with the exception of the\n   * hard disk partition name) with \"-\" to ensure that local Windows development setups do not break when attempting\n   * to write one of these manifests to disk.\n   */\n  if (process.platform === `win32`) {\n    fileNameBase = fileNameBase.replace(/:|\\/|\\*|\\?|\"|<|>|\\||\\\\/g, `-`)\n  }\n\n  // write out the manifest file\n  const manifestFilePath = path.join(\n    gatsbySiteDirectory,\n    `public`,\n    `__node-manifests`,\n    inputManifest.pluginName,\n    `${fileNameBase}.json`\n  )\n\n  const manifestFileDir = path.dirname(manifestFilePath)\n\n  await fs.ensureDir(manifestFileDir)\n\n  const previouslyWrittenNodeManifest =\n    await previouslyWrittenNodeManifests.get(inputManifest.manifestId)\n\n  // write a manifest if we don't currently have one written for this ID\n  // or if we can replace the written one with a manifest that has found a page\n  // NOTE: We still want to write out a manifest if foundPageBy is \"none\", this helps with error messaging\n  //       But we prefer to write a manifest that has a foundPageBy that is NOT \"none\"\n  const shouldWriteManifest =\n    !previouslyWrittenNodeManifest ||\n    (previouslyWrittenNodeManifest?.foundPageBy === `none` &&\n      finalManifest.foundPageBy !== `none`)\n\n  if (shouldWriteManifest) {\n    const writePromise = fs.writeJSON(manifestFilePath, finalManifest)\n\n    // This prevents two manifests from writing to the same file at the same time\n    previouslyWrittenNodeManifests.set(\n      inputManifest.manifestId,\n      new Promise(resolve => {\n        writePromise.then(() => {\n          resolve(finalManifest)\n        })\n      })\n    )\n\n    await writePromise\n  }\n\n  if (shouldWriteManifest && verboseLogs) {\n    reporter.info(\n      `Plugin ${inputManifest.pluginName} created a manifest with the id ${fileNameBase}`\n    )\n  } else if (verboseLogs) {\n    reporter.info(\n      `Plugin ${inputManifest.pluginName} created a manifest with the id ${fileNameBase} but it was not written to disk because it was already written to disk previously.`\n    )\n  }\n\n  if (nodeManifestPage.path) {\n    nodeManifestPagePathMap.set(nodeManifestPage.path, fileNameBase)\n  }\n\n  return finalManifest\n}\n\nfunction nodeManifestSortComparerAscendingUpdatedAt(a, b): number {\n  /**\n   * Prioritize node manifests that have an updatedAtUTC so that manifests known to be\n   * newest are written to disk first. If neither have an updatedAtUTC, there isn't\n   * anything to sort\n   */\n  if (!a.updatedAtUTC && !b.updatedAtUTC) {\n    return 0\n  }\n\n  if (!a.updatedAtUTC) {\n    return 1\n  }\n\n  if (!b.updatedAtUTC) {\n    return -1\n  }\n\n  return Date.parse(a.updatedAtUTC) - Date.parse(b.updatedAtUTC)\n}\n\n/**\n * Grabs all pending node manifests, processes them, writes them to disk,\n * and then removes them from the store.\n * Manifest files are added via the public unstable_createNodeManifest action in sourceNodes\n */\nexport async function processNodeManifests(): Promise<Map<\n  string,\n  string\n> | null> {\n  const verboseLogs =\n    process.env.gatsby_log_level === `verbose` ||\n    process.env.VERBOSE_NODE_MANIFEST === `true`\n\n  const startTime = Date.now()\n  let { nodeManifests } = store.getState()\n\n  const totalManifests = nodeManifests.length\n\n  if (totalManifests === 0) {\n    return null\n  }\n\n  let totalProcessedManifests = 0\n  let totalFailedManifests = 0\n  const nodeManifestPagePathMap: Map<string, string> = new Map()\n  const listOfUniqueErrorIds: Set<string> = new Set()\n  const previouslyWrittenNodeManifests: PreviouslyWrittenNodeManifests =\n    new Map()\n\n  async function processNodeManifestTask(\n    manifest: INodeManifest,\n    cb: fastq.done<any>\n  ): Promise<void> {\n    const processedManifest = await processNodeManifest(\n      manifest,\n      listOfUniqueErrorIds,\n      nodeManifestPagePathMap,\n      verboseLogs,\n      previouslyWrittenNodeManifests\n    )\n\n    if (processedManifest) {\n      totalProcessedManifests++\n    } else {\n      totalFailedManifests++\n    }\n\n    // `setImmediate` below is a workaround against stack overflow\n    // occurring when there are many manifests\n    setImmediate(() => cb(null, true))\n    return\n  }\n\n  const processNodeManifestQueue = fastq(processNodeManifestTask, 25)\n\n  if (totalManifests > NODE_MANIFEST_FILE_LIMIT) {\n    nodeManifests = [...nodeManifests]\n    nodeManifests.sort(nodeManifestSortComparerAscendingUpdatedAt)\n    nodeManifests = nodeManifests.slice(0, NODE_MANIFEST_FILE_LIMIT)\n  }\n\n  for (const manifest of nodeManifests) {\n    processNodeManifestQueue.push(manifest, () => {})\n  }\n\n  if (!processNodeManifestQueue.idle()) {\n    await new Promise(resolve => {\n      processNodeManifestQueue.drain = resolve as () => unknown\n    })\n  }\n\n  const pluralize = (length: number): string =>\n    length > 1 || length === 0 ? `s` : ``\n\n  const endTime = Date.now()\n\n  reporter.info(\n    `Wrote out ${totalProcessedManifests} node page manifest file${pluralize(\n      totalProcessedManifests\n    )} in ${endTime - startTime} ms. ${\n      totalFailedManifests > 0\n        ? `. ${totalFailedManifests} manifest${pluralize(\n            totalFailedManifests\n          )} couldn't be processed.`\n        : ``\n    }`\n  )\n\n  reporter.info(\n    (!verboseLogs && listOfUniqueErrorIds.size > 0\n      ? `unstable_createNodeManifest produced warnings [${[\n          ...listOfUniqueErrorIds,\n        ].join(`, `)}]. `\n      : ``) +\n      `To see full warning messages set process.env.VERBOSE_NODE_MANIFEST to \"true\".\\nVisit https://gatsby.dev/nodemanifest for more info on Node Manifests.`\n  )\n\n  // clean up all pending manifests from the store\n  store.dispatch(internalActions.deleteNodeManifests())\n  return nodeManifestPagePathMap\n}\n"],"mappings":"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"}