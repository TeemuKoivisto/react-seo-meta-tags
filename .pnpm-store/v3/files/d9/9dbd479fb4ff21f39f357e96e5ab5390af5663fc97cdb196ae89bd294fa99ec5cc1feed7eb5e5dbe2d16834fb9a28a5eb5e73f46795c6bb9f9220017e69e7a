{"version":3,"file":"index.js","names":["tracer","require","globalTracer","store","getDataStore","getTypes","createSchemaComposer","buildSchema","builtInFieldExtensions","builtInTypeDefinitions","TypeConflictReporter","shouldPrintEngineSnapshot","getAllTypeDefinitions","schemaCustomization","types","getState","builtInTypes","map","typeDef","typeOrTypeDef","plugin","undefined","filter","type","name","getAllFieldExtensions","fieldExtensions","customFieldExtensions","buildInferenceMetadata","Promise","resolve","length","typeNames","processNextType","typeName","pop","processingNodes","dispatchCount","dispatchNodes","res","dispatch","payload","clearExistingMetadata","nodes","setImmediate","node","iterateNodesByType","push","build","parentSpan","fullMetadataBuild","spanArgs","childOf","span","startSpan","ready","thirdPartySchemas","printConfig","inferenceMetadata","config","mapping","typeMapping","program","directory","typeConflictReporter","enginePrintConfig","path","rewrite","schemaComposer","schema","printConflicts","finish","rebuild","module","exports"],"sources":["../../src/schema/index.js"],"sourcesContent":["/* @flow */\n\nconst tracer = require(`opentracing`).globalTracer()\nconst { store } = require(`../redux`)\nconst { getDataStore, getTypes } = require(`../datastore`)\nconst { createSchemaComposer } = require(`./schema-composer`)\nconst { buildSchema } = require(`./schema`)\nconst { builtInFieldExtensions } = require(`./extensions`)\nconst { builtInTypeDefinitions } = require(`./types/built-in-types`)\nconst { TypeConflictReporter } = require(`./infer/type-conflict-reporter`)\nconst { shouldPrintEngineSnapshot } = require(`../utils/engines-helpers`)\n\nconst getAllTypeDefinitions = () => {\n  const {\n    schemaCustomization: { types },\n  } = store.getState()\n\n  const builtInTypes = builtInTypeDefinitions().map(typeDef => {\n    return {\n      typeOrTypeDef: typeDef,\n      plugin: undefined,\n    }\n  })\n\n  // Ensure that user-defined types are processed last\n  return [\n    ...builtInTypes,\n    ...types.filter(\n      type => type.plugin && type.plugin.name !== `default-site-plugin`\n    ),\n    ...types.filter(\n      type => !type.plugin || type.plugin.name === `default-site-plugin`\n    ),\n  ]\n}\n\nconst getAllFieldExtensions = () => {\n  const {\n    schemaCustomization: { fieldExtensions: customFieldExtensions },\n  } = store.getState()\n\n  return {\n    ...customFieldExtensions,\n    ...builtInFieldExtensions,\n  }\n}\n\n// Schema building requires metadata for type inference.\n// Technically it means looping through all type nodes, analyzing node structure\n// and then using this aggregated node structure in related GraphQL type.\n// Actual logic for inference located in inferenceMetadata reducer and ./infer\n// Here we just orchestrate the process via redux actions\nconst buildInferenceMetadata = ({ types }) =>\n  new Promise(resolve => {\n    if (!types || !types.length) {\n      resolve()\n      return\n    }\n    const typeNames = [...types]\n    // TODO: use async iterators when we switch to node>=10\n    //  or better investigate if we can offload metadata building to worker/Jobs API\n    //  and then feed the result into redux?\n    const processNextType = async () => {\n      const typeName = typeNames.pop()\n\n      let processingNodes = []\n      let dispatchCount = 0\n      function dispatchNodes() {\n        return new Promise(res => {\n          store.dispatch({\n            type: `BUILD_TYPE_METADATA`,\n            payload: {\n              typeName,\n              // only clear metadata on the first chunk for this type\n              clearExistingMetadata: dispatchCount++ === 0,\n              nodes: processingNodes,\n            },\n          })\n          setImmediate(() => {\n            // clear this array after BUILD_TYPE_METADATA reducer has synchronously run\n            processingNodes = []\n            // dont block the event loop. node may decide to free previous processingNodes array from memory if it needs to.\n            setImmediate(() => {\n              res(null)\n            })\n          })\n        })\n      }\n\n      for (const node of getDataStore().iterateNodesByType(typeName)) {\n        processingNodes.push(node)\n\n        if (processingNodes.length > 1000) {\n          await dispatchNodes()\n        }\n      }\n\n      if (processingNodes.length > 0) {\n        await dispatchNodes()\n      }\n\n      if (typeNames.length > 0) {\n        // dont block the event loop\n        setImmediate(() => processNextType())\n      } else {\n        resolve()\n      }\n    }\n    processNextType()\n  })\n\nconst build = async ({ parentSpan, fullMetadataBuild = true }) => {\n  const spanArgs = parentSpan ? { childOf: parentSpan } : {}\n  const span = tracer.startSpan(`build schema`, spanArgs)\n  await getDataStore().ready()\n\n  if (fullMetadataBuild) {\n    // Build metadata for type inference and start updating it incrementally\n    await buildInferenceMetadata({ types: getTypes() })\n    store.dispatch({ type: `START_INCREMENTAL_INFERENCE` })\n  }\n\n  const {\n    schemaCustomization: { thirdPartySchemas, printConfig },\n    inferenceMetadata,\n    config: { mapping: typeMapping },\n    program: { directory },\n  } = store.getState()\n\n  const typeConflictReporter = new TypeConflictReporter()\n\n  const enginePrintConfig = shouldPrintEngineSnapshot()\n    ? {\n        path: `${directory}/.cache/schema.gql`,\n        rewrite: true,\n      }\n    : undefined\n\n  const fieldExtensions = getAllFieldExtensions()\n  const schemaComposer = createSchemaComposer({ fieldExtensions })\n  const schema = await buildSchema({\n    schemaComposer,\n    types: getAllTypeDefinitions(),\n    fieldExtensions,\n    thirdPartySchemas,\n    typeMapping,\n    printConfig,\n    enginePrintConfig,\n    typeConflictReporter,\n    inferenceMetadata,\n    parentSpan,\n  })\n\n  typeConflictReporter.printConflicts()\n\n  store.dispatch({\n    type: `SET_SCHEMA_COMPOSER`,\n    payload: schemaComposer,\n  })\n  store.dispatch({\n    type: `SET_SCHEMA`,\n    payload: schema,\n  })\n\n  span.finish()\n}\n\nconst rebuild = async ({ parentSpan }) =>\n  await build({ parentSpan, fullMetadataBuild: false })\n\nmodule.exports = {\n  build,\n  rebuild,\n}\n"],"mappings":"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"}