{"version":3,"file":"build-example-data.js","names":["getExampleObject","fieldMap","typeName","typeConflictReporter","Object","keys","reduce","acc","key","value","buildExampleValue","path","descriptor","isArrayItem","type","conflicts","resolveWinnerType","addConflict","prepareConflictExamples","typeInfo","isMixOfDateAndString","hasOnlyEmptyStrings","example","item","exampleItemValue","nodes","multiple","linkedNodes","filter","dprops","hasKeys","result","forEach","prop","candidates","possibleTypes","length","isMixedNumber","typeNameMapper","includes","reportedValueMapper","relatedNode","find","relatedNodeList","object","itemValue","array","undefined","conflictingTypes","groups","first","map","nodeId","join","float","int","Boolean","total","date","string","empty"],"sources":["../../../src/schema/infer/build-example-data.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-use-before-define */\nimport { groupBy } from \"lodash\"\nimport {\n  IValueDescriptor,\n  ValueType,\n  ITypeMetadata,\n} from \"./inference-metadata\"\nimport {\n  TypeConflictReporter,\n  ITypeConflictExample,\n} from \"./type-conflict-reporter\"\n\n// See gatsby/src/schema/infer/inference-metadata.ts for the ValueDescriptor structs (-> typeInfo)\n\nconst getExampleObject = ({\n  fieldMap = {},\n  typeName,\n  typeConflictReporter,\n}: ITypeMetadata): { [k: string]: unknown } =>\n  Object.keys(fieldMap).reduce((acc, key) => {\n    const value = buildExampleValue({\n      path: `${typeName}.${key}`,\n      descriptor: fieldMap[key],\n      typeConflictReporter,\n    })\n    if (key && value !== null) {\n      acc[key] = value\n    }\n    return acc\n  }, {})\n\nconst buildExampleValue = ({\n  descriptor,\n  typeConflictReporter,\n  isArrayItem = false,\n  path = ``,\n}: {\n  descriptor: IValueDescriptor\n  typeConflictReporter?: TypeConflictReporter\n  path?: string\n  isArrayItem?: boolean\n}): unknown | null => {\n  const [type, conflicts = false] = resolveWinnerType(descriptor)\n\n  if (conflicts && typeConflictReporter) {\n    typeConflictReporter.addConflict(\n      path,\n      prepareConflictExamples(descriptor, isArrayItem)\n    )\n  }\n\n  const typeInfo = descriptor[type]\n\n  switch (type) {\n    case `null`:\n      return null\n\n    case `date`:\n    case `string`: {\n      if (isMixOfDateAndString(descriptor)) {\n        return hasOnlyEmptyStrings(descriptor) ? `1978-09-26` : `String`\n      }\n      return typeInfo.example\n    }\n\n    case `array`: {\n      const { item } = typeInfo\n      const exampleItemValue = item\n        ? buildExampleValue({\n            descriptor: item,\n            isArrayItem: true,\n            typeConflictReporter,\n            path,\n          })\n        : null\n      return exampleItemValue === null ? null : [exampleItemValue]\n    }\n\n    case `relatedNode`:\n    case `relatedNodeList`: {\n      const { nodes = {} } = typeInfo\n      return {\n        multiple: type === `relatedNodeList`,\n        linkedNodes: Object.keys(nodes).filter(key => nodes[key] > 0),\n      }\n    }\n\n    case `object`: {\n      const { dprops } = typeInfo\n      let hasKeys = false\n      const result = {}\n      Object.keys(dprops).forEach(prop => {\n        const value = buildExampleValue({\n          descriptor: dprops[prop],\n          typeConflictReporter,\n          path: `${path}.${prop}`,\n        })\n        if (value !== null) {\n          hasKeys = true\n          result[prop] = value\n        }\n      })\n      return hasKeys ? result : null\n    }\n\n    default:\n      return typeInfo.example\n  }\n}\n\nconst resolveWinnerType = (\n  descriptor: IValueDescriptor\n): [ValueType | \"null\", boolean?] => {\n  const candidates = possibleTypes(descriptor)\n  if (candidates.length === 1) {\n    return [candidates[0]]\n  }\n  if (candidates.length === 2 && isMixedNumber(descriptor)) {\n    return [`float`]\n  }\n  if (candidates.length === 2 && isMixOfDateAndString(descriptor)) {\n    return [hasOnlyEmptyStrings(descriptor) ? `date` : `string`]\n  }\n  if (candidates.length > 1) {\n    return [`null`, true]\n  }\n  return [`null`]\n}\n\nconst prepareConflictExamples = (\n  descriptor: IValueDescriptor,\n  isArrayItem: boolean\n): Array<ITypeConflictExample> => {\n  const typeNameMapper = (typeName: ValueType): string => {\n    if (typeName === `relatedNode`) {\n      return `string`\n    }\n    if (typeName === `relatedNodeList`) {\n      return `[string]`\n    }\n    return [`float`, `int`].includes(typeName) ? `number` : typeName\n  }\n  const reportedValueMapper = (typeName: ValueType): unknown => {\n    if (typeName === `relatedNode`) {\n      const { nodes } = descriptor.relatedNode ?? { nodes: {} }\n      return Object.keys(nodes).find(key => nodes[key] > 0)\n    }\n    if (typeName === `relatedNodeList`) {\n      const { nodes } = descriptor.relatedNodeList ?? { nodes: {} }\n      return Object.keys(nodes).filter(key => nodes[key] > 0)\n    }\n    if (typeName === `object`) {\n      return getExampleObject({\n        typeName,\n        fieldMap: descriptor!.object!.dprops,\n      })\n    }\n    if (typeName === `array`) {\n      const itemValue = buildExampleValue({\n        descriptor: descriptor!.array!.item,\n        isArrayItem: true,\n      })\n      return itemValue === null || itemValue === undefined ? [] : [itemValue]\n    }\n    return descriptor[typeName]?.example\n  }\n  const conflictingTypes = possibleTypes(descriptor)\n\n  if (isArrayItem) {\n    // Differentiate conflict examples by node they were first seen in.\n    // See Caveats section in the header of the ./inference-metadata.ts\n    const groups = groupBy(\n      conflictingTypes,\n      type => descriptor[type]?.first || ``\n    )\n    return Object.keys(groups).map(nodeId => {\n      return {\n        type: `[${groups[nodeId].map(typeNameMapper).join(`,`)}]`,\n        value: groups[nodeId].map(reportedValueMapper),\n      }\n    })\n  }\n\n  return conflictingTypes.map(type => {\n    return {\n      type: typeNameMapper(type),\n      value: reportedValueMapper(type),\n    }\n  })\n}\n\nconst isMixedNumber = (descriptor: IValueDescriptor): boolean => {\n  const { float, int } = descriptor\n  return Boolean(float?.total) && Boolean(int?.total)\n}\n\nconst isMixOfDateAndString = (descriptor: IValueDescriptor): boolean => {\n  const { date, string } = descriptor\n  return Boolean(date?.total) && Boolean(string?.total)\n}\n\nconst hasOnlyEmptyStrings = (descriptor: IValueDescriptor): boolean => {\n  const { string } = descriptor\n  return string !== undefined && string?.empty === string?.total\n}\n\nconst possibleTypes = (descriptor: IValueDescriptor = {}): Array<ValueType> =>\n  Object.keys(descriptor).filter(\n    type => descriptor[type].total > 0\n  ) as Array<ValueType>\n\nexport { getExampleObject }\n"],"mappings":"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"}