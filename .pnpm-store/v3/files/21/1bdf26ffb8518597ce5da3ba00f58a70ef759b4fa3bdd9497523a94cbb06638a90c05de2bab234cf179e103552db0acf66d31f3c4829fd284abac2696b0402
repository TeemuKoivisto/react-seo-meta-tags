{"version":3,"file":"index.umd.js","sources":["../src/index.ts"],"sourcesContent":["import {\n    JSXAttribute,\n    JSXIdentifier,\n    JSXNamespacedName,\n    JSXOpeningElement,\n} from \"@babel/types\";\nimport { NodePath as CoreNodePath } from \"@babel/core\";\nimport { NodePath as TraverseNodePath } from \"@babel/traverse\";\n\nexport function parseIdentifier(\n    identifier: JSXIdentifier | JSXNamespacedName\n): string {\n    if (identifier.type === `JSXIdentifier`) {\n        return identifier.name;\n    }\n    return parseIdentifier(identifier.name);\n}\n\n/**\n * Get all attribute values of a JSX element. This only includes values that can be statically-analysed.\n * Pass the `onError` callback to be notified if an attribute cannot be resolved.\n *\n * @param nodePath The NodePath of the JSX opening element\n * @param onError Called with the attribute name and path if it is present but cannot be resolved\n * @param include If present, only these props are evaluated. Does not apply to spread attributes.\n */\nexport function getAttributeValues(\n    nodePath:\n        | CoreNodePath<JSXOpeningElement>\n        | TraverseNodePath<JSXOpeningElement>,\n    onError?: (\n        attributeName: string,\n        attributePath?: CoreNodePath<JSXAttribute>\n    ) => void,\n    include?: Set<string>\n): Record<string, unknown> {\n    let result: Record<string, unknown> = {};\n\n    nodePath.traverse({\n        JSXSpreadAttribute(attrPath) {\n            const spreadValues = attrPath.get(`argument`).evaluate();\n            if (spreadValues.confident) {\n                result = { ...result, ...spreadValues.value };\n            } else {\n                onError?.(`<spread attributes>`);\n            }\n        },\n        JSXAttribute(attrPath) {\n            const prop = parseIdentifier(attrPath.node.name);\n            if (include && !include.has(prop)) {\n                return;\n            }\n            const { value, confident } = getAttributeValue(attrPath);\n            if (confident) {\n                result[prop] = value;\n            } else {\n                onError?.(prop, attrPath);\n            }\n        },\n    });\n\n    return result;\n}\n\n/**\n * Attempt to get the value of a JSX attribute. Returns an object with the\n * properties `confident`, which is false if the value cannot be resolved\n * in the current scope, and `value` which is the value if it can be.\n *\n * If the attribute is empty, then the returned value is `true`, e.g.\n * `<Image eager />` would return `true` for the `eager` attribute.\n *\n * @param nodePath The NodePath of the JSXAttribute\n */\nexport function getAttributeValue<T = unknown>(\n    nodePath: CoreNodePath<JSXAttribute> | TraverseNodePath<JSXAttribute>\n): {\n    confident: boolean;\n    value: T | true;\n} {\n    let valueNode = nodePath.get(`value`);\n    if (Array.isArray(valueNode)) {\n        valueNode = valueNode[0];\n    }\n    if (!valueNode.node) {\n        // empty attributes are truthy\n        return { confident: true, value: true };\n    } else if (valueNode.node.type === `JSXExpressionContainer`) {\n        const expression = valueNode.get(`expression`);\n\n        if (Array.isArray(expression)) {\n            return expression[0]?.evaluate();\n        }\n\n        return expression.evaluate();\n    } else {\n        return valueNode.evaluate();\n    }\n}\n"],"names":["parseIdentifier","identifier","type","name","getAttributeValues","nodePath","onError","include","result","traverse","JSXSpreadAttribute","attrPath","spreadValues","get","evaluate","confident","value","JSXAttribute","prop","node","has","getAttributeValue","valueNode","Array","isArray","expression"],"mappings":";;;;;aASgBA,gBACZC;IAEA,MAAIA,UAAU,CAACC,IAAX,oBAAJ,EAAyC;IACrC,WAAOD,UAAU,CAACE,IAAlB;IACH;;IACD,SAAOH,eAAe,CAACC,UAAU,CAACE,IAAZ,CAAtB;IACH;IAED;;;;;;;;;aAQgBC,mBACZC,UAGAC,SAIAC;IAEA,MAAIC,MAAM,GAA4B,EAAtC;IAEAH,EAAAA,QAAQ,CAACI,QAAT,CAAkB;IACdC,IAAAA,kBAAkB,CAACC,QAAD;IACd,YAAMC,YAAY,GAAGD,QAAQ,CAACE,GAAT,WAAA,EAAyBC,QAAzB,EAArB;;IACA,UAAIF,YAAY,CAACG,SAAjB,EAA4B;IACxBP,QAAAA,MAAM,GAAG,EAAE,GAAGA,MAAL;IAAa,aAAGI,YAAY,CAACI;IAA7B,SAAT;IACH,OAFD,MAEO;IACHV,QAAAA,OAAO,QAAP,YAAAA,OAAO,sBAAA,CAAP;IACH;IACJ,KARa;;IASdW,IAAAA,YAAY,CAACN,QAAD;IACR,YAAMO,IAAI,GAAGlB,eAAe,CAACW,QAAQ,CAACQ,IAAT,CAAchB,IAAf,CAA5B;;IACA,UAAII,OAAO,IAAI,CAACA,OAAO,CAACa,GAAR,CAAYF,IAAZ,CAAhB,EAAmC;IAC/B;IACH;;IACD,YAAM;IAAEF,QAAAA,KAAF;IAASD,QAAAA;IAAT,UAAuBM,iBAAiB,CAACV,QAAD,CAA9C;;IACA,UAAII,SAAJ,EAAe;IACXP,QAAAA,MAAM,CAACU,IAAD,CAAN,GAAeF,KAAf;IACH,OAFD,MAEO;IACHV,QAAAA,OAAO,QAAP,YAAAA,OAAO,CAAGY,IAAH,EAASP,QAAT,CAAP;IACH;IACJ;;IApBa,GAAlB;IAuBA,SAAOH,MAAP;IACH;IAED;;;;;;;;;;;aAUgBa,kBACZhB;IAKA,MAAIiB,SAAS,GAAGjB,QAAQ,CAACQ,GAAT,QAAA,CAAhB;;IACA,MAAIU,KAAK,CAACC,OAAN,CAAcF,SAAd,CAAJ,EAA8B;IAC1BA,IAAAA,SAAS,GAAGA,SAAS,CAAC,CAAD,CAArB;IACH;;IACD,MAAI,CAACA,SAAS,CAACH,IAAf,EAAqB;IACjB;IACA,WAAO;IAAEJ,MAAAA,SAAS,EAAE,IAAb;IAAmBC,MAAAA,KAAK,EAAE;IAA1B,KAAP;IACH,GAHD,MAGO,IAAIM,SAAS,CAACH,IAAV,CAAejB,IAAf,6BAAJ,EAAsD;IACzD,UAAMuB,UAAU,GAAGH,SAAS,CAACT,GAAV,aAAA,CAAnB;;IAEA,QAAIU,KAAK,CAACC,OAAN,CAAcC,UAAd,CAAJ,EAA+B;IAAA;;IAC3B,6BAAOA,UAAU,CAAC,CAAD,CAAjB,qBAAO,aAAeX,QAAf,EAAP;IACH;;IAED,WAAOW,UAAU,CAACX,QAAX,EAAP;IACH,GARM,MAQA;IACH,WAAOQ,SAAS,CAACR,QAAV,EAAP;IACH;IACJ;;;;;;;;;;"}