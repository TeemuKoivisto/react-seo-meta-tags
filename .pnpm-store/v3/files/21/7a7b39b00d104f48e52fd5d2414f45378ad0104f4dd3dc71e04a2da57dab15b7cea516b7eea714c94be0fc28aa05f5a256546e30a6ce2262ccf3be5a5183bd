{"version":3,"file":"inference-metadata.js","names":["getType","value","key","is32BitInteger","includes","looksLikeADate","Date","String","Array","isArray","length","Object","keys","updateValueDescriptorObject","typeInfo","nodeId","operation","metadata","path","push","dprops","forEach","v","descriptor","undefined","updateValueDescriptor","pop","updateValueDescriptorArray","item","updateValueDescriptorRelNodes","listOfNodeIds","delta","nodes","dirty","updateValueDescriptorString","empty","example","typeName","total","first","mergeObjectKeys","dpropsKeysA","dpropsKeysB","otherProps","Set","concat","descriptorsAreEqual","otherDescriptor","types","possibleTypes","otherTypes","childDescriptorsAreEqual","type","array","dpropsKeys","object","every","prop","nodeIds","relatedNode","id","Boolean","relatedNodeList","nodeFields","node","ignoredFields","filter","has","updateTypeMetadata","initialMetadata","disabled","ignored","fieldMap","field","ignore","set","disable","addNode","deleteNode","addNodes","state","isEmpty","hasNodes","typeMetadata","haveEqualFields","otherFieldMap","fields"],"sources":["../../../src/schema/infer/inference-metadata.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-use-before-define */\n/*\n## Incrementally track the structure of nodes with metadata\n\nThis metadata can be later utilized for schema inference\n(via building `exampleValue` or directly)\n\n### Usage example:\n\n```javascript\n  const node1 = { id: '1', foo: 25, bar: 'str' }\n  const node2 = { id: '1', foo: 'conflict' }\n\n  let meta = { ignoredFields: new Set(['id']) }\n  meta = addNode(meta, node1)\n  meta = addNode(meta, node2)\n  console.log(meta.fieldMap)\n  // outputs: {\n  //   foo: {\n  //     int: { total: 1, example: 25 },\n  //     string: { total: 1, example: 'conflict' },\n  //   },\n  //   bar: {\n  //     string: { total: 1, example: 'str' },\n  //   },\n  // }\n\n  const example1 = getExampleObject({ meta, typeName, typeConflictReporter })\n  console.log(example1)\n  // outputs { bar: 'str' }\n  // and reports conflicts discovered\n\n  meta = deleteNode(meta, node2)\n  console.log(meta.fieldMap)\n  // outputs: {\n  //   foo: {\n  //     int: { total: 1, example: 25 },\n  //     string: { total: 0, example: 'conflict' },\n  //   },\n  //   bar: { string: { total: 1, example: 'str' } },\n  // }\n\n  const example2 = getExampleObject({ meta, typeName, typeConflictReporter })\n  // outputs: { foo: 25, bar: 'str' }\n```\n\n`addNode`, `deleteNode`, `getExampleObject` are O(N) where N is the number\nof fields in the node object (including nested fields)\n\n### Caveats\n\n* Conflict tracking for arrays is tricky, i.e.: { a: [5, \"foo\"] } and { a: [5] }, { a: [\"foo\"] }\n  are represented identically in metadata. To workaround it we additionally track first NodeId:\n  { a: { array: { item: { int: { total: 1, first: `1` }, string: { total: 1, first: `1` } }}\n  { a: { array: { item: { int: { total: 1, first: `1` }, string: { total: 1, first: `2` } }}\n  This way we can produce more useful conflict reports\n  (still rare edge cases possible when reporting may be confusing, i.e. when node is deleted)\n*/\n\nimport { isEqual } from \"lodash\"\nimport { is32BitInteger } from \"../../utils/is-32-bit-integer\"\nimport { looksLikeADate } from \"../types/date\"\nimport { Node } from \"../../../index\"\nimport { TypeConflictReporter } from \"./type-conflict-reporter\"\n\nexport interface ITypeInfo {\n  first?: string\n  total: number\n  example?: unknown\n}\n\nexport interface ITypeInfoString extends ITypeInfo {\n  empty: number\n  example: string\n}\n\nexport interface ITypeInfoDate extends ITypeInfo {\n  example: string | Date\n}\n\nexport interface ITypeInfoNumber extends ITypeInfo {\n  example: number\n}\n\nexport interface ITypeInfoBoolean extends ITypeInfo {\n  example: boolean\n}\n\nexport interface ITypeInfoArray extends ITypeInfo {\n  item: IValueDescriptor\n}\n\nexport interface ITypeInfoRelatedNodes extends ITypeInfo {\n  nodes: { [key: string]: number }\n}\n\nexport interface ITypeInfoObject extends ITypeInfo {\n  dprops: {\n    [name: string]: IValueDescriptor\n  }\n}\n\nexport interface IValueDescriptor {\n  int?: ITypeInfoNumber\n  float?: ITypeInfoNumber\n  date?: ITypeInfoDate\n  string?: ITypeInfoString\n  boolean?: ITypeInfoBoolean\n  array?: ITypeInfoArray\n  relatedNode?: ITypeInfoRelatedNodes\n  relatedNodeList?: ITypeInfoRelatedNodes\n  object?: ITypeInfoObject\n}\n\nexport type ValueType = keyof IValueDescriptor\n\nexport interface ITypeMetadata {\n  typeName?: string\n  disabled?: boolean\n  ignored?: boolean\n  dirty?: boolean\n  total?: number\n  ignoredFields?: Set<string>\n  fieldMap?: Record<string, IValueDescriptor>\n  typeConflictReporter?: TypeConflictReporter\n  [key: string]: unknown\n}\n\ntype Operation = \"add\" | \"del\"\n\nconst getType = (value: unknown, key: string): ValueType | \"null\" => {\n  // Staying as close as possible to GraphQL types\n  switch (typeof value) {\n    case `number`:\n      return is32BitInteger(value) ? `int` : `float`\n    case `string`:\n      if (key.includes(`___NODE`)) {\n        return `relatedNode`\n      }\n      return looksLikeADate(value) ? `date` : `string`\n    case `boolean`:\n      return `boolean`\n    case `object`:\n      if (value === null) return `null`\n      if (value instanceof Date) return `date`\n      if (value instanceof String) return `string`\n      if (Array.isArray(value)) {\n        if (value.length === 0) {\n          return `null`\n        }\n        return key.includes(`___NODE`) ? `relatedNodeList` : `array`\n      }\n      if (!Object.keys(value).length) return `null`\n      return `object`\n    default:\n      // bigint, symbol, function, unknown (host objects in IE were typeof \"unknown\", for example)\n      return `null`\n  }\n}\n\nconst updateValueDescriptorObject = (\n  value: Record<string, unknown>,\n  typeInfo: ITypeInfoObject,\n  nodeId: string,\n  operation: Operation,\n  metadata: ITypeMetadata,\n  path: Array<Record<string, unknown>>\n): void => {\n  path.push(value)\n\n  const { dprops = {} } = typeInfo\n  typeInfo.dprops = dprops\n\n  Object.keys(value).forEach(key => {\n    const v = value[key]\n\n    let descriptor = dprops[key]\n    if (descriptor === undefined) {\n      descriptor = {}\n      dprops[key] = descriptor\n    }\n\n    updateValueDescriptor(nodeId, key, v, operation, descriptor, metadata, path)\n  })\n\n  path.pop()\n}\n\nconst updateValueDescriptorArray = (\n  value: Array<unknown>,\n  key: string,\n  typeInfo: ITypeInfoArray,\n  nodeId: string,\n  operation: Operation,\n  metadata: ITypeMetadata,\n  path: Array<Record<string, unknown>>\n): void => {\n  value.forEach(item => {\n    let descriptor = typeInfo.item\n    if (descriptor === undefined) {\n      descriptor = {}\n      typeInfo.item = descriptor\n    }\n\n    updateValueDescriptor(\n      nodeId,\n      key,\n      item,\n      operation,\n      descriptor,\n      metadata,\n      path\n    )\n  })\n}\n\nconst updateValueDescriptorRelNodes = (\n  listOfNodeIds: Array<string>,\n  delta: number,\n  operation: Operation,\n  typeInfo: ITypeInfoRelatedNodes,\n  metadata: ITypeMetadata\n): void => {\n  const { nodes = {} } = typeInfo\n  typeInfo.nodes = nodes\n\n  listOfNodeIds.forEach(nodeId => {\n    nodes[nodeId] = (nodes[nodeId] || 0) + delta\n\n    // Treat any new related node addition or removal as a structural change\n    // FIXME: this will produce false positives as this node can be\n    //  of the same type as another node already in the map (but we don't know it here)\n    if (nodes[nodeId] === 0 || (operation === `add` && nodes[nodeId] === 1)) {\n      metadata.dirty = true\n    }\n  })\n}\n\nconst updateValueDescriptorString = (\n  value: string,\n  delta: number,\n  typeInfo: ITypeInfoString\n): void => {\n  if (value === ``) {\n    const { empty = 0 } = typeInfo\n    typeInfo.empty = empty + delta\n  }\n  typeInfo.example =\n    typeof typeInfo.example !== `undefined` ? typeInfo.example : value\n}\n\nconst updateValueDescriptor = (\n  nodeId: string,\n  key: string,\n  value: unknown,\n  operation: Operation = `add`,\n  descriptor: IValueDescriptor,\n  metadata: ITypeMetadata,\n  path: Array<Record<string, unknown>>\n): void => {\n  // The object may be traversed multiple times from root.\n  // Each time it does it should not revisit the same node twice\n  if (path.includes(value as Record<string, unknown>)) {\n    return\n  }\n\n  const typeName = getType(value, key)\n\n  if (typeName === `null`) {\n    return\n  }\n\n  const delta = operation === `del` ? -1 : 1\n\n  let typeInfo: ITypeInfo | undefined = descriptor[typeName]\n  if (typeInfo === undefined) {\n    // eslint-disable-next-line no-undef\n    typeInfo = (descriptor[typeName] as ITypeInfo) = { total: 0 }\n  }\n  typeInfo.total += delta\n\n  // Keeping track of structural changes\n  // (when value of a new type is added or an existing type has no more values assigned)\n  if (typeInfo.total === 0 || (operation === `add` && typeInfo.total === 1)) {\n    metadata.dirty = true\n  }\n\n  // Keeping track of the first node for this type. Only used for better conflict reporting.\n  // (see Caveats section in the header comments)\n  if (operation === `add`) {\n    if (!typeInfo.first) {\n      typeInfo.first = nodeId\n    }\n  } else if (operation === `del`) {\n    if (typeInfo.first === nodeId || typeInfo.total === 0) {\n      typeInfo.first = undefined\n    }\n  }\n\n  switch (typeName) {\n    case `object`:\n      updateValueDescriptorObject(\n        value as Record<string, unknown>,\n        typeInfo as ITypeInfoObject,\n        nodeId,\n        operation,\n        metadata,\n        path\n      )\n      return\n    case `array`:\n      updateValueDescriptorArray(\n        value as Array<unknown>,\n        key,\n        typeInfo as ITypeInfoArray,\n        nodeId,\n        operation,\n        metadata,\n        path\n      )\n      return\n    case `relatedNode`:\n      updateValueDescriptorRelNodes(\n        [value as string],\n        delta,\n        operation,\n        typeInfo as ITypeInfoRelatedNodes,\n        metadata\n      )\n      return\n    case `relatedNodeList`:\n      updateValueDescriptorRelNodes(\n        value as Array<string>,\n        delta,\n        operation,\n        typeInfo as ITypeInfoRelatedNodes,\n        metadata\n      )\n      return\n    case `string`:\n      updateValueDescriptorString(\n        value as string,\n        delta,\n        typeInfo as ITypeInfoString\n      )\n      return\n  }\n\n  // int, float, boolean, null\n\n  typeInfo.example =\n    typeof typeInfo.example !== `undefined` ? typeInfo.example : value\n}\n\nconst mergeObjectKeys = (\n  dpropsKeysA: Record<string, unknown> = {},\n  dpropsKeysB: Record<string, unknown> = {}\n): Array<string> => {\n  const dprops = Object.keys(dpropsKeysA)\n  const otherProps = Object.keys(dpropsKeysB)\n  return [...new Set(dprops.concat(otherProps))]\n}\n\nconst descriptorsAreEqual = (\n  descriptor?: IValueDescriptor,\n  otherDescriptor?: IValueDescriptor\n): boolean => {\n  const types = possibleTypes(descriptor)\n  const otherTypes = possibleTypes(otherDescriptor)\n\n  const childDescriptorsAreEqual = (type: string): boolean => {\n    switch (type) {\n      case `array`:\n        return descriptorsAreEqual(\n          descriptor?.array?.item,\n          otherDescriptor?.array?.item\n        )\n      case `object`: {\n        const dpropsKeys = mergeObjectKeys(\n          descriptor?.object?.dprops,\n          otherDescriptor?.object?.dprops\n        )\n        return dpropsKeys.every(prop =>\n          descriptorsAreEqual(\n            descriptor?.object?.dprops[prop],\n            otherDescriptor?.object?.dprops[prop]\n          )\n        )\n      }\n      case `relatedNode`: {\n        const nodeIds = mergeObjectKeys(\n          descriptor?.relatedNode?.nodes,\n          otherDescriptor?.relatedNode?.nodes\n        )\n        // Must be present in both descriptors or absent in both\n        // in order to be considered equal\n        return nodeIds.every(\n          id =>\n            Boolean(descriptor?.relatedNode?.nodes[id]) ===\n            Boolean(otherDescriptor?.relatedNode?.nodes[id])\n        )\n      }\n      case `relatedNodeList`: {\n        const nodeIds = mergeObjectKeys(\n          descriptor?.relatedNodeList?.nodes,\n          otherDescriptor?.relatedNodeList?.nodes\n        )\n        return nodeIds.every(\n          id =>\n            Boolean(descriptor?.relatedNodeList?.nodes[id]) ===\n            Boolean(otherDescriptor?.relatedNodeList?.nodes[id])\n        )\n      }\n      default:\n        return true\n    }\n  }\n\n  // Equal when all possible types are equal (including conflicts)\n  return isEqual(types, otherTypes) && types.every(childDescriptorsAreEqual)\n}\n\nconst nodeFields = (node: Node, ignoredFields = new Set()): Array<string> =>\n  Object.keys(node).filter(key => !ignoredFields.has(key))\n\nconst updateTypeMetadata = (\n  metadata = initialMetadata(),\n  operation: Operation,\n  node: Node\n): ITypeMetadata => {\n  if (metadata.disabled) {\n    return metadata\n  }\n  metadata.total = (metadata.total || 0) + (operation === `add` ? 1 : -1)\n  if (metadata.ignored) {\n    return metadata\n  }\n  const { ignoredFields, fieldMap = {} } = metadata\n\n  nodeFields(node, ignoredFields).forEach(field => {\n    let descriptor = fieldMap[field]\n    if (descriptor === undefined) {\n      descriptor = {}\n      fieldMap[field] = descriptor\n    }\n\n    updateValueDescriptor(\n      node.id,\n      field,\n      node[field],\n      operation,\n      descriptor,\n      metadata,\n      []\n    )\n  })\n  metadata.fieldMap = fieldMap\n  return metadata\n}\n\nconst ignore = (metadata = initialMetadata(), set = true): ITypeMetadata => {\n  metadata.ignored = set\n  metadata.fieldMap = {}\n  return metadata\n}\n\nconst disable = (metadata = initialMetadata(), set = true): ITypeMetadata => {\n  metadata.disabled = set\n  return metadata\n}\n\nconst addNode = (metadata: ITypeMetadata, node: Node): ITypeMetadata =>\n  updateTypeMetadata(metadata, `add`, node)\n\nconst deleteNode = (metadata: ITypeMetadata, node: Node): ITypeMetadata =>\n  updateTypeMetadata(metadata, `del`, node)\n\nconst addNodes = (\n  metadata = initialMetadata(),\n  nodes: Iterable<Node>\n): ITypeMetadata => {\n  let state = metadata\n  for (const node of nodes) {\n    state = addNode(state, node)\n  }\n  return state\n}\n\nconst possibleTypes = (descriptor: IValueDescriptor = {}): Array<ValueType> =>\n  Object.keys(descriptor).filter(\n    type => descriptor[type].total > 0\n  ) as Array<ValueType>\n\nconst isEmpty = ({ fieldMap }): boolean =>\n  Object.keys(fieldMap).every(\n    field => possibleTypes(fieldMap[field]).length === 0\n  )\n\n// Even empty type may still have nodes\nconst hasNodes = (typeMetadata: ITypeMetadata): boolean =>\n  (typeMetadata.total ?? 0) > 0\n\nconst haveEqualFields = (\n  { fieldMap = {} } = {},\n  { fieldMap: otherFieldMap = {} } = {}\n): boolean => {\n  const fields = mergeObjectKeys(fieldMap, otherFieldMap)\n  return fields.every(field =>\n    descriptorsAreEqual(fieldMap[field], otherFieldMap[field])\n  )\n}\n\nconst initialMetadata = (state?: Record<string, unknown>): ITypeMetadata => {\n  return {\n    typeName: undefined,\n    disabled: false,\n    ignored: false,\n    dirty: false,\n    total: 0,\n    ignoredFields: undefined,\n    fieldMap: {},\n    ...state,\n  }\n}\n\nexport {\n  addNode,\n  addNodes,\n  deleteNode,\n  ignore,\n  disable,\n  isEmpty,\n  hasNodes,\n  haveEqualFields,\n  initialMetadata,\n}\n"],"mappings":"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"}