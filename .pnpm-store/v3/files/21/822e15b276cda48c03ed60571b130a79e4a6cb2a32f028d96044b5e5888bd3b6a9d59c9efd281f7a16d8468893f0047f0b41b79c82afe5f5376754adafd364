{"version":3,"file":"run-fast-filters.js","names":["createFilterCacheKey","typeNames","filter","filterStep","comparator","paths","push","path","type","q","nestedQuery","query","join","applyFastFilters","filters","nodeTypeNames","filtersCache","sortFields","resolvedFields","nodesPerValueArrs","getBucketsForFilters","length","sort","a","b","pop","intersectNodesByCounter","result","every","filterCacheKey","getBucketsForQueryFilter","collectBucketForElemMatch","undefined","filterPath","value","filterValue","has","ensureIndexByQuery","nodesPerValue","getNodesFromCacheByValue","targetValue","f","ensureIndexByElemMatch","nodesByValue","runFastFiltersAndSort","args","queryArgs","limit","skip","stats","convertAndApplyFastFilters","sortedResult","sortNodes","totalCount","entries","slice","nodeObjects","map","nodeIds","getNode","id","GatsbyIterable","filterFields","prefixResolvedFields","createDbQueriesFromObject","prepareQueryArgs","forEach","filterStats","filterToStats","comparatorPath","comparatorsUsed","set","get","uniqueFilterPaths","add","totalNonSingleFilters","ensureEmptyFilterCache","fields","filterCache","cache","meta","orderedByCounter","totalIndexHits","totalSiftHits","concat","nodes","getSortFieldIdentifierKeys","sortFns","field","v","getGatsbyNodePartial","sortOrder","order","toLowerCase","sortField","uniqueSorts"],"sources":["../../../src/datastore/in-memory/run-fast-filters.ts"],"sourcesContent":["import _ from \"lodash\"\nimport {\n  DbQuery,\n  IDbQueryQuery,\n  IDbQueryElemMatch,\n  IInputQuery,\n  FilterValueNullable,\n  createDbQueriesFromObject,\n  prefixResolvedFields,\n  prepareQueryArgs,\n} from \"../common/query\"\nimport {\n  FilterOp,\n  FilterCacheKey,\n  FiltersCache,\n  ensureEmptyFilterCache,\n  ensureIndexByQuery,\n  ensureIndexByElemMatch,\n  getNodesFromCacheByValue,\n  intersectNodesByCounter,\n  IFilterCache,\n  IGatsbyNodePartial,\n  getSortFieldIdentifierKeys,\n  getGatsbyNodePartial,\n} from \"./indexing\"\nimport { IGraphQLRunnerStats } from \"../../query/types\"\nimport { IRunQueryArgs, IQueryResult } from \"../types\"\nimport { GatsbyIterable } from \"../common/iterable\"\nimport { getNode } from \"../\"\n\nexport interface IRunFilterArg extends IRunQueryArgs {\n  filtersCache: FiltersCache\n}\n\ntype ISortParameters =\n  | {\n      fields: Array<string>\n      order: Array<boolean | \"asc\" | \"desc\" | \"ASC\" | \"DESC\">\n    }\n  | undefined\n\n/**\n * Creates a key for one filterCache inside FiltersCache\n */\nfunction createFilterCacheKey(\n  typeNames: Array<string>,\n  filter: DbQuery | null\n): FilterCacheKey {\n  // Note: while `elemMatch` is a special case, in the key it's just `elemMatch`\n  // (This function is future proof for elemMatch support, won't receive it yet)\n  let filterStep = filter\n  let comparator = ``\n  const paths: Array<string> = []\n  while (filterStep) {\n    paths.push(...filterStep.path)\n    if (filterStep.type === `elemMatch`) {\n      const q: IDbQueryElemMatch = filterStep\n      filterStep = q.nestedQuery\n      // Make distinction between filtering `a.elemMatch.b.eq` and `a.b.eq`\n      // In practice this is unlikely to be an issue, but it might\n      paths.push(`elemMatch`)\n    } else {\n      const q: IDbQueryQuery = filterStep\n      comparator = q.query.comparator\n      break\n    }\n  }\n\n  // Note: the separators (`,` and `/`) are arbitrary but must be different\n  return typeNames.join(`,`) + `/` + paths.join(`,`) + `/` + comparator\n}\n\n/**\n * Given the path of a set of filters, return the sets of nodes that pass the\n * filter.\n * Only nodes of given node types will be considered\n * A fast index is created if one doesn't exist yet so cold call is slower.\n *\n * Note: Not a public API. Exported for tests.\n */\nexport function applyFastFilters(\n  filters: Array<DbQuery>,\n  nodeTypeNames: Array<string>,\n  filtersCache: FiltersCache,\n  sortFields: Array<string>,\n  resolvedFields: any\n): Array<IGatsbyNodePartial> | null {\n  if (!filtersCache) {\n    // If no filter cache is passed on, explicitly don't use one\n    return null\n  }\n\n  const nodesPerValueArrs = getBucketsForFilters(\n    filters,\n    nodeTypeNames,\n    filtersCache,\n    sortFields,\n    resolvedFields\n  )\n\n  if (!nodesPerValueArrs) {\n    return null\n  }\n\n  if (nodesPerValueArrs.length === 0) {\n    return []\n  } else {\n    // Put smallest last (we'll pop it)\n    nodesPerValueArrs.sort((a, b) => b.length - a.length)\n\n    // All elements of nodesPerValueArrs should be sorted by counter and deduped\n    // So if there's only one bucket in this list the next loop is skipped\n\n    while (nodesPerValueArrs.length > 1) {\n      // TS limitation: cannot guard against .pop(), so we must double cast\n      const a = nodesPerValueArrs.pop() as unknown as Array<IGatsbyNodePartial>\n      const b = nodesPerValueArrs.pop() as unknown as Array<IGatsbyNodePartial>\n      nodesPerValueArrs.push(intersectNodesByCounter(a, b))\n    }\n\n    const result = nodesPerValueArrs[0]\n\n    if (result.length === 0) {\n      // Intersection came up empty. Not one node appeared in every bucket.\n      return null\n    }\n\n    return result\n  }\n}\n\n/**\n * If this returns undefined it means at least one cache was not found\n */\nfunction getBucketsForFilters(\n  filters: Array<DbQuery>,\n  nodeTypeNames: Array<string>,\n  filtersCache: FiltersCache,\n  sortFields: Array<string>,\n  resolvedFields: any\n): Array<Array<IGatsbyNodePartial>> | undefined {\n  const nodesPerValueArrs: Array<Array<IGatsbyNodePartial>> = []\n\n  // Fail fast while trying to create and get the value-cache for each path\n  const every = filters.every(filter => {\n    const filterCacheKey = createFilterCacheKey(nodeTypeNames, filter)\n    if (filter.type === `query`) {\n      // (Let TS warn us if a new query type gets added)\n      const q: IDbQueryQuery = filter\n      return getBucketsForQueryFilter(\n        filterCacheKey,\n        q,\n        nodeTypeNames,\n        filtersCache,\n        nodesPerValueArrs,\n        sortFields,\n        resolvedFields\n      )\n    } else {\n      // (Let TS warn us if a new query type gets added)\n      const q: IDbQueryElemMatch = filter\n      return collectBucketForElemMatch(\n        filterCacheKey,\n        q,\n        nodeTypeNames,\n        filtersCache,\n        nodesPerValueArrs,\n        sortFields,\n        resolvedFields\n      )\n    }\n  })\n\n  if (every) {\n    return nodesPerValueArrs\n  }\n\n  // \"failed at least one\"\n  return undefined\n}\n\n/**\n * Fetch all buckets for given query filter. That means it's not elemMatch.\n * Returns `false` if it found none.\n */\nfunction getBucketsForQueryFilter(\n  filterCacheKey: FilterCacheKey,\n  filter: IDbQueryQuery,\n  nodeTypeNames: Array<string>,\n  filtersCache: FiltersCache,\n  nodesPerValueArrs: Array<Array<IGatsbyNodePartial>>,\n  sortFields: Array<string>,\n  resolvedFields: any\n): boolean {\n  const {\n    path: filterPath,\n    query: { comparator, value: filterValue },\n  } = filter\n\n  if (!filtersCache.has(filterCacheKey)) {\n    // indexFields = sortFields\n    ensureIndexByQuery(\n      comparator as FilterOp,\n      filterCacheKey,\n      filterPath,\n      nodeTypeNames,\n      filtersCache,\n      sortFields,\n      resolvedFields\n    )\n  }\n\n  const nodesPerValue = getNodesFromCacheByValue(\n    filterCacheKey,\n    filterValue as FilterValueNullable,\n    filtersCache,\n    false\n  )\n\n  if (!nodesPerValue) {\n    return false\n  }\n\n  // In all other cases this must be a non-empty arr because the indexing\n  // mechanism does not create an array unless there's a IGatsbyNode for it\n  nodesPerValueArrs.push(nodesPerValue)\n\n  return true\n}\n\n/**\n * Matching node arrs are put in given array by reference\n */\nfunction collectBucketForElemMatch(\n  filterCacheKey: FilterCacheKey,\n  filter: IDbQueryElemMatch,\n  nodeTypeNames: Array<string>,\n  filtersCache: FiltersCache,\n  nodesPerValueArrs: Array<Array<IGatsbyNodePartial>>,\n  sortFields: Array<string>,\n  resolvedFields: any\n): boolean {\n  // Get comparator and target value for this elemMatch\n  let comparator: FilterOp = `$eq` // (Must be overridden but TS requires init)\n  let targetValue: FilterValueNullable = null\n  let f: DbQuery = filter\n  while (f) {\n    if (f.type === `elemMatch`) {\n      const q: IDbQueryElemMatch = f\n      f = q.nestedQuery\n    } else {\n      const q: IDbQueryQuery = f\n      comparator = q.query.comparator as FilterOp\n      targetValue = q.query.value as FilterValueNullable\n      break\n    }\n  }\n  if (!filtersCache.has(filterCacheKey)) {\n    ensureIndexByElemMatch(\n      comparator,\n      filterCacheKey,\n      filter,\n      nodeTypeNames,\n      filtersCache,\n      sortFields,\n      resolvedFields\n    )\n  }\n\n  const nodesByValue = getNodesFromCacheByValue(\n    filterCacheKey,\n    targetValue,\n    filtersCache,\n    true\n  )\n\n  if (!nodesByValue) {\n    return false\n  }\n\n  // In all other cases this must be a non-empty arr because the indexing\n  // mechanism does not create an array unless there's a IGatsbyNode for it\n  nodesPerValueArrs.push(nodesByValue)\n\n  return true\n}\n\n/**\n * Filters and sorts a list of nodes using mongodb-like syntax.\n *\n * @param args raw graphql query filter/sort as an object\n * @property {{filter?: Object, sort?: Object, skip?: number, limit?: number} | undefined} args.queryArgs\n * @property {FiltersCache} args.filtersCache A cache of indexes where you can\n *   look up Nodes grouped by a FilterCacheKey, which yields a Map which holds\n *   an arr of Nodes for the value that the filter is trying to query against.\n *   This object lives in query/query-runner.js and is passed down runQuery.\n * @returns Collection of results. Collection will be sliced by `skip` and `limit`\n */\nexport function runFastFiltersAndSort(args: IRunFilterArg): IQueryResult {\n  const {\n    queryArgs: { filter, sort, limit, skip = 0 } = {},\n    resolvedFields = {},\n    nodeTypeNames,\n    filtersCache,\n    stats,\n  } = args\n\n  const result = convertAndApplyFastFilters(\n    filter,\n    nodeTypeNames,\n    filtersCache,\n    resolvedFields,\n    stats,\n    sort\n  )\n\n  const sortedResult = sortNodes(result, sort, resolvedFields, stats)\n  const totalCount = async (): Promise<number> => sortedResult.length\n\n  const entries =\n    skip || limit\n      ? sortedResult.slice(skip, limit ? skip + (limit ?? 0) : undefined)\n      : sortedResult\n\n  const nodeObjects = entries.map(nodeIds => getNode(nodeIds.id)!)\n  return { entries: new GatsbyIterable(nodeObjects), totalCount }\n}\n\n/**\n * Return a collection of results.\n */\nfunction convertAndApplyFastFilters(\n  filterFields: IInputQuery | undefined,\n  nodeTypeNames: Array<string>,\n  filtersCache: FiltersCache,\n  resolvedFields: Record<string, any>,\n  stats: IGraphQLRunnerStats,\n  sort: ISortParameters\n): Array<IGatsbyNodePartial> {\n  const filters = filterFields\n    ? prefixResolvedFields(\n        createDbQueriesFromObject(prepareQueryArgs(filterFields)),\n        resolvedFields\n      )\n    : []\n\n  if (stats) {\n    filters.forEach(filter => {\n      const filterStats = filterToStats(filter)\n      const comparatorPath = filterStats.comparatorPath.join(`.`)\n      stats.comparatorsUsed.set(\n        comparatorPath,\n        (stats.comparatorsUsed.get(comparatorPath) || 0) + 1\n      )\n      stats.uniqueFilterPaths.add(filterStats.filterPath.join(`.`))\n    })\n    if (filters.length > 1) {\n      stats.totalNonSingleFilters++\n    }\n  }\n\n  if (filters.length === 0) {\n    const filterCacheKey = createFilterCacheKey(nodeTypeNames, null)\n    if (!filtersCache.has(filterCacheKey)) {\n      ensureEmptyFilterCache(\n        filterCacheKey,\n        nodeTypeNames,\n        filtersCache,\n        sort?.fields || [],\n        resolvedFields\n      )\n    }\n\n    // If there's a filter, there (now) must be an entry for this cache key\n    const filterCache = filtersCache.get(filterCacheKey) as IFilterCache\n    // If there is no filter then the ensureCache step will populate this:\n    const cache = filterCache.meta.orderedByCounter as Array<IGatsbyNodePartial>\n\n    return cache.slice(0)\n  }\n\n  const result = applyFastFilters(\n    filters,\n    nodeTypeNames,\n    filtersCache,\n    sort?.fields || [],\n    resolvedFields\n  )\n\n  if (result) {\n    if (stats) {\n      stats.totalIndexHits++\n    }\n    return result\n  }\n\n  if (stats) {\n    // to mean, \"empty results\"\n    stats.totalSiftHits++\n  }\n\n  return []\n}\n\nfunction filterToStats(\n  filter: DbQuery,\n  filterPath: Array<string> = [],\n  comparatorPath: Array<string> = []\n): {\n  filterPath: Array<string>\n  comparatorPath: Array<string>\n} {\n  if (filter.type === `elemMatch`) {\n    return filterToStats(\n      filter.nestedQuery,\n      filterPath.concat(filter.path),\n      comparatorPath.concat([`elemMatch`])\n    )\n  } else {\n    return {\n      filterPath: filterPath.concat(filter.path),\n      comparatorPath: comparatorPath.concat(filter.query.comparator),\n    }\n  }\n}\n\n/**\n * Given a list of filtered nodes and sorting parameters, sort the nodes\n * Returns same reference as input, sorted inline\n */\nfunction sortNodes(\n  nodes: Array<IGatsbyNodePartial>,\n  sort: ISortParameters,\n  resolvedFields: any,\n  stats: IGraphQLRunnerStats\n): Array<IGatsbyNodePartial> {\n  if (!sort || sort.fields?.length === 0 || !nodes || nodes.length === 0) {\n    return nodes\n  }\n\n  // create functions that return the item to compare on\n  const sortFields = getSortFieldIdentifierKeys(sort.fields, resolvedFields)\n  const sortFns = sortFields.map(\n    field =>\n      (v): ((any) => any) =>\n        field in v\n          ? v[field]\n          : getGatsbyNodePartial(v, sort.fields, resolvedFields)[field]\n  )\n  const sortOrder = sort.order.map(order =>\n    typeof order === `boolean` ? order : order.toLowerCase()\n  ) as Array<boolean | \"asc\" | \"desc\">\n\n  if (stats) {\n    sortFields.forEach(sortField => {\n      stats.uniqueSorts.add(sortField)\n    })\n  }\n\n  return _.orderBy(nodes, sortFns, sortOrder)\n}\n"],"mappings":"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"}