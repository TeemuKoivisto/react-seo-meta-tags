{"version":3,"file":"index.js","names":["report","require","ObjectTypeComposer","hasNodes","getExampleObject","addNodeInterface","addInferredFields","getDataStore","addInferredTypes","schemaComposer","typeConflictReporter","typeMapping","inferenceMetadata","parentSpan","typeMap","typesWithNodes","Object","keys","filter","typeName","typeNames","putFileFirst","noNodeInterfaceTypes","typesToInfer","forEach","typeComposer","has","getOTC","runInfer","hasExtension","getExtension","hasInterface","push","create","setExtension","length","warn","panic","map","addInferredType","getTypeName","firstNode","node","iterateNodesByType","internal","owner","exampleValue","index","indexOf","slice","module","exports"],"sources":["../../../src/schema/infer/index.js"],"sourcesContent":["const report = require(`gatsby-cli/lib/reporter`)\nconst { ObjectTypeComposer } = require(`graphql-compose`)\nconst { hasNodes } = require(`./inference-metadata`)\nconst { getExampleObject } = require(`./build-example-data`)\nconst { addNodeInterface } = require(`../types/node-interface`)\nconst { addInferredFields } = require(`./add-inferred-fields`)\nconst { getDataStore } = require(`../../datastore`)\n\nconst addInferredTypes = ({\n  schemaComposer,\n  typeConflictReporter,\n  typeMapping,\n  inferenceMetadata,\n  parentSpan,\n}) => {\n  // XXX(freiksenet): Won't be needed after plugins set typedefs\n  // Infer File first so all the links to it would work\n  const { typeMap } = inferenceMetadata\n  const typesWithNodes = Object.keys(typeMap).filter(typeName =>\n    hasNodes(typeMap[typeName])\n  )\n  const typeNames = putFileFirst(typesWithNodes)\n  const noNodeInterfaceTypes = []\n\n  const typesToInfer = []\n\n  typeNames.forEach(typeName => {\n    let typeComposer\n    if (schemaComposer.has(typeName)) {\n      typeComposer = schemaComposer.getOTC(typeName)\n      const runInfer = typeComposer.hasExtension(`infer`)\n        ? typeComposer.getExtension(`infer`)\n        : true\n      if (runInfer) {\n        if (!typeComposer.hasInterface(`Node`)) {\n          noNodeInterfaceTypes.push(typeName)\n        }\n        typesToInfer.push(typeComposer)\n      }\n    } else {\n      typeComposer = ObjectTypeComposer.create(typeName, schemaComposer)\n      addNodeInterface({ schemaComposer, typeComposer })\n      typeComposer.setExtension(`createdFrom`, `inference`)\n      typesToInfer.push(typeComposer)\n    }\n  })\n\n  if (noNodeInterfaceTypes.length > 0) {\n    noNodeInterfaceTypes.forEach(typeName => {\n      report.warn(\n        `Type \\`${typeName}\\` declared in \\`createTypes\\` looks like a node, ` +\n          `but doesn't implement a \\`Node\\` interface. It's likely that you should ` +\n          `add the \\`Node\\` interface to your type def:\\n\\n` +\n          `\\`type ${typeName} implements Node { ... }\\`\\n\\n` +\n          `If you know that you don't want it to be a node (which would mean no ` +\n          `root queries to retrieve it), you can explicitly disable inference ` +\n          `for it:\\n\\n` +\n          `\\`type ${typeName} @dontInfer { ... }\\``\n      )\n    })\n    report.panic(`Building schema failed`)\n  }\n\n  return typesToInfer.map(typeComposer =>\n    addInferredType({\n      schemaComposer,\n      typeComposer,\n      typeConflictReporter,\n      typeMapping,\n      parentSpan,\n      inferenceMetadata,\n    })\n  )\n}\n\nconst addInferredType = ({\n  schemaComposer,\n  typeComposer,\n  typeConflictReporter,\n  typeMapping,\n  inferenceMetadata = {},\n  parentSpan,\n}) => {\n  const typeName = typeComposer.getTypeName()\n  // TODO: Move this to where the type is created once we can get\n  // node type owner information directly from store\n  if (\n    typeComposer.getExtension(`createdFrom`) === `inference` &&\n    hasNodes(inferenceMetadata.typeMap[typeName])\n  ) {\n    let firstNode\n    for (const node of getDataStore().iterateNodesByType(typeName)) {\n      firstNode = node\n      break\n    }\n    if (firstNode) {\n      typeComposer.setExtension(`plugin`, firstNode.internal.owner)\n    }\n  }\n\n  const exampleValue = getExampleObject({\n    ...inferenceMetadata.typeMap[typeName],\n    typeName,\n    typeConflictReporter,\n  })\n\n  addInferredFields({\n    schemaComposer,\n    typeComposer,\n    exampleValue,\n    typeMapping,\n    parentSpan,\n  })\n  return typeComposer\n}\n\nconst putFileFirst = typeNames => {\n  const index = typeNames.indexOf(`File`)\n  if (index !== -1) {\n    return [`File`, ...typeNames.slice(0, index), ...typeNames.slice(index + 1)]\n  } else {\n    return typeNames\n  }\n}\n\nmodule.exports = {\n  addInferredType,\n  addInferredTypes,\n}\n"],"mappings":"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"}