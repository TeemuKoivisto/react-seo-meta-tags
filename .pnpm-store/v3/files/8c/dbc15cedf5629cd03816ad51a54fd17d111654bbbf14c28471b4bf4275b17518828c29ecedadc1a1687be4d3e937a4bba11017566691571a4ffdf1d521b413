{"version":3,"file":"add-inferred-fields.js","names":["_","require","ObjectTypeComposer","GraphQLList","invariant","report","getDataStore","addInferredFields","schemaComposer","typeComposer","exampleValue","typeMapping","parentSpan","config","getInferenceConfig","defaults","shouldAddFields","addInferredFieldsImpl","exampleObject","prefix","getTypeName","unsanitizedFieldPath","deprecatedNodeKeys","size","reportOnce","Array","from","join","module","exports","fields","Object","keys","forEach","unsanitizedKey","key","createFieldName","push","fieldsByKey","groupBy","field","possibleFields","selectedField","length","resolveMultipleFields","possibleFieldsNames","map","warn","fieldConfig","getFieldConfig","hasField","addFields","setFieldExtension","Set","selector","arrays","value","isArray","hasMapping","getFieldConfigFromMapping","includes","getFieldConfigFromFieldNameConvention","multiple","add","getSimpleFieldConfig","pop","split","extensions","proxy","type","nodeField","find","canonicalField","sortBy","mapping","path","link","by","foreignKey","replace","linkedTypesSet","linkedValues","linkedNodes","iterateNodes","node","get","has","internal","id","getNode","linkedTypes","typeName","sort","getOrCreateUTC","utc","setTypes","getOTC","setResolveType","is32BitInteger","isDate","dateformat","isFile","fileByRelativePath","Date","String","fieldTypeComposer","getFieldTC","lists","fieldType","getFieldType","ofType","createTypeName","create","setExtension","getExtension","addDerivedType","derivedTypeName","inferenceConfig","Error","suffix","slice","upperFirst","NON_ALPHA_NUMERIC_EXPR","RegExp","fieldName","replaced","match","char","index","hasExtension"],"sources":["../../../src/schema/infer/add-inferred-fields.js"],"sourcesContent":["const _ = require(`lodash`)\nconst { ObjectTypeComposer } = require(`graphql-compose`)\nconst { GraphQLList } = require(`graphql`)\nconst invariant = require(`invariant`)\nconst report = require(`gatsby-cli/lib/reporter`)\n\nimport { isFile } from \"./is-file\"\nimport { isDate } from \"../types/date\"\nimport { addDerivedType } from \"../types/derived-types\"\nimport { reportOnce } from \"../../utils/report-once\"\nimport { is32BitInteger } from \"../../utils/is-32-bit-integer\"\nconst { getDataStore } = require(`../../datastore`)\n\nconst addInferredFields = ({\n  schemaComposer,\n  typeComposer,\n  exampleValue,\n  typeMapping,\n  parentSpan,\n}) => {\n  const config = getInferenceConfig({\n    typeComposer,\n    defaults: {\n      shouldAddFields: true,\n    },\n  })\n  addInferredFieldsImpl({\n    schemaComposer,\n    typeComposer,\n    exampleObject: exampleValue,\n    prefix: typeComposer.getTypeName(),\n    unsanitizedFieldPath: [typeComposer.getTypeName()],\n    typeMapping,\n    config,\n  })\n\n  if (deprecatedNodeKeys.size > 0) {\n    reportOnce(\n      `The ___NODE convention is deprecated. Please use the @link directive instead.\\nType: ${typeComposer.getTypeName()}, Keys: ${Array.from(\n        deprecatedNodeKeys\n      ).join(`, `)}\\nMigration: https://gatsby.dev/node-convention-deprecation`,\n      `verbose`\n    )\n  }\n}\n\nmodule.exports = {\n  addInferredFields,\n}\n\nconst addInferredFieldsImpl = ({\n  schemaComposer,\n  typeComposer,\n  exampleObject,\n  typeMapping,\n  prefix,\n  unsanitizedFieldPath,\n  config,\n}) => {\n  const fields = []\n  Object.keys(exampleObject).forEach(unsanitizedKey => {\n    const key = createFieldName(unsanitizedKey)\n    fields.push({\n      key,\n      unsanitizedKey,\n      exampleValue: exampleObject[unsanitizedKey],\n    })\n  })\n\n  const fieldsByKey = _.groupBy(fields, field => field.key)\n\n  Object.keys(fieldsByKey).forEach(key => {\n    const possibleFields = fieldsByKey[key]\n    let selectedField\n    if (possibleFields.length > 1) {\n      const field = resolveMultipleFields(possibleFields)\n      const possibleFieldsNames = possibleFields\n        .map(field => `\\`${field.unsanitizedKey}\\``)\n        .join(`, `)\n      report.warn(\n        `Multiple node fields resolve to the same GraphQL field \\`${prefix}.${field.key}\\` - [${possibleFieldsNames}]. Gatsby will use \\`${field.unsanitizedKey}\\`.`\n      )\n      selectedField = field\n    } else {\n      selectedField = possibleFields[0]\n    }\n\n    const fieldConfig = getFieldConfig({\n      ...selectedField,\n      schemaComposer,\n      typeComposer,\n      prefix,\n      unsanitizedFieldPath,\n      typeMapping,\n      config,\n    })\n\n    if (!fieldConfig) return\n\n    if (!typeComposer.hasField(key)) {\n      if (config.shouldAddFields) {\n        typeComposer.addFields({ [key]: fieldConfig })\n        typeComposer.setFieldExtension(key, `createdFrom`, `inference`)\n      }\n    }\n  })\n\n  return typeComposer\n}\n\nconst deprecatedNodeKeys = new Set()\n\nconst getFieldConfig = ({\n  schemaComposer,\n  typeComposer,\n  prefix,\n  exampleValue,\n  key,\n  unsanitizedKey,\n  unsanitizedFieldPath,\n  typeMapping,\n  config,\n}) => {\n  const selector = `${prefix}.${key}`\n  unsanitizedFieldPath.push(unsanitizedKey)\n\n  let arrays = 0\n  let value = exampleValue\n  while (Array.isArray(value)) {\n    value = value[0]\n    arrays++\n  }\n\n  let fieldConfig\n  if (hasMapping(typeMapping, selector)) {\n    // TODO: Use `prefix` instead of `selector` in hasMapping and getFromMapping?\n    // i.e. does the config contain sanitized field names?\n    fieldConfig = getFieldConfigFromMapping({ typeMapping, selector })\n  } else if (unsanitizedKey.includes(`___NODE`)) {\n    // TODO(v5): Remove ability to use foreign keys like this (e.g. author___NODE___contact___email)\n    // and recommend using schema customization instead\n\n    fieldConfig = getFieldConfigFromFieldNameConvention({\n      schemaComposer,\n      value: exampleValue,\n      key: unsanitizedKey,\n    })\n    arrays = arrays + (value.multiple ? 1 : 0)\n\n    deprecatedNodeKeys.add(unsanitizedKey)\n  } else {\n    fieldConfig = getSimpleFieldConfig({\n      schemaComposer,\n      typeComposer,\n      key,\n      value,\n      selector,\n      unsanitizedFieldPath,\n      typeMapping,\n      config,\n      arrays,\n    })\n  }\n\n  unsanitizedFieldPath.pop()\n  if (!fieldConfig) return null\n\n  // Proxy resolver to unsanitized fieldName in case it contained invalid characters\n  if (key !== unsanitizedKey.split(`___NODE`)[0]) {\n    fieldConfig = {\n      ...fieldConfig,\n      extensions: {\n        ...(fieldConfig.extensions || {}),\n        proxy: { from: unsanitizedKey },\n      },\n    }\n  }\n\n  while (arrays > 0) {\n    fieldConfig = { ...fieldConfig, type: [fieldConfig.type] }\n    arrays--\n  }\n\n  return fieldConfig\n}\n\nconst resolveMultipleFields = possibleFields => {\n  const nodeField = possibleFields.find(field =>\n    field.unsanitizedKey.includes(`___NODE`)\n  )\n  if (nodeField) {\n    return nodeField\n  }\n\n  const canonicalField = possibleFields.find(\n    field => field.unsanitizedKey === field.key\n  )\n  if (canonicalField) {\n    return canonicalField\n  }\n\n  return _.sortBy(possibleFields, field => field.unsanitizedKey)[0]\n}\n\n// XXX(freiksenet): removing this as it's a breaking change\n// Deeper nested levels should be inferred as JSON.\n// const MAX_DEPTH = 5\n\nconst hasMapping = (mapping, selector) =>\n  mapping && Object.keys(mapping).includes(selector)\n\nconst getFieldConfigFromMapping = ({ typeMapping, selector }) => {\n  const [type, ...path] = typeMapping[selector].split(`.`)\n  return {\n    type,\n    extensions: {\n      link: { by: path.join(`.`) || `id` },\n    },\n  }\n}\n\n// probably should be in example value\nconst getFieldConfigFromFieldNameConvention = ({\n  schemaComposer,\n  value,\n  key,\n}) => {\n  const path = key.split(`___NODE___`)[1]\n  // Allow linking by nested fields, e.g. `author___NODE___contact___email`\n  const foreignKey = path && path.replace(/___/g, `.`)\n  const linkedTypesSet = new Set()\n\n  if (foreignKey) {\n    const linkedValues = new Set(value.linkedNodes)\n    getDataStore()\n      .iterateNodes()\n      .forEach(node => {\n        const value = _.get(node, foreignKey)\n        if (linkedValues.has(value)) {\n          linkedTypesSet.add(node.internal.type)\n        }\n      })\n  } else {\n    value.linkedNodes.forEach(id => {\n      const node = getDataStore().getNode(id)\n      if (node) {\n        linkedTypesSet.add(node.internal.type)\n      }\n    })\n  }\n\n  const linkedTypes = [...linkedTypesSet]\n\n  invariant(\n    linkedTypes.length,\n    `Encountered an error trying to infer a GraphQL type for: \\`${key}\\`. ` +\n      `There is no corresponding node with the \\`id\\` field matching: \"${value.linkedNodes}\".`\n  )\n\n  let type\n  // If the field value is an array that links to more than one type,\n  // create a GraphQLUnionType. Note that we don't support the case where\n  // scalar fields link to different types. Similarly, an array of objects\n  // with foreign-key fields will produce union types if those foreign-key\n  // fields are arrays, but not if they are scalars. See the tests for an example.\n  if (linkedTypes.length > 1) {\n    const typeName = linkedTypes.sort().join(``) + `Union`\n    type = schemaComposer.getOrCreateUTC(typeName, utc => {\n      utc.setTypes(linkedTypes.map(typeName => schemaComposer.getOTC(typeName)))\n      utc.setResolveType(node => node.internal.type)\n    })\n  } else {\n    type = linkedTypes[0]\n  }\n\n  return {\n    type,\n    extensions: {\n      link: { by: foreignKey || `id`, from: key },\n    },\n  }\n}\n\nconst getSimpleFieldConfig = ({\n  schemaComposer,\n  typeComposer,\n  key,\n  value,\n  selector,\n  unsanitizedFieldPath,\n  typeMapping,\n  config,\n  arrays,\n}) => {\n  switch (typeof value) {\n    case `boolean`:\n      return { type: `Boolean` }\n    case `number`:\n      return { type: is32BitInteger(value) ? `Int` : `Float` }\n    case `string`:\n      if (isDate(value)) {\n        return { type: `Date`, extensions: { dateformat: {} } }\n      }\n      if (isFile(unsanitizedFieldPath, value)) {\n        // NOTE: For arrays of files, where not every path references\n        // a File node in the db, it is semi-random if the field is\n        // inferred as File or String, since the exampleValue only has\n        // the first entry (which could point to an existing file or not).\n        return { type: `File`, extensions: { fileByRelativePath: {} } }\n      }\n      return { type: `String` }\n    case `object`:\n      if (value instanceof Date) {\n        return { type: `Date`, extensions: { dateformat: {} } }\n      }\n      if (value instanceof String) {\n        return { type: `String` }\n      }\n      if (value /* && depth < MAX_DEPTH*/) {\n        let fieldTypeComposer\n        if (typeComposer.hasField(key)) {\n          fieldTypeComposer = typeComposer.getFieldTC(key)\n          // If we have an object as a field value, but the field type is\n          // explicitly defined as something other than an ObjectType\n          // we can bail early.\n          if (!(fieldTypeComposer instanceof ObjectTypeComposer)) return null\n          // If the array depth of the field value and of the explicitly\n          // defined field type don't match we can also bail early.\n          let lists = 0\n          let fieldType = typeComposer.getFieldType(key)\n          while (fieldType.ofType) {\n            if (fieldType instanceof GraphQLList) lists++\n            fieldType = fieldType.ofType\n          }\n          if (lists !== arrays) return null\n        } else {\n          // When the field type has not been explicitly defined, we\n          // don't need to continue in case of @dontInfer\n          if (!config.shouldAddFields) return null\n\n          const typeName = createTypeName(selector)\n          if (schemaComposer.has(typeName)) {\n            // Type could have been already created via schema customization\n            fieldTypeComposer = schemaComposer.getOTC(typeName)\n          } else {\n            fieldTypeComposer = ObjectTypeComposer.create(\n              typeName,\n              schemaComposer\n            )\n            fieldTypeComposer.setExtension(`createdFrom`, `inference`)\n            fieldTypeComposer.setExtension(\n              `plugin`,\n              typeComposer.getExtension(`plugin`)\n            )\n            addDerivedType({\n              typeComposer,\n              derivedTypeName: fieldTypeComposer.getTypeName(),\n            })\n          }\n        }\n\n        // Inference config options are either explicitly defined on a type\n        // with directive/extension, or inherited from the parent type.\n        const inferenceConfig = getInferenceConfig({\n          typeComposer: fieldTypeComposer,\n          defaults: config,\n        })\n\n        return {\n          type: addInferredFieldsImpl({\n            schemaComposer,\n            typeComposer: fieldTypeComposer,\n            exampleObject: value,\n            typeMapping,\n            prefix: selector,\n            unsanitizedFieldPath,\n            config: inferenceConfig,\n          }),\n        }\n      }\n  }\n  throw new Error(`Can't determine type for \"${value}\" in \\`${selector}\\`.`)\n}\n\nconst createTypeName = selector => {\n  const keys = selector.split(`.`)\n  const suffix = keys.slice(1).map(_.upperFirst).join(``)\n  return `${keys[0]}${suffix}`\n}\n\nconst NON_ALPHA_NUMERIC_EXPR = new RegExp(`[^a-zA-Z0-9_]`, `g`)\n\n/**\n * GraphQL field names must be a string and cannot contain anything other than\n * alphanumeric characters and `_`. They also can't start with `__` which is\n * reserved for internal fields (`___foo` doesn't work either).\n */\nconst createFieldName = key => {\n  // Check if the key is really a string otherwise GraphQL will throw.\n  invariant(\n    typeof key === `string`,\n    `GraphQL field name (key) is not a string: \\`${key}\\`.`\n  )\n\n  const fieldName = key.split(`___NODE`)[0]\n  const replaced = fieldName.replace(NON_ALPHA_NUMERIC_EXPR, `_`)\n\n  // key is invalid; normalize with leading underscore and rest with x\n  if (replaced.match(/^__/)) {\n    return replaced.replace(/_/g, (char, index) => (index === 0 ? `_` : `x`))\n  }\n\n  // key is invalid (starts with numeric); normalize with leading underscore\n  if (replaced.match(/^[0-9]/)) {\n    return `_` + replaced\n  }\n\n  return replaced\n}\n\nconst getInferenceConfig = ({ typeComposer, defaults }) => {\n  return {\n    shouldAddFields: typeComposer.hasExtension(`infer`)\n      ? typeComposer.getExtension(`infer`)\n      : defaults.shouldAddFields,\n  }\n}\n"],"mappings":"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"}