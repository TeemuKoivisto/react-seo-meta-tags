{"version":3,"file":"type-defs.js","names":["parse","Kind","GraphQLASTNodeKind","require","inferExtensionName","dontInferExtensionName","report","isASTDocument","typeOrTypeDef","kind","DOCUMENT","parseTypeDef","error","reportParsingError","message","source","locations","length","codeFrameColumns","frame","body","start","linesAbove","linesBelow","panic","typesWithoutInference","typeNames","definitions","forEach","def","directives","directive","name","value","push","isGatsbyType","config","extensions","module","exports"],"sources":["../../../src/schema/types/type-defs.js"],"sourcesContent":["const { parse, Kind: GraphQLASTNodeKind } = require(`graphql`)\nimport { isGatsbyType } from \"./type-builders\"\nconst { inferExtensionName, dontInferExtensionName } = require(`../extensions`)\nconst report = require(`gatsby-cli/lib/reporter`)\n\nconst isASTDocument = typeOrTypeDef =>\n  typeof typeOrTypeDef === `object` &&\n  typeOrTypeDef.kind &&\n  GraphQLASTNodeKind.DOCUMENT === typeOrTypeDef.kind\n\n/**\n * Parses type definition represented as an SDL string into an AST Document.\n * Type definitions of other formats (other than SDL) are returned as is\n */\nconst parseTypeDef = typeOrTypeDef => {\n  if (typeof typeOrTypeDef === `string`) {\n    try {\n      return parse(typeOrTypeDef)\n    } catch (error) {\n      reportParsingError(error)\n    }\n  }\n  return typeOrTypeDef\n}\n\nconst reportParsingError = error => {\n  const { message, source, locations } = error\n\n  if (source && locations && locations.length) {\n    const { codeFrameColumns } = require(`@babel/code-frame`)\n\n    const frame = codeFrameColumns(\n      source.body,\n      { start: locations[0] },\n      { linesAbove: 5, linesBelow: 5 }\n    )\n    report.panic(\n      `Encountered an error parsing the provided GraphQL type definitions:\\n` +\n        message +\n        `\\n\\n` +\n        frame +\n        `\\n`\n    )\n  } else {\n    throw error\n  }\n}\n\n/**\n * Given a type definition, collects type names that should skip the inference process\n */\nconst typesWithoutInference = (typeNames = [], typeOrTypeDef) => {\n  if (typeof typeOrTypeDef === `string`) {\n    typeOrTypeDef = parseTypeDef(typeOrTypeDef)\n  }\n  if (isASTDocument(typeOrTypeDef)) {\n    typeOrTypeDef.definitions.forEach(def => {\n      if (!def.directives) return\n\n      def.directives.forEach(directive => {\n        if (directive.name.value === dontInferExtensionName && def.name.value) {\n          typeNames.push(def.name.value)\n        }\n      })\n    })\n    return typeNames\n  }\n  if (isGatsbyType(typeOrTypeDef) && typeOrTypeDef.config) {\n    const { extensions = {}, name } = typeOrTypeDef.config\n    if (\n      name &&\n      (extensions[dontInferExtensionName] ||\n        extensions[inferExtensionName] === false)\n    ) {\n      typeNames.push(name)\n    }\n  }\n  return typeNames\n}\n\nmodule.exports = {\n  parseTypeDef,\n  reportParsingError,\n  typesWithoutInference,\n  isASTDocument,\n}\n"],"mappings":";;AACA;AADA,MAAM;EAAEA,KAAK;EAAEC,IAAI,EAAEC;AAAmB,CAAC,GAAGC,OAAO,CAAE,SAAQ,CAAC;AAE9D,MAAM;EAAEC,kBAAkB;EAAEC;AAAuB,CAAC,GAAGF,OAAO,CAAE,eAAc,CAAC;AAC/E,MAAMG,MAAM,GAAGH,OAAO,CAAE,yBAAwB,CAAC;AAEjD,MAAMI,aAAa,GAAGC,aAAa,IACjC,OAAOA,aAAa,KAAM,QAAO,IACjCA,aAAa,CAACC,IAAI,IAClBP,kBAAkB,CAACQ,QAAQ,KAAKF,aAAa,CAACC,IAAI;;AAEpD;AACA;AACA;AACA;AACA,MAAME,YAAY,GAAGH,aAAa,IAAI;EACpC,IAAI,OAAOA,aAAa,KAAM,QAAO,EAAE;IACrC,IAAI;MACF,OAAOR,KAAK,CAACQ,aAAa,CAAC;IAC7B,CAAC,CAAC,OAAOI,KAAK,EAAE;MACdC,kBAAkB,CAACD,KAAK,CAAC;IAC3B;EACF;EACA,OAAOJ,aAAa;AACtB,CAAC;AAED,MAAMK,kBAAkB,GAAGD,KAAK,IAAI;EAClC,MAAM;IAAEE,OAAO;IAAEC,MAAM;IAAEC;EAAU,CAAC,GAAGJ,KAAK;EAE5C,IAAIG,MAAM,IAAIC,SAAS,IAAIA,SAAS,CAACC,MAAM,EAAE;IAC3C,MAAM;MAAEC;IAAiB,CAAC,GAAGf,OAAO,CAAE,mBAAkB,CAAC;IAEzD,MAAMgB,KAAK,GAAGD,gBAAgB,CAC5BH,MAAM,CAACK,IAAI,EACX;MAAEC,KAAK,EAAEL,SAAS,CAAC,CAAC;IAAE,CAAC,EACvB;MAAEM,UAAU,EAAE,CAAC;MAAEC,UAAU,EAAE;IAAE,CAAC,CACjC;IACDjB,MAAM,CAACkB,KAAK,CACT,uEAAsE,GACrEV,OAAO,GACN,MAAK,GACNK,KAAK,GACJ,IAAG,CACP;EACH,CAAC,MAAM;IACL,MAAMP,KAAK;EACb;AACF,CAAC;;AAED;AACA;AACA;AACA,MAAMa,qBAAqB,GAAG,CAACC,SAAS,GAAG,EAAE,EAAElB,aAAa,KAAK;EAC/D,IAAI,OAAOA,aAAa,KAAM,QAAO,EAAE;IACrCA,aAAa,GAAGG,YAAY,CAACH,aAAa,CAAC;EAC7C;EACA,IAAID,aAAa,CAACC,aAAa,CAAC,EAAE;IAChCA,aAAa,CAACmB,WAAW,CAACC,OAAO,CAACC,GAAG,IAAI;MACvC,IAAI,CAACA,GAAG,CAACC,UAAU,EAAE;MAErBD,GAAG,CAACC,UAAU,CAACF,OAAO,CAACG,SAAS,IAAI;QAClC,IAAIA,SAAS,CAACC,IAAI,CAACC,KAAK,KAAK5B,sBAAsB,IAAIwB,GAAG,CAACG,IAAI,CAACC,KAAK,EAAE;UACrEP,SAAS,CAACQ,IAAI,CAACL,GAAG,CAACG,IAAI,CAACC,KAAK,CAAC;QAChC;MACF,CAAC,CAAC;IACJ,CAAC,CAAC;IACF,OAAOP,SAAS;EAClB;EACA,IAAI,IAAAS,0BAAY,EAAC3B,aAAa,CAAC,IAAIA,aAAa,CAAC4B,MAAM,EAAE;IACvD,MAAM;MAAEC,UAAU,GAAG,CAAC,CAAC;MAAEL;IAAK,CAAC,GAAGxB,aAAa,CAAC4B,MAAM;IACtD,IACEJ,IAAI,KACHK,UAAU,CAAChC,sBAAsB,CAAC,IACjCgC,UAAU,CAACjC,kBAAkB,CAAC,KAAK,KAAK,CAAC,EAC3C;MACAsB,SAAS,CAACQ,IAAI,CAACF,IAAI,CAAC;IACtB;EACF;EACA,OAAON,SAAS;AAClB,CAAC;AAEDY,MAAM,CAACC,OAAO,GAAG;EACf5B,YAAY;EACZE,kBAAkB;EAClBY,qBAAqB;EACrBlB;AACF,CAAC"}