{"version":3,"file":"index.js","names":["NODE_MUTATION_BATCH_SIZE","NODE_MUTATION_BATCH_TIMEOUT","FILE_CHANGE_AGGREGATION_TIMEOUT","waitingStates","predictableActionArguments","id","initial","context","nodeMutationBatch","runningBatch","states","idle","always","cond","ctx","length","target","sourceFilesDirty","Boolean","on","ADD_NODE_MUTATION","actions","SOURCE_FILE_CHANGED","aggregatingFileChanges","after","undefined","internal","batchingNodeMutations","committingBatch","entry","assign","invoke","src","onDone","rebuild","type","data","waitingMachine","createMachine","waitingActions","services","waitingServices"],"sources":["../../../src/state-machines/waiting/index.ts"],"sourcesContent":["import { MachineConfig, assign, createMachine } from \"xstate\"\nimport { IWaitingContext } from \"./types\"\nimport { waitingActions } from \"./actions\"\nimport { waitingServices } from \"./services\"\n\nconst NODE_MUTATION_BATCH_SIZE = 100\nconst NODE_MUTATION_BATCH_TIMEOUT = 500\nconst FILE_CHANGE_AGGREGATION_TIMEOUT = 200\n\nexport type WaitingResult = Pick<IWaitingContext, \"nodeMutationBatch\">\n\n/**\n * This idle state also handles batching of node mutations and running of\n * mutations when we first start it\n */\nexport const waitingStates: MachineConfig<IWaitingContext, any, any> = {\n  predictableActionArguments: true,\n  id: `waitingMachine`,\n  initial: `idle`,\n  context: {\n    nodeMutationBatch: [],\n    runningBatch: [],\n  },\n  states: {\n    idle: {\n      always: [\n        {\n          // If we already have queued node mutations, move\n          // immediately to batching\n          cond: (ctx): boolean => !!ctx.nodeMutationBatch.length,\n          target: `batchingNodeMutations`,\n        },\n        {\n          // If source files are dirty upon entering this state,\n          // move immediately to aggregatingFileChanges to force re-compilation\n          // See https://github.com/gatsbyjs/gatsby/issues/27609\n          target: `aggregatingFileChanges`,\n          cond: ({ sourceFilesDirty }): boolean => Boolean(sourceFilesDirty),\n        },\n      ],\n      on: {\n        ADD_NODE_MUTATION: {\n          actions: `addNodeMutation`,\n          target: `batchingNodeMutations`,\n        },\n        // We only listen for this when idling because if we receive it at any\n        // other point we're already going to create pages etc\n        SOURCE_FILE_CHANGED: {\n          target: `aggregatingFileChanges`,\n        },\n      },\n    },\n    aggregatingFileChanges: {\n      // Sigh. This is because webpack doesn't expose the Watchpack\n      // aggregated file invalidation events. If we compile immediately,\n      // we won't pick up the changed files\n      after: {\n        // The aggregation timeout\n        [FILE_CHANGE_AGGREGATION_TIMEOUT]: {\n          actions: `extractQueries`,\n          target: `idle`,\n        },\n      },\n      on: {\n        ADD_NODE_MUTATION: {\n          actions: `addNodeMutation`,\n          target: `batchingNodeMutations`,\n        },\n        SOURCE_FILE_CHANGED: {\n          target: undefined,\n          // External self-transition reset the timer\n          internal: false,\n        },\n      },\n    },\n    batchingNodeMutations: {\n      // Check if the batch is already full on entry\n      always: {\n        cond: (ctx): boolean =>\n          ctx.nodeMutationBatch.length >= NODE_MUTATION_BATCH_SIZE,\n        target: `committingBatch`,\n      },\n      on: {\n        // More mutations added to batch\n        ADD_NODE_MUTATION: [\n          // You know the score: only run the first matching transition\n          {\n            // If this fills the batch then commit it\n            actions: `addNodeMutation`,\n            cond: (ctx): boolean =>\n              ctx.nodeMutationBatch.length >= NODE_MUTATION_BATCH_SIZE,\n            target: `committingBatch`,\n          },\n          {\n            // ...otherwise just add it to the batch\n            actions: `addNodeMutation`,\n          },\n        ],\n      },\n      after: {\n        // Time's up\n        [NODE_MUTATION_BATCH_TIMEOUT]: `committingBatch`,\n      },\n    },\n    committingBatch: {\n      entry: assign<IWaitingContext>(({ nodeMutationBatch }) => {\n        return {\n          nodeMutationBatch: [],\n          runningBatch: nodeMutationBatch,\n        }\n      }),\n      on: {\n        // While we're running the batch we will also run new actions, as these may be cascades\n        ADD_NODE_MUTATION: {\n          actions: `callApi`,\n        },\n      },\n      invoke: {\n        src: `runMutationBatch`,\n        // When we're done, clear the running batch ready for next time\n        onDone: {\n          actions: assign<IWaitingContext, any>({\n            runningBatch: [],\n          }),\n          target: `rebuild`,\n        },\n      },\n    },\n    rebuild: {\n      type: `final`,\n      // This is returned to the parent. The batch includes\n      // any mutations that arrived while we were running the other batch\n      data: ({ nodeMutationBatch }): WaitingResult => {\n        return { nodeMutationBatch }\n      },\n    },\n  },\n}\n\nexport const waitingMachine = createMachine(waitingStates, {\n  actions: waitingActions,\n  services: waitingServices,\n})\n"],"mappings":"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"}