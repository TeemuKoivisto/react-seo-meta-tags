{"version":3,"file":"utils.js","names":["toNodeTypeNames","schema","gqlTypeName","gqlType","getType","isObjectType","isAbstractType","possibleTypes","getPossibleTypes","filter","type","getInterfaces","some","iface","name","map","isObjectOrInterfaceTypeComposer","ObjectTypeComposer","InterfaceTypeComposer","fieldNeedToResolve","typeComposer","schemaComposer","fieldName","nodeTypeNames","possibleTCs","getAnyTC","tc","getFieldExtension","fieldPathNeedToResolve","selector","schemaCustomization","composer","store","getState","Error","selectors","split","isInterfaceType","i","length","nextType","getNamedType","getFields","getResolvedFields","node","typeName","internal","resolvedNodes","resolvedNodesCache","get","id","pathObjectToPathString","input","path","currentValue","leaf","undefined","isPlainObject","entries","Object","key","value","push","join","maybeConvertSortInputObjectToSortPath","args","sort","Array","isArray","fields","order","every","item","toLowerCase","sorts","modifiedSort"],"sources":["../../src/schema/utils.ts"],"sourcesContent":["import {\n  isAbstractType,\n  getNamedType,\n  GraphQLSchema,\n  isObjectType,\n  isInterfaceType,\n  GraphQLObjectType,\n  GraphQLInterfaceType,\n  GraphQLUnionType,\n} from \"graphql\"\nimport {\n  InterfaceTypeComposer,\n  NamedTypeComposer,\n  ObjectTypeComposer,\n  SchemaComposer,\n} from \"graphql-compose\"\nimport isPlainObject from \"lodash/isPlainObject\"\n\nimport type { IGatsbyNodePartial } from \"../datastore/in-memory/indexing\"\nimport { IGatsbyNode } from \"../internal\"\nimport { store } from \"../redux\"\n\nexport const toNodeTypeNames = (\n  schema: GraphQLSchema,\n  gqlTypeName:\n    | string\n    | GraphQLObjectType\n    | GraphQLInterfaceType\n    | GraphQLUnionType\n): Array<string> => {\n  const gqlType =\n    typeof gqlTypeName === `string` ? schema.getType(gqlTypeName) : gqlTypeName\n\n  if (!gqlType || !(isObjectType(gqlType) || isAbstractType(gqlType))) {\n    return []\n  }\n\n  const possibleTypes = isAbstractType(gqlType)\n    ? schema.getPossibleTypes(gqlType)\n    : [gqlType]\n\n  return possibleTypes\n    .filter(type => type.getInterfaces().some(iface => iface.name === `Node`))\n    .map(type => type.name)\n}\n\nexport function isObjectOrInterfaceTypeComposer(\n  type: NamedTypeComposer<any>\n): type is ObjectTypeComposer | InterfaceTypeComposer {\n  return (\n    type instanceof ObjectTypeComposer || type instanceof InterfaceTypeComposer\n  )\n}\n\nexport const fieldNeedToResolve = ({\n  schema,\n  gqlType,\n  typeComposer,\n  schemaComposer,\n  fieldName,\n}: {\n  schema: GraphQLSchema\n  gqlType: GraphQLObjectType | GraphQLInterfaceType\n  typeComposer: ObjectTypeComposer<any> | InterfaceTypeComposer<any>\n  schemaComposer: SchemaComposer<any>\n  fieldName: string\n}): boolean => {\n  const nodeTypeNames = toNodeTypeNames(schema, gqlType)\n\n  const possibleTCs: Array<ObjectTypeComposer | InterfaceTypeComposer> = [\n    typeComposer,\n    ...nodeTypeNames\n      .map(name => schemaComposer.getAnyTC(name))\n      .filter(isObjectOrInterfaceTypeComposer),\n  ]\n\n  for (const tc of possibleTCs) {\n    if (tc.getFieldExtension(fieldName, `needsResolve`) || false) {\n      return true\n    }\n  }\n\n  return false\n}\n\nexport const fieldPathNeedToResolve = ({\n  selector,\n  type,\n}: {\n  selector: string\n  type: string | GraphQLObjectType | GraphQLInterfaceType\n}): boolean => {\n  const {\n    schema,\n    schemaCustomization: { composer: schemaComposer },\n  } = store.getState()\n\n  if (!schemaComposer) {\n    throw new Error(`Schema composer isn't set yet`)\n  }\n\n  const selectors =\n    typeof selector === `string` ? selector.split(`.`) : selector\n\n  let gqlType = typeof type === `string` ? schema.getType(type) : type\n\n  if (!gqlType || !(isObjectType(gqlType) || isInterfaceType(gqlType))) {\n    return false\n  }\n\n  for (let i = 0; i < selectors.length; i++) {\n    const fieldName = selectors[i]\n    const typeComposer = schemaComposer.getAnyTC(gqlType.name)\n\n    if (!isObjectOrInterfaceTypeComposer(typeComposer)) {\n      return false\n    }\n\n    if (\n      fieldNeedToResolve({\n        schema,\n        gqlType,\n        typeComposer,\n        schemaComposer,\n        fieldName,\n      })\n    ) {\n      return true\n    }\n\n    const nextType = getNamedType(gqlType.getFields()[fieldName].type)\n    if (!nextType || !(isObjectType(nextType) || isInterfaceType(nextType))) {\n      return false\n    } else {\n      gqlType = nextType\n    }\n  }\n\n  return false\n}\n\nexport function getResolvedFields(\n  node: IGatsbyNode | IGatsbyNodePartial\n): undefined | Record<string, any> {\n  const typeName = node.internal.type\n  const resolvedNodes = store.getState().resolvedNodesCache.get(typeName)\n  return resolvedNodes?.get(node.id)\n}\n\ntype NestedPathStructure = INestedPathStructureNode | true | \"ASC\" | \"DESC\"\n\nexport interface INestedPathStructureNode {\n  [key: string]: NestedPathStructure\n}\n\nexport function pathObjectToPathString(input: INestedPathStructureNode): {\n  path: string\n  leaf: any\n} {\n  const path: Array<string> = []\n  let currentValue: NestedPathStructure | undefined = input\n  let leaf: any = undefined\n  while (currentValue) {\n    if (isPlainObject(currentValue)) {\n      const entries = Object.entries(currentValue)\n      if (entries.length !== 1) {\n        throw new Error(`Invalid field arg`)\n      }\n      for (const [key, value] of entries) {\n        path.push(key)\n        currentValue = value\n      }\n    } else {\n      leaf = currentValue\n      currentValue = undefined\n    }\n  }\n\n  return {\n    path: path.join(`.`),\n    leaf,\n  }\n}\n\nexport function maybeConvertSortInputObjectToSortPath(args: any): any {\n  if (!args.sort) {\n    return args\n  }\n\n  if (_CFLAGS_.GATSBY_MAJOR === `5`) {\n    // check if it's already in expected format\n    if (\n      Array.isArray(args.sort?.fields) &&\n      Array.isArray(args.sort?.order) &&\n      args.sort.order.every(\n        item =>\n          typeof item === `string` &&\n          (item.toLowerCase() === `asc` || item.toLowerCase() === `desc`)\n      )\n    ) {\n      return args\n    }\n\n    let sorts = args.sort\n\n    if (!Array.isArray(sorts)) {\n      sorts = [sorts]\n    }\n\n    const modifiedSort: any = {\n      fields: [],\n      order: [],\n    }\n\n    for (const sort of sorts) {\n      const { path, leaf } = pathObjectToPathString(sort)\n      modifiedSort.fields.push(path)\n      modifiedSort.order.push(leaf)\n    }\n\n    return {\n      ...args,\n      sort: modifiedSort,\n    }\n  }\n\n  return args\n}\n"],"mappings":"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"}