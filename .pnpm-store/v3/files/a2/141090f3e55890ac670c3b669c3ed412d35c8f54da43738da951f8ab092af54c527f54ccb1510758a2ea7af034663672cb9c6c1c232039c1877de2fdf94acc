{"version":3,"file":"index.modern.mjs","sources":["../src/lib/history.js","../src/lib/hooks-create-context.js","../src/lib/hooks-use-context.js","../src/lib/redirect.js","../src/lib/utils.js","../src/lib/link.js","../src/lib/error-boundary.js","../src/lib/location-provider.js","../src/lib/location.js","../src/lib/location-server.js","../src/lib/match.js","../src/lib/focus-handler.js","../src/lib/router.js","../src/hooks/use-location.js","../src/hooks/use-navigate.js","../src/hooks/use-params.js","../src/hooks/use-match.js"],"sourcesContent":["const getLocation = source => {\n  const { search, hash, href, origin, protocol, host, hostname, port } =\n    source.location\n  let { pathname } = source.location\n\n  if (!pathname && href && canUseDOM) {\n    const url = new URL(href)\n    pathname = url.pathname\n  }\n\n  return {\n    pathname: encodeURI(decodeURI(pathname)),\n    search,\n    hash,\n    href,\n    origin,\n    protocol,\n    host,\n    hostname,\n    port,\n    state: source.history.state,\n    key: (source.history.state && source.history.state.key) || \"initial\",\n  }\n}\n\nconst createHistory = (source, options) => {\n  let listeners = []\n  let location = getLocation(source)\n  let transitioning = false\n  let resolveTransition = () => {}\n\n  return {\n    get location() {\n      return location\n    },\n\n    get transitioning() {\n      return transitioning\n    },\n\n    _onTransitionComplete() {\n      transitioning = false\n      resolveTransition()\n    },\n\n    listen(listener) {\n      listeners.push(listener)\n\n      const popstateListener = () => {\n        location = getLocation(source)\n        listener({ location, action: \"POP\" })\n      }\n\n      source.addEventListener(\"popstate\", popstateListener)\n\n      return () => {\n        source.removeEventListener(\"popstate\", popstateListener)\n        listeners = listeners.filter(fn => fn !== listener)\n      }\n    },\n\n    navigate(to, { state, replace = false } = {}) {\n      if (typeof to === \"number\") {\n        source.history.go(to)\n      } else {\n        state = { ...state, key: Date.now() + \"\" }\n        // try...catch iOS Safari limits to 100 pushState calls\n        try {\n          if (transitioning || replace) {\n            source.history.replaceState(state, null, to)\n          } else {\n            source.history.pushState(state, null, to)\n          }\n        } catch (e) {\n          source.location[replace ? \"replace\" : \"assign\"](to)\n        }\n      }\n\n      location = getLocation(source)\n      transitioning = true\n      const transition = new Promise(res => (resolveTransition = res))\n      listeners.forEach(listener => listener({ location, action: \"PUSH\" }))\n      return transition\n    },\n  }\n}\n\n// Stores history entries in memory for testing or other platforms like Native\nconst createMemorySource = (initialPath = \"/\") => {\n  const searchIndex = initialPath.indexOf(\"?\")\n  const initialLocation = {\n    pathname:\n      searchIndex > -1 ? initialPath.substr(0, searchIndex) : initialPath,\n    search: searchIndex > -1 ? initialPath.substr(searchIndex) : \"\",\n  }\n  let index = 0\n  const stack = [initialLocation]\n  const states = [null]\n\n  return {\n    get location() {\n      return stack[index]\n    },\n    addEventListener(name, fn) {},\n    removeEventListener(name, fn) {},\n    history: {\n      get entries() {\n        return stack\n      },\n      get index() {\n        return index\n      },\n      get state() {\n        return states[index]\n      },\n      pushState(state, _, uri) {\n        const [pathname, search = \"\"] = uri.split(\"?\")\n        index++\n        stack.push({ pathname, search: search.length ? `?${search}` : search })\n        states.push(state)\n      },\n      replaceState(state, _, uri) {\n        const [pathname, search = \"\"] = uri.split(\"?\")\n        stack[index] = { pathname, search }\n        states[index] = state\n      },\n      go(to) {\n        const newIndex = index + to\n\n        if (newIndex < 0 || newIndex > states.length - 1) {\n          return\n        }\n\n        index = newIndex\n      },\n    },\n  }\n}\n\n// global history - uses window.history as the source if available, otherwise a\n// memory history\nconst canUseDOM = !!(\n  typeof window !== \"undefined\" &&\n  window.document &&\n  window.document.createElement\n)\nconst getSource = () => {\n  return canUseDOM ? window : createMemorySource()\n}\n\nconst globalSource = getSource()\nconst globalHistory = createHistory(globalSource)\nconst { navigate } = globalHistory\n\nexport { globalHistory, navigate, createHistory, createMemorySource }\n","/* eslint-disable no-undef */\n\nimport React from \"react\"\n\nconst createServerContext = (name, defaultValue = null) => {\n  if (!globalThis.__SERVER_CONTEXT) {\n    globalThis.__SERVER_CONTEXT = {}\n  }\n\n  if (!globalThis.__SERVER_CONTEXT[name]) {\n    globalThis.__SERVER_CONTEXT[name] = React.createServerContext(\n      name,\n      defaultValue\n    )\n  }\n\n  return globalThis.__SERVER_CONTEXT[name]\n}\n\nfunction createServerOrClientContext(name, defaultValue) {\n  if (React.createServerContext) {\n    return createServerContext(name, defaultValue)\n  }\n\n  return React.createContext(defaultValue)\n}\n\nexport const BaseContext = createServerOrClientContext(\"Base\", {\n  baseuri: \"/\",\n  basepath: \"/\",\n})\nexport const LocationContext = createServerOrClientContext(\"Location\")\n","import * as React from \"react\"\nimport { BaseContext, LocationContext } from \"./hooks-create-context\"\n\nexport const useBaseContext = () => React.useContext(BaseContext)\nexport const useLocationContext = () => React.useContext(LocationContext)\n","import * as React from \"react\"\nimport PropTypes from \"prop-types\"\nimport { navigate } from \"./history\"\nimport { resolve, insertParams } from \"./utils\"\nimport { useBaseContext, useLocationContext } from \"./hooks-use-context\"\n\nfunction RedirectRequest(uri) {\n  this.uri = uri\n}\n\nconst isRedirect = o => o instanceof RedirectRequest\n\nconst redirectTo = to => {\n  throw new RedirectRequest(to)\n}\n\nfunction RedirectImpl(props) {\n  const { to, replace = true, state, noThrow, baseuri } = props\n\n  React.useEffect(() => {\n    Promise.resolve().then(() => {\n      const resolvedTo = resolve(to, baseuri)\n      navigate(insertParams(resolvedTo, props), { replace, state })\n    })\n  }, [])\n\n  const resolvedTo = resolve(to, baseuri)\n\n  if (!noThrow) {\n    redirectTo(insertParams(resolvedTo, props))\n  }\n\n  return null\n}\n\nconst Redirect = props => {\n  const locationContext = useLocationContext()\n  const { baseuri } = useBaseContext()\n\n  return <RedirectImpl {...locationContext} baseuri={baseuri} {...props} />\n}\n\nRedirect.propTypes = {\n  from: PropTypes.string,\n  to: PropTypes.string.isRequired,\n}\n\nexport { Redirect, isRedirect, redirectTo }\n","import * as React from \"react\"\nimport invariant from \"invariant\"\nimport { Redirect } from \"./redirect\"\n\n/**\n * startsWith(string, search) - Check if `string` starts with `search`\n */\nconst startsWith = (string, search) => {\n  return string.substr(0, search.length) === search\n}\n\n/**\n * pick(routes, uri)\n\n  Ranks and picks the best route to match. Each segment gets the highest\n  amount of points, then the type of segment gets an additional amount of\n  points where\n\n      static > dynamic > splat > root\n\n  This way we don't have to worry about the order of our routes, let the\n  computers do it.\n\n  A route looks like this\n\n      { path, default, value }\n\n  And a returned match looks like:\n\n      { route, params, uri }\n\n  I know, I should use TypeScript not comments for these types. \n */\nconst pick = (routes, uri) => {\n  let match\n  let default_\n\n  const [uriPathname] = uri.split(\"?\")\n  const uriSegments = segmentize(uriPathname)\n  const isRootUri = uriSegments[0] === \"\"\n  const ranked = rankRoutes(routes)\n\n  for (let i = 0, l = ranked.length; i < l; i++) {\n    let missed = false\n    const route = ranked[i].route\n\n    if (route.default) {\n      default_ = {\n        route,\n        params: {},\n        uri,\n      }\n      continue\n    }\n\n    const routeSegments = segmentize(route.path)\n    const params = {}\n    const max = Math.max(uriSegments.length, routeSegments.length)\n    let index = 0\n\n    for (; index < max; index++) {\n      const routeSegment = routeSegments[index]\n      const uriSegment = uriSegments[index]\n\n      if (isSplat(routeSegment)) {\n        // Hit a splat, just grab the rest, and return a match\n        // uri:   /files/documents/work\n        // route: /files/*\n        const param = routeSegment.slice(1) || \"*\"\n        params[param] = uriSegments\n          .slice(index)\n          .map(decodeURIComponent)\n          .join(\"/\")\n        break\n      }\n\n      if (uriSegment === undefined) {\n        // URI is shorter than the route, no match\n        // uri:   /users\n        // route: /users/:userId\n        missed = true\n        break\n      }\n\n      const dynamicMatch = paramRe.exec(routeSegment)\n\n      if (dynamicMatch && !isRootUri) {\n        const matchIsNotReserved = reservedNames.indexOf(dynamicMatch[1]) === -1\n        invariant(\n          matchIsNotReserved,\n          `<Router> dynamic segment \"${dynamicMatch[1]}\" is a reserved name. Please use a different name in path \"${route.path}\".`\n        )\n        const value = decodeURIComponent(uriSegment)\n        params[dynamicMatch[1]] = value\n      } else if (routeSegment !== uriSegment) {\n        // Current segments don't match, not dynamic, not splat, so no match\n        // uri:   /users/123/settings\n        // route: /users/:id/profile\n        missed = true\n        break\n      }\n    }\n\n    if (!missed) {\n      match = {\n        route,\n        params,\n        uri: \"/\" + uriSegments.slice(0, index).join(\"/\"),\n      }\n      break\n    }\n  }\n\n  return match || default_ || null\n}\n\n/**\n * match(path, uri) - Matches just one path to a uri, also lol\n */\nconst match = (path, uri) => pick([{ path }], uri)\n\n/**\n * resolve(to, basepath)\n\n  Resolves URIs as though every path is a directory, no files.  Relative URIs\n  in the browser can feel awkward because not only can you be \"in a directory\"\n  you can be \"at a file\", too. For example\n\n      browserSpecResolve('foo', '/bar/') => /bar/foo\n      browserSpecResolve('foo', '/bar') => /foo\n\n  But on the command line of a file system, it's not as complicated, you can't\n  `cd` from a file, only directories.  This way, links have to know less about\n  their current path. To go deeper you can do this:\n\n      <Link to=\"deeper\"/>\n      // instead of\n      <Link to=`{${props.uri}/deeper}`/>\n\n  Just like `cd`, if you want to go deeper from the command line, you do this:\n\n      cd deeper\n      // not\n      cd $(pwd)/deeper\n\n  By treating every path as a directory, linking to relative paths should\n  require less contextual information and (fingers crossed) be more intuitive.\n */\nconst resolve = (to, base) => {\n  // /foo/bar, /baz/qux => /foo/bar\n  if (startsWith(to, \"/\")) {\n    return to\n  }\n\n  const [toPathname, toQuery] = to.split(\"?\")\n  const [basePathname] = base.split(\"?\")\n\n  const toSegments = segmentize(toPathname)\n  const baseSegments = segmentize(basePathname)\n\n  // ?a=b, /users?b=c => /users?a=b\n  if (toSegments[0] === \"\") {\n    return addQuery(basePathname, toQuery)\n  }\n\n  // profile, /users/789 => /users/789/profile\n  if (!startsWith(toSegments[0], \".\")) {\n    const pathname = baseSegments.concat(toSegments).join(\"/\")\n    return addQuery((basePathname === \"/\" ? \"\" : \"/\") + pathname, toQuery)\n  }\n\n  // ./         /users/123  =>  /users/123\n  // ../        /users/123  =>  /users\n  // ../..      /users/123  =>  /\n  // ../../one  /a/b/c/d    =>  /a/b/one\n  // .././one   /a/b/c/d    =>  /a/b/c/one\n  const allSegments = baseSegments.concat(toSegments)\n  const segments = []\n  for (let i = 0, l = allSegments.length; i < l; i++) {\n    const segment = allSegments[i]\n    if (segment === \"..\") segments.pop()\n    else if (segment !== \".\") segments.push(segment)\n  }\n\n  return addQuery(\"/\" + segments.join(\"/\"), toQuery)\n}\n\nconst insertParams = (path, params) => {\n  const [pathBase, query = \"\"] = path.split(\"?\")\n  const segments = segmentize(pathBase)\n  let constructedPath =\n    \"/\" +\n    segments\n      .map(segment => {\n        const match = paramRe.exec(segment)\n        return match ? params[match[1]] : segment\n      })\n      .join(\"/\")\n  const { location: { search = \"\" } = {} } = params\n  const searchSplit = search.split(\"?\")[1] || \"\"\n  constructedPath = addQuery(constructedPath, query, searchSplit)\n  return constructedPath\n}\n\nconst validateRedirect = (from, to) => {\n  const filter = segment => isDynamic(segment)\n  const fromString = segmentize(from).filter(filter).sort().join(\"/\")\n  const toString = segmentize(to).filter(filter).sort().join(\"/\")\n  return fromString === toString\n}\n\nconst paramRe = /^:(.+)/\n\nconst SEGMENT_POINTS = 4\nconst STATIC_POINTS = 3\nconst DYNAMIC_POINTS = 2\nconst SPLAT_PENALTY = 1\nconst ROOT_POINTS = 1\n\nconst isRootSegment = segment => segment === \"\"\nconst isDynamic = segment => paramRe.test(segment)\nconst isSplat = segment => segment && segment[0] === \"*\"\n\nconst rankRoute = (route, index) => {\n  const score = route.default\n    ? 0\n    : segmentize(route.path).reduce((score, segment) => {\n        score += SEGMENT_POINTS\n        if (isRootSegment(segment)) score += ROOT_POINTS\n        else if (isDynamic(segment)) score += DYNAMIC_POINTS\n        else if (isSplat(segment)) score -= SEGMENT_POINTS + SPLAT_PENALTY\n        else score += STATIC_POINTS\n        return score\n      }, 0)\n  return { route, score, index }\n}\n\nconst rankRoutes = routes =>\n  routes\n    .map(rankRoute)\n    .sort((a, b) =>\n      a.score < b.score ? 1 : a.score > b.score ? -1 : a.index - b.index\n    )\n\nconst segmentize = uri =>\n  uri\n    // strip starting/ending slashes\n    .replace(/(^\\/+|\\/+$)/g, \"\")\n    .split(\"/\")\n\nconst addQuery = (pathname, ...query) => {\n  query = query.filter(q => q && q.length > 0)\n  return pathname + (query && query.length > 0 ? `?${query.join(\"&\")}` : \"\")\n}\n\nconst reservedNames = [\"uri\", \"path\"]\n\n/**\n * Shallow compares two objects.\n * @param {Object} obj1 The first object to compare.\n * @param {Object} obj2 The second object to compare.\n */\nconst shallowCompare = (obj1, obj2) => {\n  const obj1Keys = Object.keys(obj1)\n  return (\n    obj1Keys.length === Object.keys(obj2).length &&\n    obj1Keys.every(key => obj2.hasOwnProperty(key) && obj1[key] === obj2[key])\n  )\n}\n\nconst stripSlashes = str => str.replace(/(^\\/+|\\/+$)/g, \"\")\n\nconst createRoute = basepath => element => {\n  if (!element) {\n    return null\n  }\n\n  if (element.type === React.Fragment && element.props.children) {\n    return React.Children.map(element.props.children, createRoute(basepath))\n  }\n  invariant(\n    element.props.path || element.props.default || element.type === Redirect,\n    `<Router>: Children of <Router> must have a \\`path\\` or \\`default\\` prop, or be a \\`<Redirect>\\`. None found on element type \\`${element.type}\\``\n  )\n\n  invariant(\n    !(element.type === Redirect && (!element.props.from || !element.props.to)),\n    `<Redirect from=\"${element.props.from}\" to=\"${element.props.to}\"/> requires both \"from\" and \"to\" props when inside a <Router>.`\n  )\n\n  invariant(\n    !(\n      element.type === Redirect &&\n      !validateRedirect(element.props.from, element.props.to)\n    ),\n    `<Redirect from=\"${element.props.from} to=\"${element.props.to}\"/> has mismatched dynamic segments, ensure both paths have the exact same dynamic segments.`\n  )\n\n  if (element.props.default) {\n    return { value: element, default: true }\n  }\n\n  const elementPath =\n    element.type === Redirect ? element.props.from : element.props.path\n\n  const path =\n    elementPath === \"/\"\n      ? basepath\n      : `${stripSlashes(basepath)}/${stripSlashes(elementPath)}`\n\n  return {\n    value: element,\n    default: element.props.default,\n    path: element.props.children ? `${stripSlashes(path)}/*` : path,\n  }\n}\n\nconst shouldNavigate = event =>\n  !event.defaultPrevented &&\n  event.button === 0 &&\n  !(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey)\n\nexport {\n  startsWith,\n  pick,\n  match,\n  resolve,\n  insertParams,\n  validateRedirect,\n  shallowCompare,\n  createRoute,\n  shouldNavigate,\n}\n","/* eslint-disable jsx-a11y/anchor-has-content */\nimport * as React from \"react\"\nimport PropTypes from \"prop-types\"\nimport { navigate } from \"./history\"\nimport { resolve, startsWith, shouldNavigate, shallowCompare } from \"./utils\"\nimport { useBaseContext, useLocationContext } from \"./hooks-use-context\"\n\nlet { forwardRef } = React\n\nif (typeof forwardRef === \"undefined\") {\n  forwardRef = C => C\n}\n\nconst k = () => {}\n\nexport const Link = forwardRef(({ innerRef, ...props }, ref) => {\n  const { baseuri } = useBaseContext()\n  const { location } = useLocationContext()\n\n  const { to, state, replace, getProps = k, ...anchorProps } = props\n  const href = resolve(to, baseuri)\n  const encodedHref = encodeURI(href)\n  const isCurrent = location.pathname === encodedHref\n  const isPartiallyCurrent = startsWith(location.pathname, encodedHref)\n\n  return (\n    <a\n      ref={ref || innerRef}\n      aria-current={isCurrent ? \"page\" : undefined}\n      {...anchorProps}\n      {...getProps({ isCurrent, isPartiallyCurrent, href, location })}\n      href={href}\n      onClick={event => {\n        if (anchorProps.onClick) anchorProps.onClick(event)\n        if (shouldNavigate(event)) {\n          event.preventDefault()\n          let shouldReplace = replace\n          if (typeof replace !== \"boolean\" && isCurrent) {\n            const { key, ...restState } = { ...location.state }\n            shouldReplace = shallowCompare({ ...state }, restState)\n          }\n          navigate(href, {\n            state,\n            replace: shouldReplace,\n          })\n        }\n      }}\n    />\n  )\n})\n\nLink.displayName = \"Link\"\n\nLink.propTypes = {\n  to: PropTypes.string.isRequired,\n}\n","// MIT LICENSE - Taken from: https://github.com/tatethurston/react-use-error-boundary/blob/525225a34d4ad50f52b5f5ac8731cdf6999cf8a8/src/index.tsx\n\nimport * as React from \"react\"\n\nclass ErrorBoundary extends React.Component {\n  displayName = \"ReactUseErrorBoundary\"\n\n  componentDidCatch(...args) {\n    // silence React warning:\n    // ErrorBoundary: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI\n    this.setState({})\n    this.props.onError(...args)\n  }\n\n  render() {\n    return this.props.children\n  }\n}\n\nconst noop = () => false\n\nconst errorBoundaryContext = React.createContext({\n  componentDidCatch: { current: undefined },\n  error: undefined,\n  setError: noop,\n})\n\nexport function ErrorBoundaryContext({ children }) {\n  const [error, setError] = React.useState()\n  const componentDidCatch = React.useRef()\n  const ctx = React.useMemo(\n    () => ({\n      componentDidCatch,\n      error,\n      setError,\n    }),\n    [error]\n  )\n  return (\n    <errorBoundaryContext.Provider value={ctx}>\n      <ErrorBoundary\n        error={error}\n        onError={(error, errorInfo) => {\n          setError(error)\n          componentDidCatch.current?.(error, errorInfo)\n        }}\n      >\n        {children}\n      </ErrorBoundary>\n    </errorBoundaryContext.Provider>\n  )\n}\nErrorBoundaryContext.displayName = \"ReactUseErrorBoundaryContext\"\n\nexport function withErrorBoundary(WrappedComponent) {\n  function WithErrorBoundary(props) {\n    return (\n      <ErrorBoundaryContext>\n        <WrappedComponent key=\"WrappedComponent\" {...props} />\n      </ErrorBoundaryContext>\n    )\n  }\n  WithErrorBoundary.displayName = `WithErrorBoundary(${\n    WrappedComponent.displayName ?? WrappedComponent.name ?? \"Component\"\n  })`\n\n  return WithErrorBoundary\n}\n\nexport function useErrorBoundary(componentDidCatch) {\n  const ctx = React.useContext(errorBoundaryContext)\n  ctx.componentDidCatch.current = componentDidCatch\n  const resetError = React.useCallback(() => {\n    ctx.setError(undefined)\n  }, [])\n\n  return [ctx.error, resetError]\n}\n","import * as React from \"react\"\nimport { globalHistory, navigate } from \"./history\"\nimport { isRedirect } from \"./redirect\"\nimport { LocationContext } from \"./hooks-create-context\"\nimport { withErrorBoundary, useErrorBoundary } from \"./error-boundary\"\n\nexport const LocationProvider = withErrorBoundary(\n  ({ history = globalHistory, children }) => {\n    const { location } = history\n\n    const [context, setContext] = React.useState({ location })\n    const [error] = useErrorBoundary()\n\n    React.useEffect(() => {\n      history._onTransitionComplete()\n    }, [context.location])\n\n    React.useEffect(() => {\n      let isCancelled = false\n      const unlisten = history.listen(({ location }) => {\n        Promise.resolve().then(() => {\n          requestAnimationFrame(() => {\n            if (!isCancelled) {\n              setContext({ location })\n            }\n          })\n        })\n      })\n      return () => {\n        isCancelled = true\n        unlisten()\n      }\n    }, [])\n\n    if (error) {\n      if (isRedirect(error)) {\n        navigate(error.uri, { replace: true })\n      } else {\n        throw error\n      }\n    }\n\n    return (\n      <LocationContext.Provider value={context}>\n        {typeof children === \"function\" ? children(context) : children || null}\n      </LocationContext.Provider>\n    )\n  }\n)\n","import * as React from \"react\"\nimport { useLocationContext } from \"./hooks-use-context\"\nimport { LocationProvider } from \"./location-provider\"\n\nexport const Location = ({ children }) => {\n  const context = useLocationContext()\n\n  if (context) {\n    return children(context)\n  } else {\n    return <LocationProvider>{children}</LocationProvider>\n  }\n}\n","import * as React from \"react\"\nimport { LocationContext } from \"./hooks-create-context\"\n\nexport const ServerLocation = ({ url, children }) => {\n  const searchIndex = url.indexOf(\"?\")\n  const searchExists = searchIndex > -1\n  let pathname\n  let search = \"\"\n  const hash = \"\"\n\n  if (searchExists) {\n    pathname = url.substring(0, searchIndex)\n    search = url.substring(searchIndex)\n  } else {\n    pathname = url\n  }\n\n  return (\n    <LocationContext.Provider\n      value={{\n        location: {\n          pathname,\n          search,\n          hash,\n        },\n      }}\n    >\n      {children}\n    </LocationContext.Provider>\n  )\n}\n","import { useBaseContext, useLocationContext } from \"./hooks-use-context\"\nimport { resolve, match } from \"./utils\"\n\nconst Match = ({ path, children }) => {\n  const { baseuri } = useBaseContext()\n  const { location } = useLocationContext()\n\n  const resolvedPath = resolve(path, baseuri)\n  const result = match(resolvedPath, location.pathname)\n  return children({\n    location,\n    match: result\n      ? {\n          ...result.params,\n          uri: result.uri,\n          path,\n        }\n      : null,\n  })\n}\n\nexport { Match }\n","import * as React from \"react\"\n\nexport const FocusHandler = ({ uri, location, component, ...domProps }) => {\n  return (\n    <FocusHandlerImpl\n      {...domProps}\n      component={component}\n      uri={uri}\n      location={location}\n    />\n  )\n}\n\nlet focusHandlerCount = 0\n\nconst FocusHandlerImpl = ({\n  children,\n  style,\n  component: Comp = \"div\",\n  uri,\n  location,\n  ...domProps\n}) => {\n  const focusWrapperRef = React.useRef()\n  const initialRenderRef = React.useRef(true)\n  const uriRef = React.useRef(uri)\n  const pathnameRef = React.useRef(location.pathname)\n  const shouldFocusRef = React.useRef(false)\n\n  const _requestFocus = requestNode => {\n    if (shouldFocusRef.current && requestNode) {\n      requestNode.focus()\n    }\n  }\n\n  // Initial mount/unmount logic\n  React.useEffect(() => {\n    focusHandlerCount++\n    focus()\n\n    return () => {\n      focusHandlerCount--\n      if (focusHandlerCount === 0) {\n        initialRenderRef.current = true\n      }\n    }\n  }, [])\n\n  // Subsequent navigation logic\n  React.useEffect(() => {\n    let uriChanged = false\n    let pathnameChanged = false\n\n    if (uri !== uriRef.current) {\n      uriRef.current = uri\n      uriChanged = true\n    }\n\n    if (location.pathname !== pathnameRef.current) {\n      pathnameRef.current = location.pathname\n      pathnameChanged = true\n    }\n\n    const navigatedUpToMe = pathnameChanged && location.pathname === uri\n\n    shouldFocusRef.current = uriChanged || navigatedUpToMe\n\n    if (shouldFocusRef.current) {\n      focus()\n    }\n  }, [uri, location])\n\n  const focus = React.useCallback(() => {\n    if (process.env.NODE_ENV === \"test\") {\n      // TODO: Check if change for tests still needed\n      return\n    }\n\n    // Don't focus the <Comp /> on initial render\n    if (initialRenderRef.current) {\n      initialRenderRef.current = false\n    } else {\n      _requestFocus(focusWrapperRef.current)\n    }\n  }, [])\n\n  return (\n    <Comp\n      style={{ outline: \"none\", ...style }}\n      tabIndex=\"-1\"\n      ref={focusWrapperRef}\n      {...domProps}\n    >\n      {children}\n    </Comp>\n  )\n}\n","import * as React from \"react\"\nimport { BaseContext } from \"./hooks-create-context\"\nimport { createRoute, pick } from \"./utils\"\nimport { FocusHandler } from \"./focus-handler\"\nimport { useBaseContext, useLocationContext } from \"./hooks-use-context\"\n\nexport const Router = props => {\n  const baseContext = useBaseContext()\n  const locationContext = useLocationContext()\n\n  return <RouterImpl {...baseContext} {...locationContext} {...props} />\n}\n\nfunction RouterImpl(props) {\n  const {\n    location,\n    primary = true,\n    children,\n    basepath,\n    baseuri,\n    component = \"div\",\n    ...domProps\n  } = props\n\n  const routes = React.Children.toArray(children).reduce((array, child) => {\n    const routes = createRoute(basepath)(child)\n    return array.concat(routes)\n  }, [])\n  const { pathname } = location\n  const match = pick(routes, pathname)\n\n  if (match) {\n    const {\n      params,\n      uri,\n      route,\n      route: { value: element },\n    } = match\n\n    // remove the /* from the end for child routes relative paths\n    const normalizedBasePath = route.default\n      ? basepath\n      : route.path.replace(/\\*$/, \"\")\n\n    const props = {\n      ...params,\n      uri,\n      location,\n    }\n\n    const clone = React.cloneElement(\n      element,\n      props,\n      element.props.children ? (\n        <Router location={location} primary={primary}>\n          {element.props.children}\n        </Router>\n      ) : undefined\n    )\n\n    // using 'div' for < 16.3 support\n    const FocusWrapper = primary ? FocusHandler : component\n    // don't pass any props to 'div'\n    const wrapperProps = primary\n      ? { uri, location, component, ...domProps }\n      : domProps\n\n    return (\n      <BaseContext.Provider\n        value={{ baseuri: uri, basepath: normalizedBasePath }}\n      >\n        <FocusWrapper {...wrapperProps}>{clone}</FocusWrapper>\n      </BaseContext.Provider>\n    )\n  } else {\n    return null\n  }\n}\n","import { useLocationContext } from \"../lib/hooks-use-context\"\n\nexport const useLocation = () => {\n  const context = useLocationContext()\n\n  if (!context) {\n    throw new Error(\n      \"useLocation hook was used but a LocationContext.Provider was not found in the parent tree. Make sure this is used in a component that is a child of Router\"\n    )\n  }\n\n  return context.location\n}\n","export const useNavigate = () => {\n  throw new Error(\n    \"useNavigate is removed. Use import { navigate } from 'gatsby' instead\"\n  )\n}\n","import { useBaseContext } from \"../lib/hooks-use-context\"\nimport { match } from \"../lib/utils\"\nimport { useLocation } from \"./use-location\"\n\nexport const useParams = () => {\n  const context = useBaseContext()\n\n  if (!context) {\n    throw new Error(\n      \"useParams hook was used but a LocationContext.Provider was not found in the parent tree. Make sure this is used in a component that is a child of Router\"\n    )\n  }\n\n  const location = useLocation()\n\n  const results = match(context.basepath, location.pathname)\n\n  return results ? results.params : null\n}\n","import { useBaseContext } from \"../lib/hooks-use-context\"\nimport { resolve, match } from \"../lib/utils\"\nimport { useLocation } from \"./use-location\"\n\nexport const useMatch = path => {\n  if (!path) {\n    throw new Error(\n      \"useMatch(path: string) requires an argument of a string to match against\"\n    )\n  }\n  const context = useBaseContext()\n\n  if (!context) {\n    throw new Error(\n      \"useMatch hook was used but a LocationContext.Provider was not found in the parent tree. Make sure this is used in a component that is a child of Router\"\n    )\n  }\n\n  const location = useLocation()\n\n  const resolvedPath = resolve(path, context.baseuri)\n  const result = match(resolvedPath, location.pathname)\n  return result\n    ? {\n        ...result.params,\n        uri: result.uri,\n        path,\n      }\n    : null\n}\n"],"names":["source","search","hash","href","origin","protocol","host","hostname","port","location","pathname","canUseDOM","encodeURI","decodeURI","state","history","key","options","getLocation","transitioning","resolveTransition","_onTransitionComplete","listen","listener","listeners","push","popstateListener","action","addEventListener","removeEventListener","filter","fn","navigate","to","replace","go","Date","now","replaceState","pushState","e","transition","Promise","res","forEach","createMemorySource","initialPath","searchIndex","indexOf","initialLocation","substr","index","stack","name","entries","states","_","uri","split","length","newIndex","window","document","createElement","globalHistory","createHistory","createServerOrClientContext","defaultValue","React","createServerContext","globalThis","__SERVER_CONTEXT","createContext","BaseContext","baseuri","basepath","LocationContext","useContext","useLocationContext","RedirectRequest","this","isRedirect","o","redirectTo","RedirectImpl","props","noThrow","useEffect","resolve","then","resolvedTo","insertParams","Redirect","locationContext","useBaseContext","_extends","propTypes","from","PropTypes","string","isRequired","startsWith","routes","match","default_","uriPathname","uriSegments","segmentize","isRootUri","ranked","rankRoutes","l","i","route","default","params","routeSegments","path","max","Math","routeSegment","uriSegment","isSplat","slice","map","decodeURIComponent","join","undefined","missed","dynamicMatch","paramRe","exec","matchIsNotReserved","reservedNames","invariant","value","pick","base","toPathname","toQuery","basePathname","toSegments","addQuery","baseSegments","concat","allSegments","segment","segments","pop","pathBase","query","constructedPath","searchSplit","isDynamic","sort","toString","test","score","reduce","isRootSegment","SEGMENT_POINTS","rankRoute","a","b","q","obj1","obj2","Object","keys","obj1Keys","every","hasOwnProperty","stripSlashes","str","createRoute","element","type","Fragment","children","Children","validateRedirect","elementPath","_excluded","_excluded2","_excluded3","forwardRef","C","k","Link","ref","innerRef","_ref","_objectWithoutPropertiesLoose","getProps","anchorProps","encodedHref","isCurrent","isPartiallyCurrent","onClick","event","defaultPrevented","button","metaKey","altKey","ctrlKey","shiftKey","shouldNavigate","preventDefault","shouldReplace","restState","shallowCompare","displayName","ErrorBoundary","Component","constructor","args","super","componentDidCatch","setState","onError","render","errorBoundaryContext","current","error","setError","ErrorBoundaryContext","useState","useRef","ctx","useMemo","Provider","errorInfo","LocationProvider","withErrorBoundary","WrappedComponent","_WrappedComponent$dis","WithErrorBoundary","context","setContext","useErrorBoundary","resetError","useCallback","isCancelled","unlisten","requestAnimationFrame","Location","ServerLocation","url","substring","Match","resolvedPath","result","FocusHandler","component","domProps","FocusHandlerImpl","_ref2","style","Comp","focusWrapperRef","initialRenderRef","uriRef","shouldFocusRef","focusHandlerCount","focus","uriChanged","pathnameChanged","pathnameRef","requestNode","process","env","NODE_ENV","outline","tabIndex","baseContext","RouterImpl","primary","toArray","array","child","_props","clone","cloneElement","Router","FocusWrapper","wrapperProps","normalizedBasePath","useLocation","Error","useNavigate","useParams","results","useMatch"],"mappings":"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"}