{"version":3,"file":"CommandLineParameterProvider.js","sourceRoot":"","sources":["../../src/providers/CommandLineParameterProvider.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport * as argparse from 'argparse';\n\nimport type {\n  ICommandLineChoiceDefinition,\n  ICommandLineChoiceListDefinition,\n  ICommandLineIntegerDefinition,\n  ICommandLineIntegerListDefinition,\n  ICommandLineFlagDefinition,\n  ICommandLineStringDefinition,\n  ICommandLineStringListDefinition,\n  ICommandLineRemainderDefinition\n} from '../parameters/CommandLineDefinition';\nimport type { ICommandLineParserOptions } from './CommandLineParser';\nimport {\n  CommandLineParameter,\n  CommandLineParameterWithArgument,\n  CommandLineParameterKind\n} from '../parameters/BaseClasses';\nimport { CommandLineChoiceParameter } from '../parameters/CommandLineChoiceParameter';\nimport { CommandLineChoiceListParameter } from '../parameters/CommandLineChoiceListParameter';\nimport { CommandLineIntegerParameter } from '../parameters/CommandLineIntegerParameter';\nimport { CommandLineIntegerListParameter } from '../parameters/CommandLineIntegerListParameter';\nimport { CommandLineFlagParameter } from '../parameters/CommandLineFlagParameter';\nimport { CommandLineStringParameter } from '../parameters/CommandLineStringParameter';\nimport { CommandLineStringListParameter } from '../parameters/CommandLineStringListParameter';\nimport { CommandLineRemainder } from '../parameters/CommandLineRemainder';\nimport { SCOPING_PARAMETER_GROUP } from '../Constants';\n\n/**\n * The result containing the parsed paramter long name and scope. Returned when calling\n * {@link CommandLineParameterProvider.parseScopedLongName}.\n *\n * @public\n */\nexport interface IScopedLongNameParseResult {\n  /**\n   * The long name parsed from the scoped long name, e.g. \"--my-scope:my-parameter\" -\\> \"--my-parameter\"\n   */\n  longName: string;\n\n  /**\n   * The scope parsed from the scoped long name or undefined if no scope was found,\n   * e.g. \"--my-scope:my-parameter\" -\\> \"my-scope\"\n   */\n  scope: string | undefined;\n}\n\n/**\n * This is the argparse result data object\n * @internal\n */\nexport interface ICommandLineParserData {\n  action: string;\n  [key: string]: any; // eslint-disable-line @typescript-eslint/no-explicit-any\n}\n\nconst SCOPE_GROUP_NAME: string = 'scope';\nconst LONG_NAME_GROUP_NAME: string = 'longName';\nconst POSSIBLY_SCOPED_LONG_NAME_REGEXP: RegExp =\n  /^--((?<scope>[a-z0-9]+(-[a-z0-9]+)*):)?(?<longName>[a-z0-9]+((-[a-z0-9]+)+)?)$/;\n\n/**\n * This is the common base class for CommandLineAction and CommandLineParser\n * that provides functionality for defining command-line parameters.\n *\n * @public\n */\nexport abstract class CommandLineParameterProvider {\n  private static _keyCounter: number = 0;\n\n  private readonly _parameters: CommandLineParameter[];\n  private readonly _parametersByLongName: Map<string, CommandLineParameter[]>;\n  private readonly _parameterGroupsByName: Map<\n    string | typeof SCOPING_PARAMETER_GROUP,\n    argparse.ArgumentGroup\n  >;\n  private _parametersRegistered: boolean;\n  private _parametersProcessed: boolean;\n  private _remainder: CommandLineRemainder | undefined;\n\n  /** @internal */\n  // Third party code should not inherit subclasses or call this constructor\n  public constructor() {\n    this._parameters = [];\n    this._parametersByLongName = new Map();\n    this._parameterGroupsByName = new Map();\n    this._parametersRegistered = false;\n    this._parametersProcessed = false;\n  }\n\n  /**\n   * Returns a collection of the parameters that were defined for this object.\n   */\n  public get parameters(): ReadonlyArray<CommandLineParameter> {\n    return this._parameters;\n  }\n\n  /**\n   * Informs the caller if the argparse data has been processed into parameters.\n   */\n  public get parametersProcessed(): boolean {\n    return this._parametersProcessed;\n  }\n\n  /**\n   * If {@link CommandLineParameterProvider.defineCommandLineRemainder} was called,\n   * this object captures any remaining command line arguments after the recognized portion.\n   */\n  public get remainder(): CommandLineRemainder | undefined {\n    return this._remainder;\n  }\n\n  /**\n   * Defines a command-line parameter whose value must be a string from a fixed set of\n   * allowable choices (similar to an enum).\n   *\n   * @remarks\n   * Example of a choice parameter:\n   * ```\n   * example-tool --log-level warn\n   * ```\n   */\n  public defineChoiceParameter(definition: ICommandLineChoiceDefinition): CommandLineChoiceParameter {\n    const parameter: CommandLineChoiceParameter = new CommandLineChoiceParameter(definition);\n    this._defineParameter(parameter);\n    return parameter;\n  }\n\n  /**\n   * Returns the CommandLineChoiceParameter with the specified long name.\n   * @remarks\n   * This method throws an exception if the parameter is not defined.\n   */\n  public getChoiceParameter(parameterLongName: string, parameterScope?: string): CommandLineChoiceParameter {\n    return this._getParameter(parameterLongName, CommandLineParameterKind.Choice, parameterScope);\n  }\n\n  /**\n   * Defines a command-line parameter whose value must be a string from a fixed set of\n   * allowable choices (similar to an enum). The parameter can be specified multiple times to\n   * build a list.\n   *\n   * @remarks\n   * Example of a choice list parameter:\n   * ```\n   * example-tool --allow-color red --allow-color green\n   * ```\n   */\n  public defineChoiceListParameter(\n    definition: ICommandLineChoiceListDefinition\n  ): CommandLineChoiceListParameter {\n    const parameter: CommandLineChoiceListParameter = new CommandLineChoiceListParameter(definition);\n    this._defineParameter(parameter);\n    return parameter;\n  }\n\n  /**\n   * Returns the CommandLineChoiceListParameter with the specified long name.\n   * @remarks\n   * This method throws an exception if the parameter is not defined.\n   */\n  public getChoiceListParameter(\n    parameterLongName: string,\n    parameterScope?: string\n  ): CommandLineChoiceListParameter {\n    return this._getParameter(parameterLongName, CommandLineParameterKind.ChoiceList, parameterScope);\n  }\n\n  /**\n   * Defines a command-line switch whose boolean value is true if the switch is provided,\n   * and false otherwise.\n   *\n   * @remarks\n   * Example usage of a flag parameter:\n   * ```\n   * example-tool --debug\n   * ```\n   */\n  public defineFlagParameter(definition: ICommandLineFlagDefinition): CommandLineFlagParameter {\n    const parameter: CommandLineFlagParameter = new CommandLineFlagParameter(definition);\n    this._defineParameter(parameter);\n    return parameter;\n  }\n\n  /**\n   * Returns the CommandLineFlagParameter with the specified long name.\n   * @remarks\n   * This method throws an exception if the parameter is not defined.\n   */\n  public getFlagParameter(parameterLongName: string, parameterScope?: string): CommandLineFlagParameter {\n    return this._getParameter(parameterLongName, CommandLineParameterKind.Flag, parameterScope);\n  }\n\n  /**\n   * Defines a command-line parameter whose argument is an integer.\n   *\n   * @remarks\n   * Example usage of an integer parameter:\n   * ```\n   * example-tool --max-attempts 5\n   * ```\n   */\n  public defineIntegerParameter(definition: ICommandLineIntegerDefinition): CommandLineIntegerParameter {\n    const parameter: CommandLineIntegerParameter = new CommandLineIntegerParameter(definition);\n    this._defineParameter(parameter);\n    return parameter;\n  }\n\n  /**\n   * Returns the CommandLineIntegerParameter with the specified long name.\n   * @remarks\n   * This method throws an exception if the parameter is not defined.\n   */\n  public getIntegerParameter(\n    parameterLongName: string,\n    parameterScope?: string\n  ): CommandLineIntegerParameter {\n    return this._getParameter(parameterLongName, CommandLineParameterKind.Integer, parameterScope);\n  }\n\n  /**\n   * Defines a command-line parameter whose argument is an integer. The parameter can be specified\n   * multiple times to build a list.\n   *\n   * @remarks\n   * Example usage of an integer list parameter:\n   * ```\n   * example-tool --avoid 4 --avoid 13\n   * ```\n   */\n  public defineIntegerListParameter(\n    definition: ICommandLineIntegerListDefinition\n  ): CommandLineIntegerListParameter {\n    const parameter: CommandLineIntegerListParameter = new CommandLineIntegerListParameter(definition);\n    this._defineParameter(parameter);\n    return parameter;\n  }\n\n  /**\n   * Returns the CommandLineIntegerParameter with the specified long name.\n   * @remarks\n   * This method throws an exception if the parameter is not defined.\n   */\n  public getIntegerListParameter(\n    parameterLongName: string,\n    parameterScope?: string\n  ): CommandLineIntegerListParameter {\n    return this._getParameter(parameterLongName, CommandLineParameterKind.IntegerList, parameterScope);\n  }\n\n  /**\n   * Defines a command-line parameter whose argument is a single text string.\n   *\n   * @remarks\n   * Example usage of a string parameter:\n   * ```\n   * example-tool --message \"Hello, world!\"\n   * ```\n   */\n  public defineStringParameter(definition: ICommandLineStringDefinition): CommandLineStringParameter {\n    const parameter: CommandLineStringParameter = new CommandLineStringParameter(definition);\n    this._defineParameter(parameter);\n    return parameter;\n  }\n\n  /**\n   * Returns the CommandLineStringParameter with the specified long name.\n   * @remarks\n   * This method throws an exception if the parameter is not defined.\n   */\n  public getStringParameter(parameterLongName: string, parameterScope?: string): CommandLineStringParameter {\n    return this._getParameter(parameterLongName, CommandLineParameterKind.String, parameterScope);\n  }\n\n  /**\n   * Defines a command-line parameter whose argument is a single text string.  The parameter can be\n   * specified multiple times to build a list.\n   *\n   * @remarks\n   * Example usage of a string list parameter:\n   * ```\n   * example-tool --add file1.txt --add file2.txt --add file3.txt\n   * ```\n   */\n  public defineStringListParameter(\n    definition: ICommandLineStringListDefinition\n  ): CommandLineStringListParameter {\n    const parameter: CommandLineStringListParameter = new CommandLineStringListParameter(definition);\n    this._defineParameter(parameter);\n    return parameter;\n  }\n\n  /**\n   * Defines a rule that captures any remaining command line arguments after the recognized portion.\n   *\n   * @remarks\n   * This feature is useful for commands that pass their arguments along to an external tool, relying on\n   * that tool to perform validation.  (It could also be used to parse parameters without any validation\n   * or documentation, but that is not recommended.)\n   *\n   * Example of capturing the remainder after an optional flag parameter.\n   * ```\n   * example-tool --my-flag this is the remainder\n   * ```\n   *\n   * In the \"--help\" documentation, the remainder rule will be represented as \"...\".\n   */\n  public defineCommandLineRemainder(definition: ICommandLineRemainderDefinition): CommandLineRemainder {\n    if (this._remainder) {\n      throw new Error('defineRemainingArguments() has already been called for this provider');\n    }\n    this._remainder = new CommandLineRemainder(definition);\n    return this._remainder;\n  }\n\n  /**\n   * Returns the CommandLineStringListParameter with the specified long name.\n   * @remarks\n   * This method throws an exception if the parameter is not defined.\n   */\n  public getStringListParameter(\n    parameterLongName: string,\n    parameterScope?: string\n  ): CommandLineStringListParameter {\n    return this._getParameter(parameterLongName, CommandLineParameterKind.StringList, parameterScope);\n  }\n\n  /**\n   * Generates the command-line help text.\n   */\n  public renderHelpText(): string {\n    this._registerDefinedParameters();\n    return this._getArgumentParser().formatHelp();\n  }\n\n  /**\n   * Generates the command-line usage text.\n   */\n  public renderUsageText(): string {\n    this._registerDefinedParameters();\n    return this._getArgumentParser().formatUsage();\n  }\n\n  /**\n   * Returns a object which maps the long name of each parameter in this.parameters\n   * to the stringified form of its value. This is useful for logging telemetry, but\n   * it is not the proper way of accessing parameters or their values.\n   */\n  public getParameterStringMap(): Record<string, string> {\n    const parameterMap: Record<string, string> = {};\n    for (const parameter of this.parameters) {\n      const parameterName: string = parameter.scopedLongName || parameter.longName;\n      switch (parameter.kind) {\n        case CommandLineParameterKind.Flag:\n        case CommandLineParameterKind.Choice:\n        case CommandLineParameterKind.String:\n        case CommandLineParameterKind.Integer:\n          parameterMap[parameterName] = JSON.stringify(\n            (\n              parameter as\n                | CommandLineFlagParameter\n                | CommandLineIntegerParameter\n                | CommandLineChoiceParameter\n                | CommandLineStringParameter\n            ).value\n          );\n          break;\n        case CommandLineParameterKind.StringList:\n        case CommandLineParameterKind.IntegerList:\n        case CommandLineParameterKind.ChoiceList:\n          const arrayValue: ReadonlyArray<string | number> | undefined = (\n            parameter as\n              | CommandLineIntegerListParameter\n              | CommandLineStringListParameter\n              | CommandLineChoiceListParameter\n          ).values;\n          parameterMap[parameterName] = arrayValue ? arrayValue.join(',') : '';\n          break;\n      }\n    }\n    return parameterMap;\n  }\n\n  /**\n   * Returns an object with the parsed scope (if present) and the long name of the parameter.\n   */\n  public parseScopedLongName(scopedLongName: string): IScopedLongNameParseResult {\n    const result: RegExpExecArray | null = POSSIBLY_SCOPED_LONG_NAME_REGEXP.exec(scopedLongName);\n    if (!result || !result.groups) {\n      throw new Error(`The parameter long name \"${scopedLongName}\" is not valid.`);\n    }\n    return {\n      longName: `--${result.groups[LONG_NAME_GROUP_NAME]}`,\n      scope: result.groups[SCOPE_GROUP_NAME]\n    };\n  }\n\n  /** @internal */\n  public _registerDefinedParameters(): void {\n    if (this._parametersRegistered) {\n      // We prevent new parameters from being defined after the first call to _registerDefinedParameters,\n      // so we can already ensure that all parameters were registered.\n      return;\n    }\n    this._parametersRegistered = true;\n\n    for (const longNameParameters of this._parametersByLongName.values()) {\n      const useScopedLongName: boolean = longNameParameters.length > 1;\n      for (const parameter of longNameParameters) {\n        if (useScopedLongName && !parameter.parameterScope) {\n          throw new Error(\n            `The parameter \"${parameter.longName}\" is defined multiple times with the same long name. ` +\n              'Parameters with the same long name must define a scope.'\n          );\n        }\n        this._registerParameter(parameter, useScopedLongName);\n      }\n    }\n\n    // Need to add the remainder parameter last\n    if (this._remainder) {\n      const argparseOptions: argparse.ArgumentOptions = {\n        help: this._remainder.description,\n        nargs: argparse.Const.REMAINDER,\n        metavar: '\"...\"'\n      };\n\n      this._getArgumentParser().addArgument(argparse.Const.REMAINDER, argparseOptions);\n    }\n  }\n\n  /**\n   * The child class should implement this hook to define its command-line parameters,\n   * e.g. by calling defineFlagParameter().\n   */\n  protected onDefineParameters?(): void;\n\n  /**\n   * Retrieves the argparse object.\n   * @internal\n   */\n  protected abstract _getArgumentParser(): argparse.ArgumentParser;\n\n  /** @internal */\n  protected _processParsedData(parserOptions: ICommandLineParserOptions, data: ICommandLineParserData): void {\n    if (!this._parametersRegistered) {\n      throw new Error('Parameters have not been registered');\n    }\n\n    if (this._parametersProcessed) {\n      throw new Error('Command Line Parser Data was already processed');\n    }\n\n    // Fill in the values for the parameters\n    for (const parameter of this._parameters) {\n      const value: any = data[parameter._parserKey!]; // eslint-disable-line @typescript-eslint/no-explicit-any\n      parameter._setValue(value);\n    }\n\n    if (this.remainder) {\n      this.remainder._setValue(data[argparse.Const.REMAINDER]);\n    }\n\n    this._parametersProcessed = true;\n  }\n\n  /** @internal */\n  protected _defineParameter(parameter: CommandLineParameter): void {\n    if (this._parametersRegistered) {\n      throw new Error('Parameters have already been registered for this provider');\n    }\n\n    // Generate and set the parser key at definition time\n    parameter._parserKey = this._generateKey();\n\n    this._parameters.push(parameter);\n\n    // Collect all parameters with the same long name. We will perform conflict resolution at registration.\n    let longNameParameters: CommandLineParameter[] | undefined = this._parametersByLongName.get(\n      parameter.longName\n    );\n    if (!longNameParameters) {\n      longNameParameters = [];\n      this._parametersByLongName.set(parameter.longName, longNameParameters);\n    }\n    longNameParameters.push(parameter);\n  }\n\n  /** @internal */\n  protected _registerParameter(parameter: CommandLineParameter, useScopedLongName: boolean): void {\n    const names: string[] = [];\n    if (parameter.shortName) {\n      names.push(parameter.shortName);\n    }\n\n    // Use the original long name unless otherwise requested\n    if (!useScopedLongName) {\n      names.push(parameter.longName);\n    }\n\n    // Add the scoped long name if it exists\n    if (parameter.scopedLongName) {\n      names.push(parameter.scopedLongName);\n    }\n\n    let finalDescription: string = parameter.description;\n\n    const supplementaryNotes: string[] = [];\n    parameter._getSupplementaryNotes(supplementaryNotes);\n    if (supplementaryNotes.length > 0) {\n      // If they left the period off the end of their sentence, then add one.\n      if (finalDescription.match(/[a-z0-9]\"?\\s*$/i)) {\n        finalDescription = finalDescription.trimRight() + '.';\n      }\n      // Append the supplementary text\n      finalDescription += ' ' + supplementaryNotes.join(' ');\n    }\n\n    // NOTE: Our \"environmentVariable\" feature takes precedence over argparse's \"defaultValue\",\n    // so we have to reimplement that feature.\n    const argparseOptions: argparse.ArgumentOptions = {\n      help: finalDescription,\n      dest: parameter._parserKey,\n      metavar: (parameter as CommandLineParameterWithArgument).argumentName || undefined,\n      required: parameter.required\n    };\n\n    switch (parameter.kind) {\n      case CommandLineParameterKind.Choice: {\n        const choiceParameter: CommandLineChoiceParameter = parameter as CommandLineChoiceParameter;\n        argparseOptions.choices = choiceParameter.alternatives as string[];\n        break;\n      }\n      case CommandLineParameterKind.ChoiceList: {\n        const choiceParameter: CommandLineChoiceListParameter = parameter as CommandLineChoiceListParameter;\n        argparseOptions.choices = choiceParameter.alternatives as string[];\n        argparseOptions.action = 'append';\n        break;\n      }\n      case CommandLineParameterKind.Flag:\n        argparseOptions.action = 'storeTrue';\n        break;\n      case CommandLineParameterKind.Integer:\n        argparseOptions.type = 'int';\n        break;\n      case CommandLineParameterKind.IntegerList:\n        argparseOptions.type = 'int';\n        argparseOptions.action = 'append';\n        break;\n      case CommandLineParameterKind.String:\n        break;\n      case CommandLineParameterKind.StringList:\n        argparseOptions.action = 'append';\n        break;\n    }\n\n    let argumentGroup: argparse.ArgumentGroup | undefined;\n    if (parameter.parameterGroup) {\n      argumentGroup = this._parameterGroupsByName.get(parameter.parameterGroup);\n      if (!argumentGroup) {\n        let parameterGroupName: string;\n        if (typeof parameter.parameterGroup === 'string') {\n          parameterGroupName = parameter.parameterGroup;\n        } else if (parameter.parameterGroup === SCOPING_PARAMETER_GROUP) {\n          parameterGroupName = 'scoping';\n        } else {\n          throw new Error('Unexpected parameter group: ' + parameter.parameterGroup);\n        }\n\n        argumentGroup = this._getArgumentParser().addArgumentGroup({\n          title: `Optional ${parameterGroupName} arguments`\n        });\n        this._parameterGroupsByName.set(parameter.parameterGroup, argumentGroup);\n      }\n    } else {\n      argumentGroup = this._getArgumentParser();\n    }\n\n    argumentGroup.addArgument(names, { ...argparseOptions });\n\n    if (parameter.undocumentedSynonyms && parameter.undocumentedSynonyms.length > 0) {\n      argumentGroup.addArgument(parameter.undocumentedSynonyms, {\n        ...argparseOptions,\n        help: argparse.Const.SUPPRESS\n      });\n    }\n  }\n\n  private _generateKey(): string {\n    return 'key_' + (CommandLineParameterProvider._keyCounter++).toString();\n  }\n\n  private _getParameter<T extends CommandLineParameter>(\n    parameterLongName: string,\n    expectedKind: CommandLineParameterKind,\n    parameterScope?: string\n  ): T {\n    // Support the parameter long name being prefixed with the scope\n    const { scope, longName } = this.parseScopedLongName(parameterLongName);\n    parameterLongName = longName;\n    parameterScope = scope || parameterScope;\n\n    const parameters: CommandLineParameter[] | undefined = this._parametersByLongName.get(parameterLongName);\n    if (!parameters) {\n      throw new Error(`The parameter \"${parameterLongName}\" is not defined`);\n    }\n\n    const parameter: CommandLineParameter | undefined = parameters.find(\n      (p) => p.parameterScope === parameterScope\n    );\n    if (!parameter) {\n      throw new Error(`The parameter \"${parameterLongName}\" with scope \"${parameterScope}\" is not defined.`);\n    }\n\n    if (parameter.kind !== expectedKind) {\n      throw new Error(\n        `The parameter \"${parameterLongName}\" is of type \"${CommandLineParameterKind[parameter.kind]}\"` +\n          ` whereas the caller was expecting \"${CommandLineParameterKind[expectedKind]}\".`\n      );\n    }\n    return parameter as T;\n  }\n}\n"]}