{"version":3,"file":"get-page-data.js","names":["DEFAULT_WAIT_TIMEOUT","RETRY_INTERVAL","getPageData","pagePath","waitForMS","doGetPageData","initialWaitForMs","queries","pendingPageDataWrites","pages","store","getState","has","Error","query","trackedQueries","get","running","waitNextPageData","dirty","emitter","emit","pagePaths","readPageData","remainingTime","Promise","resolve","on","listener","timeout","setTimeout","off","Math","max","min","data","payload","page","clearTimeout","process","nextTick","catch","toFixed","program","readPageDataUtil","path","join","directory","err"],"sources":["../../src/utils/get-page-data.ts"],"sourcesContent":["import * as path from \"path\"\nimport { store, emitter } from \"../redux\"\nimport { IClearPendingPageDataWriteAction } from \"../redux/types\"\nimport {\n  IPageDataWithQueryResult,\n  readPageData as readPageDataUtil,\n} from \"./page-data\"\n\nconst DEFAULT_WAIT_TIMEOUT = 15 * 1000\nexport const RETRY_INTERVAL = 5 * 1000\n\nexport async function getPageData(\n  pagePath: string,\n  waitForMS: number = DEFAULT_WAIT_TIMEOUT\n): Promise<IPageDataWithQueryResult> {\n  return doGetPageData(pagePath, waitForMS, waitForMS)\n}\n\nasync function doGetPageData(\n  pagePath: string,\n  waitForMS: number,\n  initialWaitForMs: number\n): Promise<IPageDataWithQueryResult> {\n  const { queries, pendingPageDataWrites, pages } = store.getState()\n\n  if (!pages.has(pagePath)) {\n    throw new Error(\n      `Page \"${pagePath}\" doesn't exist. It might have been deleted recently.`\n    )\n  }\n\n  const query = queries.trackedQueries.get(pagePath)\n\n  if (!query) {\n    throw new Error(`Could not find query ${pagePath}`)\n  }\n  if (query.running !== 0) {\n    return waitNextPageData(pagePath, waitForMS, initialWaitForMs)\n  }\n  if (query.dirty !== 0) {\n    emitter.emit(`QUERY_RUN_REQUESTED`, { pagePath })\n    return waitNextPageData(pagePath, waitForMS, initialWaitForMs)\n  }\n  if (pendingPageDataWrites.pagePaths.has(pagePath)) {\n    return waitNextPageData(pagePath, waitForMS, initialWaitForMs)\n  }\n  // Results are up-to-date\n  return readPageData(pagePath)\n}\n\nasync function waitNextPageData(\n  pagePath: string,\n  remainingTime: number,\n  initialWaitForMs: number\n): Promise<IPageDataWithQueryResult> {\n  if (remainingTime > 0) {\n    return new Promise(resolve => {\n      emitter.on(`CLEAR_PENDING_PAGE_DATA_WRITE`, listener)\n\n      const timeout = setTimeout((): void => {\n        emitter.off(`CLEAR_PENDING_PAGE_DATA_WRITE`, listener)\n        resolve(\n          doGetPageData(\n            pagePath,\n            Math.max(remainingTime - RETRY_INTERVAL, 0),\n            initialWaitForMs\n          )\n        )\n      }, Math.min(RETRY_INTERVAL, remainingTime))\n\n      function listener(data: IClearPendingPageDataWriteAction): void {\n        if (data.payload.page === pagePath) {\n          clearTimeout(timeout)\n          emitter.off(`CLEAR_PENDING_PAGE_DATA_WRITE`, listener)\n          // page-data was flushed, but we don't know if query wasn't marked as stale in meantime\n          // so we call `doGetPageData` again that will make checks and wait for fresh result\n          // or resolve immediately if it's not stale.\n          // Remaining time change is not actually \"correct\", but timeout overall is meant to ensure\n          // we do resolve (or reject) eventually, it doesn't have to be 100% correct - we do decrease\n          // it slightly to not end up in infinite loop situations.\n          // We also need to delay calling `doGetPageData` because it can cause adding another `CLEAR_PENDING_PAGE_DATA_WRITE`\n          // callback in same tick and `mett` will run this callback (because it will happen before current callback finishes\n          // and `mett` doesn't guarantee it will only run callbacks registered before message was emitted)\n          process.nextTick(() =>\n            resolve(\n              doGetPageData(\n                pagePath,\n                Math.max(remainingTime - RETRY_INTERVAL / 5, 0),\n                initialWaitForMs\n              )\n            )\n          )\n        }\n      }\n    })\n  } else {\n    // not ideal ... but try to push results we might have (stale)\n    // or fail/reject\n    return readPageData(pagePath).catch(() => {\n      throw new Error(\n        `Couldn't get query results for \"${pagePath}\" in ${(\n          initialWaitForMs / 1000\n        ).toFixed(3)}s.`\n      )\n    })\n  }\n}\n\nasync function readPageData(pagePath): Promise<IPageDataWithQueryResult> {\n  const { program } = store.getState()\n\n  try {\n    return await readPageDataUtil(\n      path.join(program.directory, `public`),\n      pagePath\n    )\n  } catch (err) {\n    throw new Error(\n      `Error loading a result for the page query in \"${pagePath}\". Query was not run and no cached result was found.`\n    )\n  }\n}\n"],"mappings":"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"}