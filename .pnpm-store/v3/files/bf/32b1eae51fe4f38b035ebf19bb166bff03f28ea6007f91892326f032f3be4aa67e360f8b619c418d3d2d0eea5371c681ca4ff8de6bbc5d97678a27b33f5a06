{"version":3,"file":"schema.js","names":["_","require","invariant","isSpecifiedScalarType","isIntrospectionType","assertValidName","GraphQLNonNull","GraphQLList","GraphQLObjectType","GraphQLInterfaceType","GraphQLUnionType","ObjectTypeComposer","InterfaceTypeComposer","UnionTypeComposer","InputTypeComposer","ScalarTypeComposer","EnumTypeComposer","getDataStore","getNode","getNodesByType","apiRunner","report","addNodeInterfaceFields","overridableBuiltInTypeNames","builtInScalarTypeNames","addInferredTypes","addRemoteFileInterfaceFields","findOne","findManyPaginated","wrappingResolver","defaultResolver","processFieldExtensions","internalExtensionNames","isASTDocument","parseTypeDef","reportParsingError","printTypeDefinitions","buildSchema","schemaComposer","types","typeMapping","fieldExtensions","thirdPartySchemas","printConfig","enginePrintConfig","typeConflictReporter","inferenceMetadata","parentSpan","ready","updateSchemaComposer","schema","freezeTypeComposers","module","exports","excluded","Set","Array","from","values","forEach","tc","isCompositeTC","has","getTypeName","type","getType","activity","phantomActivity","start","addTypes","span","end","addInferredChildOfExtensions","process","env","GATSBY_SKIP_WRITING_SCHEMA_TO_FILE","config","addSetFieldsOnGraphQLNodeTypeFields","addConvenienceChildrenFields","Promise","all","map","typeComposer","processTypeComposer","checkQueryableInterfaces","addThirdPartySchemas","addCustomResolveFunctions","attachTracingResolver","hasInterface","determineSearchableFields","addTypeToRootQuery","isNodeInterface","fieldNames","query","typeName","camelCase","queryAll","convenienceChild","convenienceChildren","typeOrTypeDef","plugin","parsedTypes","createdFrom","parseTypes","doc","error","processAddedType","isGatsbyType","createTypeComposerFromGatsbyType","checkIsAllowedTypeName","get","mergeTypes","name","typeOwner","getExtension","isOverridableBuiltInType","isSafeMerge","hasExtension","warn","mergeFields","fields","getFields","getInterfaces","iface","addInterface","mergeResolveType","extensions","isNamedTypeComposer","convertDirectivesToExtensions","getDirectives","extendExtensions","getExtensions","addExtensions","add","getResolveType","setResolveType","node","internal","addSchemaMustHaveType","directives","args","setExtension","hasCorrectIdField","hasField","getFieldType","toString","panic","getFieldNames","fieldName","setFieldExtension","getFieldDirectives","getFieldExtensions","Object","keys","filter","includes","definition","getDirective","defaultValue","undefined","arg","argumentDef","find","value","validate","message","endsWith","kind","GatsbyGraphQLTypeKind","OBJECT","createTemp","typeMapper","convertOutputFieldConfigMap","interfaces","tmpComposer","createInterfaceTC","getIFTC","INPUT_OBJECT","convertInputFieldConfigMap","UNION","createObjectTC","getOTC","INTERFACE","ENUM","SCALAR","JSON","stringify","result","nodes","traceId","addNestedFields","schemaQueryType","getQueryType","queryTC","createTempTC","processThirdPartyTypeFields","Query","addFields","getTypeMap","typeHasFields","_fields","createTC","resetOverriddenThirdPartyTypeFields","getFieldExtension","removeField","fieldType","String","replace","extendField","intermediateSchema","createResolvers","resolvers","ignoreNonexistentTypes","fieldConfig","originalFieldConfig","getFieldConfig","originalTypeName","originalResolver","resolve","fieldTypeName","isArray","stringifyArray","newConfig","source","context","info","defaultFieldResolver","extendFieldExtensions","needsResolve","field","getField","resolver","dateformat","searchable","SEARCHABLE_ENUM","SEARCHABLE","sortable","SORTABLE_ENUM","SORTABLE","proxy","isEmpty","DEPRECATED_SEARCHABLE","DEPRECATED_SORTABLE","parentTypesToChildren","Map","mimeTypesToChildren","typesHandlingMimeTypes","mimeType","set","mimeTypes","parentType","children","parent","getAnyTC","child","createChildrenField","createChildField","parentTypes","isExplicitChild","childTypeComposer","childOfExtension","parentMimeTypes","some","addInferredChildOfExtension","shouldInfer","parentTypeName","childNodeTypes","iterateNodesByType","childNode","push","description","path","nodeModel","getNodesByIds","ids","length","filterInputTC","getFilterInput","paginationTC","getPagination","queryName","queryNamePlural","sort","getSortInputNestedObjects","getSortInput","skip","limit","makeFieldNonNull","definitions","def","parsedType","makeSchemaDef","ifaceName","_gqType","delete","arr","item","Error","ofType","v","parseValue","interfaceTypeComposer","queryableInterfaces","incorrectTypes","size","t","join","entries","setField","resolveType"],"sources":["../../src/schema/schema.js"],"sourcesContent":["const _ = require(`lodash`)\nconst invariant = require(`invariant`)\nconst {\n  isSpecifiedScalarType,\n  isIntrospectionType,\n  assertValidName,\n  GraphQLNonNull,\n  GraphQLList,\n  GraphQLObjectType,\n  GraphQLInterfaceType,\n  GraphQLUnionType,\n} = require(`graphql`)\nconst {\n  ObjectTypeComposer,\n  InterfaceTypeComposer,\n  UnionTypeComposer,\n  InputTypeComposer,\n  ScalarTypeComposer,\n  EnumTypeComposer,\n} = require(`graphql-compose`)\nconst { getDataStore, getNode, getNodesByType } = require(`../datastore`)\n\nconst apiRunner = require(`../utils/api-runner-node`)\nconst report = require(`gatsby-cli/lib/reporter`)\nconst { addNodeInterfaceFields } = require(`./types/node-interface`)\nconst {\n  overridableBuiltInTypeNames,\n  builtInScalarTypeNames,\n} = require(`./types/built-in-types`)\nconst { addInferredTypes } = require(`./infer`)\nconst {\n  addRemoteFileInterfaceFields,\n} = require(`./types/remote-file-interface`)\n\nconst {\n  findOne,\n  findManyPaginated,\n  wrappingResolver,\n  defaultResolver,\n} = require(`./resolvers`)\nconst {\n  processFieldExtensions,\n  internalExtensionNames,\n} = require(`./extensions`)\nimport { getPagination } from \"./types/pagination\"\nimport {\n  SORTABLE_ENUM,\n  getSortInput,\n  getSortInputNestedObjects,\n} from \"./types/sort\"\nimport { getFilterInput, SEARCHABLE_ENUM } from \"./types/filter\"\nimport { isGatsbyType, GatsbyGraphQLTypeKind } from \"./types/type-builders\"\n\nconst {\n  isASTDocument,\n  parseTypeDef,\n  reportParsingError,\n} = require(`./types/type-defs`)\nconst { printTypeDefinitions } = require(`./print`)\n\nconst buildSchema = async ({\n  schemaComposer,\n  types,\n  typeMapping,\n  fieldExtensions,\n  thirdPartySchemas,\n  printConfig,\n  enginePrintConfig,\n  typeConflictReporter,\n  inferenceMetadata,\n  parentSpan,\n}) => {\n  // FIXME: consider removing .ready here - it is needed for various tests to pass (although probably harmless)\n  await getDataStore().ready()\n  await updateSchemaComposer({\n    schemaComposer,\n    types,\n    typeMapping,\n    fieldExtensions,\n    thirdPartySchemas,\n    printConfig,\n    enginePrintConfig,\n    typeConflictReporter,\n    inferenceMetadata,\n    parentSpan,\n  })\n  // const { printSchema } = require(`graphql`)\n  const schema = schemaComposer.buildSchema()\n  freezeTypeComposers(schemaComposer)\n\n  // console.log(printSchema(schema))\n  return schema\n}\n\nmodule.exports = {\n  buildSchema,\n}\n\n// Workaround for https://github.com/graphql-compose/graphql-compose/issues/319\n//  FIXME: remove this when fixed in graphql-compose\nconst freezeTypeComposers = (schemaComposer, excluded = new Set()) => {\n  Array.from(schemaComposer.values()).forEach(tc => {\n    const isCompositeTC =\n      tc instanceof ObjectTypeComposer || tc instanceof InterfaceTypeComposer\n\n    if (isCompositeTC && !excluded.has(tc.getTypeName())) {\n      // typeComposer.getType() actually mutates the underlying GraphQL type\n      //   and always re-assigns type._fields with a thunk.\n      //   It causes continuous redundant field re-definitions when running queries\n      //   (affects performance significantly).\n      //   Prevent the mutation and \"freeze\" the type:\n      const type = tc.getType()\n      tc.getType = () => type\n    }\n  })\n}\n\nconst updateSchemaComposer = async ({\n  schemaComposer,\n  types,\n  typeMapping,\n  fieldExtensions,\n  thirdPartySchemas,\n  printConfig,\n  enginePrintConfig,\n  typeConflictReporter,\n  inferenceMetadata,\n  parentSpan,\n}) => {\n  let activity = report.phantomActivity(`Add explicit types`, {\n    parentSpan: parentSpan,\n  })\n  activity.start()\n  await addTypes({ schemaComposer, parentSpan: activity.span, types })\n  activity.end()\n\n  activity = report.phantomActivity(`Add inferred types`, {\n    parentSpan: parentSpan,\n  })\n  activity.start()\n  await addInferredTypes({\n    schemaComposer,\n    typeConflictReporter,\n    typeMapping,\n    inferenceMetadata,\n    parentSpan: activity.span,\n  })\n  addInferredChildOfExtensions({\n    schemaComposer,\n  })\n  activity.end()\n\n  activity = report.phantomActivity(`Processing types`, {\n    parentSpan: parentSpan,\n  })\n  activity.start()\n  if (!process.env.GATSBY_SKIP_WRITING_SCHEMA_TO_FILE) {\n    await printTypeDefinitions({\n      config: printConfig,\n      schemaComposer,\n      parentSpan: activity.span,\n    })\n    if (enginePrintConfig) {\n      // make sure to print schema that will be used when bundling graphql-engine\n      await printTypeDefinitions({\n        config: enginePrintConfig,\n        schemaComposer,\n        parentSpan: activity.span,\n      })\n    }\n  }\n  await addSetFieldsOnGraphQLNodeTypeFields({\n    schemaComposer,\n    parentSpan: activity.span,\n  })\n  await addConvenienceChildrenFields({\n    schemaComposer,\n    parentSpan: activity.span,\n  })\n  await Promise.all(\n    Array.from(new Set(schemaComposer.values())).map(typeComposer =>\n      processTypeComposer({\n        schemaComposer,\n        typeComposer,\n        fieldExtensions,\n        parentSpan: activity.span,\n      })\n    )\n  )\n  checkQueryableInterfaces({ schemaComposer, parentSpan: activity.span })\n  await addThirdPartySchemas({\n    schemaComposer,\n    thirdPartySchemas,\n    parentSpan: activity.span,\n  })\n  await addCustomResolveFunctions({ schemaComposer, parentSpan: activity.span })\n  attachTracingResolver({ schemaComposer, parentSpan: activity.span })\n  activity.end()\n}\n\nconst processTypeComposer = async ({\n  schemaComposer,\n  typeComposer,\n  fieldExtensions,\n  parentSpan,\n}) => {\n  if (typeComposer instanceof ObjectTypeComposer) {\n    await processFieldExtensions({\n      schemaComposer,\n      typeComposer,\n      fieldExtensions,\n      parentSpan,\n    })\n\n    if (typeComposer.hasInterface(`Node`)) {\n      await addNodeInterfaceFields({ schemaComposer, typeComposer })\n    }\n\n    if (typeComposer.hasInterface(`RemoteFile`)) {\n      addRemoteFileInterfaceFields(schemaComposer, typeComposer)\n    }\n\n    await determineSearchableFields({\n      schemaComposer,\n      typeComposer,\n      parentSpan,\n    })\n\n    if (typeComposer.hasInterface(`Node`)) {\n      await addTypeToRootQuery({ schemaComposer, typeComposer, parentSpan })\n    }\n  } else if (typeComposer instanceof InterfaceTypeComposer) {\n    if (isNodeInterface(typeComposer)) {\n      await addNodeInterfaceFields({ schemaComposer, typeComposer, parentSpan })\n\n      // We only process field extensions for queryable Node interfaces, so we get\n      // the input args on the root query type, e.g. `formatString` etc. for `dateformat`\n      await processFieldExtensions({\n        schemaComposer,\n        typeComposer,\n        fieldExtensions,\n        parentSpan,\n      })\n      await determineSearchableFields({\n        schemaComposer,\n        typeComposer,\n        parentSpan,\n      })\n      await addTypeToRootQuery({ schemaComposer, typeComposer, parentSpan })\n    }\n  }\n}\n\nconst fieldNames = {\n  query: typeName => _.camelCase(typeName),\n  queryAll: typeName => _.camelCase(`all ${typeName}`),\n  convenienceChild: typeName => _.camelCase(`child ${typeName}`),\n  convenienceChildren: typeName => _.camelCase(`children ${typeName}`),\n}\n\nconst addTypes = ({ schemaComposer, types, parentSpan }) => {\n  types.forEach(({ typeOrTypeDef, plugin }) => {\n    if (typeof typeOrTypeDef === `string`) {\n      typeOrTypeDef = parseTypeDef(typeOrTypeDef)\n    }\n\n    if (isASTDocument(typeOrTypeDef)) {\n      let parsedTypes\n      const createdFrom = `sdl`\n      try {\n        parsedTypes = parseTypes({\n          doc: typeOrTypeDef,\n          plugin,\n          createdFrom,\n          schemaComposer,\n          parentSpan,\n        })\n      } catch (error) {\n        reportParsingError(error)\n        return\n      }\n      parsedTypes.forEach(type => {\n        processAddedType({\n          schemaComposer,\n          type,\n          parentSpan,\n          createdFrom,\n          plugin,\n        })\n      })\n    } else if (isGatsbyType(typeOrTypeDef)) {\n      const type = createTypeComposerFromGatsbyType({\n        schemaComposer,\n        type: typeOrTypeDef,\n        parentSpan,\n      })\n\n      if (type) {\n        const typeName = type.getTypeName()\n        const createdFrom = `typeBuilder`\n        checkIsAllowedTypeName(typeName)\n        if (schemaComposer.has(typeName)) {\n          const typeComposer = schemaComposer.get(typeName)\n          mergeTypes({\n            schemaComposer,\n            typeComposer,\n            type,\n            plugin,\n            createdFrom,\n            parentSpan,\n          })\n        } else {\n          processAddedType({\n            schemaComposer,\n            type,\n            parentSpan,\n            createdFrom,\n            plugin,\n          })\n        }\n      }\n    } else {\n      const typeName = typeOrTypeDef.name\n      const createdFrom = `graphql-js`\n      checkIsAllowedTypeName(typeName)\n      if (schemaComposer.has(typeName)) {\n        const typeComposer = schemaComposer.get(typeName)\n        mergeTypes({\n          schemaComposer,\n          typeComposer,\n          type: typeOrTypeDef,\n          plugin,\n          createdFrom,\n          parentSpan,\n        })\n      } else {\n        processAddedType({\n          schemaComposer,\n          type: typeOrTypeDef,\n          parentSpan,\n          createdFrom,\n          plugin,\n        })\n      }\n    }\n  })\n}\n\nconst mergeTypes = ({\n  schemaComposer,\n  typeComposer,\n  type,\n  plugin,\n  createdFrom,\n  parentSpan,\n}) => {\n  // The merge is considered safe when a user or a plugin owning the type extend this type\n  // TODO: add proper conflicts detection and reporting (on the field level)\n  const typeOwner = typeComposer.getExtension(`plugin`)\n  const isOverridableBuiltInType =\n    !typeOwner && overridableBuiltInTypeNames.has(typeComposer.getTypeName())\n\n  const isSafeMerge =\n    !plugin ||\n    plugin.name === `default-site-plugin` ||\n    plugin.name === typeOwner ||\n    typeComposer.hasExtension(`isPlaceholder`) ||\n    isOverridableBuiltInType\n\n  if (!isSafeMerge) {\n    if (typeOwner) {\n      report.warn(\n        `Plugin \\`${plugin.name}\\` has customized the GraphQL type ` +\n          `\\`${typeComposer.getTypeName()}\\`, which has already been defined ` +\n          `by the plugin \\`${typeOwner}\\`. ` +\n          `This could potentially cause conflicts.`\n      )\n    } else {\n      report.warn(\n        `Plugin \\`${plugin.name}\\` has customized the built-in Gatsby GraphQL type ` +\n          `\\`${typeComposer.getTypeName()}\\`. ` +\n          `This is allowed, but could potentially cause conflicts.`\n      )\n    }\n  }\n\n  if (\n    type instanceof ObjectTypeComposer ||\n    type instanceof InterfaceTypeComposer ||\n    type instanceof GraphQLObjectType ||\n    type instanceof GraphQLInterfaceType\n  ) {\n    mergeFields({ typeComposer, fields: type.getFields() })\n    type.getInterfaces().forEach(iface => typeComposer.addInterface(iface))\n  }\n\n  if (\n    type instanceof GraphQLInterfaceType ||\n    type instanceof InterfaceTypeComposer ||\n    type instanceof GraphQLUnionType ||\n    type instanceof UnionTypeComposer\n  ) {\n    mergeResolveType({ typeComposer, type })\n  }\n\n  let extensions = {}\n  if (isNamedTypeComposer(type)) {\n    if (createdFrom === `sdl`) {\n      extensions = convertDirectivesToExtensions(type, type.getDirectives())\n    } else {\n      typeComposer.extendExtensions(type.getExtensions())\n    }\n  }\n\n  addExtensions({\n    schemaComposer,\n    typeComposer,\n    extensions,\n    plugin,\n    createdFrom,\n  })\n\n  return true\n}\n\nconst processAddedType = ({\n  schemaComposer,\n  type,\n  parentSpan,\n  createdFrom,\n  plugin,\n}) => {\n  const typeName = schemaComposer.add(type)\n  const typeComposer = schemaComposer.get(typeName)\n  if (\n    typeComposer instanceof InterfaceTypeComposer ||\n    typeComposer instanceof UnionTypeComposer\n  ) {\n    if (!typeComposer.getResolveType()) {\n      typeComposer.setResolveType(node => node.internal.type)\n    }\n  }\n  schemaComposer.addSchemaMustHaveType(typeComposer)\n  let extensions = {}\n  if (createdFrom === `sdl`) {\n    extensions = convertDirectivesToExtensions(\n      typeComposer,\n      typeComposer.getDirectives()\n    )\n  }\n\n  addExtensions({\n    schemaComposer,\n    typeComposer,\n    extensions,\n    plugin,\n    createdFrom,\n  })\n\n  return typeComposer\n}\n\n/**\n * @param {import(\"graphql-compose\").AnyTypeComposer} typeComposer\n * @param {Array<import(\"graphql-compose\").Directive>} directives\n * @return {{infer?: boolean, mimeTypes?: { types: Array<string> }, childOf?: { types: Array<string> }, nodeInterface?: boolean}}\n */\nconst convertDirectivesToExtensions = (typeComposer, directives) => {\n  const extensions = {}\n  directives.forEach(({ name, args }) => {\n    switch (name) {\n      case `infer`:\n      case `dontInfer`: {\n        extensions[`infer`] = name === `infer`\n        break\n      }\n      case `mimeTypes`:\n        extensions[`mimeTypes`] = args\n        break\n      case `childOf`:\n        extensions[`childOf`] = args\n        break\n      case `nodeInterface`:\n        if (typeComposer instanceof InterfaceTypeComposer) {\n          extensions[`nodeInterface`] = true\n        }\n        break\n      default:\n    }\n  })\n\n  return extensions\n}\n\nconst addExtensions = ({\n  schemaComposer,\n  typeComposer,\n  extensions = {},\n  plugin,\n  createdFrom,\n}) => {\n  typeComposer.setExtension(`createdFrom`, createdFrom)\n  typeComposer.setExtension(`plugin`, plugin ? plugin.name : null)\n  typeComposer.extendExtensions(extensions)\n\n  if (\n    typeComposer instanceof InterfaceTypeComposer &&\n    isNodeInterface(typeComposer)\n  ) {\n    const hasCorrectIdField =\n      typeComposer.hasField(`id`) &&\n      typeComposer.getFieldType(`id`).toString() === `ID!`\n\n    if (!hasCorrectIdField) {\n      report.panic(\n        `Interfaces with the \\`nodeInterface\\` extension must have a field ` +\n          `\\`id\\` of type \\`ID!\\`. Check the type definition of ` +\n          `\\`${typeComposer.getTypeName()}\\`.`\n      )\n    }\n  }\n\n  if (\n    typeComposer instanceof ObjectTypeComposer ||\n    typeComposer instanceof InterfaceTypeComposer ||\n    typeComposer instanceof InputTypeComposer\n  ) {\n    typeComposer.getFieldNames().forEach(fieldName => {\n      typeComposer.setFieldExtension(fieldName, `createdFrom`, createdFrom)\n      typeComposer.setFieldExtension(\n        fieldName,\n        `plugin`,\n        plugin ? plugin.name : null\n      )\n\n      if (createdFrom === `sdl`) {\n        const directives = typeComposer.getFieldDirectives(fieldName)\n        directives.forEach(({ name, args }) => {\n          typeComposer.setFieldExtension(fieldName, name, args)\n        })\n      }\n\n      // Validate field extension args. `graphql-compose` already checks the\n      // type of directive args in `parseDirectives`, but we want to check\n      // extensions provided with type builders as well. Also, we warn if an\n      // extension option was provided which does not exist in the field\n      // extension definition.\n      const fieldExtensions = typeComposer.getFieldExtensions(fieldName)\n      const typeName = typeComposer.getTypeName()\n      Object.keys(fieldExtensions)\n        .filter(name => !internalExtensionNames.includes(name))\n        .forEach(name => {\n          const args = fieldExtensions[name]\n\n          if (!args || typeof args !== `object`) {\n            report.error(\n              `Field extension arguments must be provided as an object. ` +\n                `Received \"${args}\" on \\`${typeName}.${fieldName}\\`.`\n            )\n            return\n          }\n\n          try {\n            const definition = schemaComposer.getDirective(name)\n\n            // Handle `defaultValue` when not provided as directive\n            definition.args.forEach(({ name, defaultValue }) => {\n              if (args[name] === undefined && defaultValue !== undefined) {\n                args[name] = defaultValue\n              }\n            })\n\n            Object.keys(args).forEach(arg => {\n              const argumentDef = definition.args.find(\n                ({ name }) => name === arg\n              )\n              if (!argumentDef) {\n                report.error(\n                  `Field extension \\`${name}\\` on \\`${typeName}.${fieldName}\\` ` +\n                    `has invalid argument \\`${arg}\\`.`\n                )\n                return\n              }\n              const value = args[arg]\n              try {\n                validate(argumentDef.type, value)\n              } catch (error) {\n                report.error(\n                  `Field extension \\`${name}\\` on \\`${typeName}.${fieldName}\\` ` +\n                    `has argument \\`${arg}\\` with invalid value \"${value}\". ` +\n                    error.message\n                )\n              }\n            })\n          } catch (error) {\n            report.error(\n              `Field extension \\`${name}\\` on \\`${typeName}.${fieldName}\\` ` +\n                `is not available.`\n            )\n          }\n        })\n    })\n  }\n\n  return typeComposer\n}\n\nconst checkIsAllowedTypeName = name => {\n  invariant(\n    name !== `Node`,\n    `The GraphQL type \\`Node\\` is reserved for internal use.`\n  )\n  invariant(\n    !name.endsWith(`FilterInput`) && !name.endsWith(`SortInput`),\n    `GraphQL type names ending with \"FilterInput\" or \"SortInput\" are ` +\n      `reserved for internal use. Please rename \\`${name}\\`.`\n  )\n  invariant(\n    !builtInScalarTypeNames.includes(name),\n    `The GraphQL type \\`${name}\\` is reserved for internal use by ` +\n      `built-in scalar types.`\n  )\n  assertValidName(name)\n}\n\nconst createTypeComposerFromGatsbyType = ({\n  schemaComposer,\n  type,\n  parentSpan,\n}) => {\n  let typeComposer\n  switch (type.kind) {\n    case GatsbyGraphQLTypeKind.OBJECT: {\n      typeComposer = ObjectTypeComposer.createTemp({\n        ...type.config,\n        fields: () =>\n          schemaComposer.typeMapper.convertOutputFieldConfigMap(\n            type.config.fields\n          ),\n        interfaces: () => {\n          if (type.config.interfaces) {\n            return type.config.interfaces.map(iface => {\n              if (typeof iface === `string`) {\n                // Sadly, graphql-compose runs this function too early - before we have\n                // all of those interfaces actually created in the schema, so have to create\n                // a temporary placeholder composer :/\n                if (!schemaComposer.has(iface)) {\n                  const tmpComposer = schemaComposer.createInterfaceTC(iface)\n                  tmpComposer.setExtension(`isPlaceholder`, true)\n                  return tmpComposer\n                }\n                return schemaComposer.getIFTC(iface)\n              } else {\n                return iface\n              }\n            })\n          } else {\n            return []\n          }\n        },\n      })\n      break\n    }\n    case GatsbyGraphQLTypeKind.INPUT_OBJECT: {\n      typeComposer = InputTypeComposer.createTemp({\n        ...type.config,\n        fields: schemaComposer.typeMapper.convertInputFieldConfigMap(\n          type.config.fields\n        ),\n      })\n      break\n    }\n    case GatsbyGraphQLTypeKind.UNION: {\n      typeComposer = UnionTypeComposer.createTemp({\n        ...type.config,\n        types: () => {\n          if (type.config.types) {\n            return type.config.types.map(typeName => {\n              if (!schemaComposer.has(typeName)) {\n                // Sadly, graphql-compose runs this function too early - before we have\n                // all of those types actually created in the schema, so have to create\n                // a temporary placeholder composer :/\n                const tmpComposer = schemaComposer.createObjectTC(typeName)\n                tmpComposer.setExtension(`isPlaceholder`, true)\n                return tmpComposer\n              }\n              return schemaComposer.getOTC(typeName)\n            })\n          } else {\n            return []\n          }\n        },\n      })\n      break\n    }\n    case GatsbyGraphQLTypeKind.INTERFACE: {\n      typeComposer = InterfaceTypeComposer.createTemp({\n        ...type.config,\n        fields: () =>\n          schemaComposer.typeMapper.convertOutputFieldConfigMap(\n            type.config.fields\n          ),\n        interfaces: () => {\n          if (type.config.interfaces) {\n            return type.config.interfaces.map(iface => {\n              if (typeof iface === `string`) {\n                // Sadly, graphql-compose runs this function too early - before we have\n                // all of those interfaces actually created in the schema, so have to create\n                // a temporary placeholder composer :/\n                if (!schemaComposer.has(iface)) {\n                  const tmpComposer = schemaComposer.createInterfaceTC(iface)\n                  tmpComposer.setExtension(`isPlaceholder`, true)\n                  return tmpComposer\n                }\n                return schemaComposer.getIFTC(iface)\n              } else {\n                return iface\n              }\n            })\n          } else {\n            return []\n          }\n        },\n      })\n      break\n    }\n    case GatsbyGraphQLTypeKind.ENUM: {\n      typeComposer = EnumTypeComposer.createTemp(type.config)\n      break\n    }\n    case GatsbyGraphQLTypeKind.SCALAR: {\n      typeComposer = ScalarTypeComposer.createTemp(type.config)\n      break\n    }\n    default: {\n      report.warn(`Illegal type definition: ${JSON.stringify(type.config)}`)\n      typeComposer = null\n    }\n  }\n  if (typeComposer) {\n    // Workaround for https://github.com/graphql-compose/graphql-compose/issues/311\n    typeComposer.schemaComposer = schemaComposer\n  }\n  return typeComposer\n}\n\nconst addSetFieldsOnGraphQLNodeTypeFields = ({ schemaComposer, parentSpan }) =>\n  Promise.all(\n    Array.from(schemaComposer.values()).map(async tc => {\n      if (tc instanceof ObjectTypeComposer && tc.hasInterface(`Node`)) {\n        const typeName = tc.getTypeName()\n        const result = await apiRunner(`setFieldsOnGraphQLNodeType`, {\n          type: {\n            name: typeName,\n            get nodes() {\n              // TODO STRICT_MODE: return iterator instead of array\n              return getNodesByType(typeName)\n            },\n          },\n          traceId: `initial-setFieldsOnGraphQLNodeType`,\n          parentSpan,\n        })\n        if (result) {\n          // NOTE: `setFieldsOnGraphQLNodeType` only allows setting\n          // nested fields with a path as property name, i.e.\n          // `{ 'frontmatter.published': 'Boolean' }`, but not in the form\n          // `{ frontmatter: { published: 'Boolean' }}`\n          result.forEach(fields => tc.addNestedFields(fields))\n        }\n      }\n    })\n  )\n\nconst addThirdPartySchemas = ({\n  schemaComposer,\n  thirdPartySchemas,\n  parentSpan,\n}) => {\n  thirdPartySchemas.forEach(schema => {\n    const schemaQueryType = schema.getQueryType()\n    const queryTC = schemaComposer.createTempTC(schemaQueryType)\n    processThirdPartyTypeFields({\n      typeComposer: queryTC,\n      type: schemaQueryType,\n      schemaQueryType,\n    })\n    schemaComposer.Query.addFields(queryTC.getFields())\n\n    // Explicitly add the third-party schema's types, so they can be targeted\n    // in `createResolvers` API.\n    const types = schema.getTypeMap()\n    Object.keys(types).forEach(typeName => {\n      const type = types[typeName]\n      if (\n        type !== schemaQueryType &&\n        !isSpecifiedScalarType(type) &&\n        !isIntrospectionType(type) &&\n        type.name !== `Date` &&\n        type.name !== `JSON`\n      ) {\n        const typeHasFields =\n          type instanceof GraphQLObjectType ||\n          type instanceof GraphQLInterfaceType\n\n        // Workaround for an edge case typical for Relay Classic-compatible schemas.\n        // For example, GitHub API contains this piece:\n        //   type Query { relay: Query }\n        // And gatsby-source-graphql transforms it to:\n        //   type Query { github: GitHub }\n        //   type GitHub { relay: Query }\n        // The problem:\n        //   schemaComposer.createTC(type) for type `GitHub` will eagerly create type composers\n        //   for all fields (including `relay` and it's type: `Query` of the third-party schema)\n        //   This unexpected `Query` composer messes up with our own Query type composer and produces duplicate types.\n        //   The workaround is to make sure fields of the GitHub type are lazy and are evaluated only when\n        //   this Query type is already replaced with our own root `Query` type (see processThirdPartyTypeFields):\n        if (typeHasFields && typeof type._fields === `object`) {\n          const fields = type._fields\n          type._fields = () => fields\n        }\n        // ^^^ workaround done\n        const typeComposer = schemaComposer.createTC(type)\n        if (typeHasFields) {\n          processThirdPartyTypeFields({\n            typeComposer,\n            type,\n            schemaQueryType,\n          })\n        }\n        typeComposer.setExtension(`createdFrom`, `thirdPartySchema`)\n        schemaComposer.addSchemaMustHaveType(typeComposer)\n      }\n    })\n  })\n}\n\nconst resetOverriddenThirdPartyTypeFields = ({ typeComposer }) => {\n  // The problem: createResolvers API mutates third party schema instance.\n  //   For example it can add a new field referencing a type from our main schema\n  //   Then if we rebuild the schema this old type instance will sneak into\n  //   the new schema and produce the famous error:\n  //   \"Schema must contain uniquely named types but contains multiple types named X\"\n  // This function only affects schema rebuilding pathway.\n  //   It cleans up artifacts created by the `createResolvers` API of the previous build\n  //   so that we return the third party schema to its initial state (hence can safely re-add)\n  // TODO: the right way to fix this would be not to mutate the third party schema in\n  //   the first place. But unfortunately mutation happens in the `graphql-compose`\n  //   and we don't have an easy way to avoid it without major rework\n  typeComposer.getFieldNames().forEach(fieldName => {\n    const createdFrom = typeComposer.getFieldExtension(fieldName, `createdFrom`)\n    if (createdFrom === `createResolvers`) {\n      typeComposer.removeField(fieldName)\n      return\n    }\n    const config = typeComposer.getFieldExtension(\n      fieldName,\n      `originalFieldConfig`\n    )\n    if (config) {\n      typeComposer.removeField(fieldName)\n      typeComposer.addFields({\n        [fieldName]: config,\n      })\n    }\n  })\n}\n\nconst processThirdPartyTypeFields = ({\n  typeComposer,\n  type,\n  schemaQueryType,\n}) => {\n  // Fix for types that refer to Query. Thanks Relay Classic!\n  const fields = type.getFields()\n  Object.keys(fields).forEach(fieldName => {\n    // Remove customization that we could have added via `createResolvers`\n    // to make it work with schema rebuilding\n    const fieldType = String(fields[fieldName].type)\n    if (fieldType.replace(/[[\\]!]/g, ``) === schemaQueryType.name) {\n      typeComposer.extendField(fieldName, {\n        type: fieldType.replace(schemaQueryType.name, `Query`),\n      })\n    }\n  })\n  resetOverriddenThirdPartyTypeFields({ typeComposer })\n}\n\nconst addCustomResolveFunctions = async ({ schemaComposer, parentSpan }) => {\n  const intermediateSchema = schemaComposer.buildSchema()\n  const createResolvers = (\n    resolvers,\n    { ignoreNonexistentTypes = false } = {}\n  ) => {\n    Object.keys(resolvers).forEach(typeName => {\n      const fields = resolvers[typeName]\n      if (schemaComposer.has(typeName)) {\n        const tc = schemaComposer.getOTC(typeName)\n        Object.keys(fields).forEach(fieldName => {\n          const fieldConfig = fields[fieldName]\n          if (tc.hasField(fieldName)) {\n            const originalFieldConfig = tc.getFieldConfig(fieldName)\n            const originalTypeName = originalFieldConfig.type.toString()\n            const originalResolver = originalFieldConfig.resolve\n            let fieldTypeName\n            if (fieldConfig.type) {\n              fieldTypeName = Array.isArray(fieldConfig.type)\n                ? stringifyArray(fieldConfig.type)\n                : fieldConfig.type.toString()\n            }\n\n            if (\n              !fieldTypeName ||\n              fieldTypeName.replace(/!/g, ``) ===\n                originalTypeName.replace(/!/g, ``) ||\n              tc.getExtension(`createdFrom`) === `thirdPartySchema`\n            ) {\n              const newConfig = {}\n              if (fieldConfig.type) {\n                newConfig.type = fieldConfig.type\n              }\n              if (fieldConfig.args) {\n                newConfig.args = fieldConfig.args\n              }\n              if (fieldConfig.resolve) {\n                newConfig.resolve = (source, args, context, info) =>\n                  fieldConfig.resolve(source, args, context, {\n                    ...info,\n                    originalResolver:\n                      originalResolver || context.defaultFieldResolver,\n                  })\n                tc.extendFieldExtensions(fieldName, {\n                  needsResolve: true,\n                })\n              }\n              tc.extendField(fieldName, newConfig)\n\n              // See resetOverriddenThirdPartyTypeFields for explanation\n              if (tc.getExtension(`createdFrom`) === `thirdPartySchema`) {\n                tc.setFieldExtension(\n                  fieldName,\n                  `originalFieldConfig`,\n                  originalFieldConfig\n                )\n              }\n            } else if (fieldTypeName) {\n              report.warn(\n                `\\`createResolvers\\` passed resolvers for field ` +\n                  `\\`${typeName}.${fieldName}\\` with type \\`${fieldTypeName}\\`. ` +\n                  `Such a field with type \\`${originalTypeName}\\` already exists ` +\n                  `on the type. Use \\`createTypes\\` to override type fields.`\n              )\n            }\n          } else {\n            tc.addFields({\n              [fieldName]: fieldConfig,\n            })\n            // See resetOverriddenThirdPartyTypeFields for explanation\n            tc.setFieldExtension(fieldName, `createdFrom`, `createResolvers`)\n          }\n        })\n      } else if (!ignoreNonexistentTypes) {\n        report.warn(\n          `\\`createResolvers\\` passed resolvers for type \\`${typeName}\\` that ` +\n            `doesn't exist in the schema. Use \\`createTypes\\` to add the type ` +\n            `before adding resolvers.`\n        )\n      }\n    })\n  }\n  await apiRunner(`createResolvers`, {\n    intermediateSchema,\n    createResolvers,\n    traceId: `initial-createResolvers`,\n    parentSpan,\n  })\n}\n\nfunction attachTracingResolver({ schemaComposer }) {\n  schemaComposer.forEach(typeComposer => {\n    if (\n      typeComposer instanceof ObjectTypeComposer ||\n      typeComposer instanceof InterfaceTypeComposer\n    ) {\n      typeComposer.getFieldNames().forEach(fieldName => {\n        const field = typeComposer.getField(fieldName)\n        const resolver = wrappingResolver(field.resolve || defaultResolver)\n        typeComposer.extendField(fieldName, {\n          resolve: resolver,\n        })\n      })\n    }\n  })\n}\n\nconst determineSearchableFields = ({ schemaComposer, typeComposer }) => {\n  typeComposer.getFieldNames().forEach(fieldName => {\n    const field = typeComposer.getField(fieldName)\n    const extensions = typeComposer.getFieldExtensions(fieldName)\n    if (field.resolve) {\n      if (extensions.dateformat) {\n        typeComposer.extendFieldExtensions(fieldName, {\n          searchable: SEARCHABLE_ENUM.SEARCHABLE,\n          sortable: SORTABLE_ENUM.SORTABLE,\n          needsResolve: extensions.proxy ? true : false,\n        })\n      } else if (!_.isEmpty(field.args)) {\n        typeComposer.extendFieldExtensions(fieldName, {\n          searchable: SEARCHABLE_ENUM.DEPRECATED_SEARCHABLE,\n          sortable: SORTABLE_ENUM.DEPRECATED_SORTABLE,\n          needsResolve: true,\n        })\n      } else {\n        typeComposer.extendFieldExtensions(fieldName, {\n          searchable: SEARCHABLE_ENUM.SEARCHABLE,\n          sortable: SORTABLE_ENUM.SORTABLE,\n          needsResolve: true,\n        })\n      }\n    } else {\n      typeComposer.extendFieldExtensions(fieldName, {\n        searchable: SEARCHABLE_ENUM.SEARCHABLE,\n        sortable: SORTABLE_ENUM.SORTABLE,\n        needsResolve: false,\n      })\n    }\n  })\n}\n\nconst addConvenienceChildrenFields = ({ schemaComposer }) => {\n  const parentTypesToChildren = new Map()\n  const mimeTypesToChildren = new Map()\n  const typesHandlingMimeTypes = new Map()\n\n  schemaComposer.forEach(type => {\n    if (\n      (type instanceof ObjectTypeComposer ||\n        type instanceof InterfaceTypeComposer) &&\n      type.hasExtension(`mimeTypes`)\n    ) {\n      const { types } = type.getExtension(`mimeTypes`)\n      new Set(types).forEach(mimeType => {\n        if (!typesHandlingMimeTypes.has(mimeType)) {\n          typesHandlingMimeTypes.set(mimeType, new Set())\n        }\n        typesHandlingMimeTypes.get(mimeType).add(type)\n      })\n    }\n\n    if (\n      (type instanceof ObjectTypeComposer ||\n        type instanceof InterfaceTypeComposer) &&\n      type.hasExtension(`childOf`)\n    ) {\n      if (type instanceof ObjectTypeComposer && !type.hasInterface(`Node`)) {\n        report.error(\n          `The \\`childOf\\` extension can only be used on types that implement the \\`Node\\` interface.\\n` +\n            `Check the type definition of \\`${type.getTypeName()}\\`.`\n        )\n        return\n      }\n      if (type instanceof InterfaceTypeComposer && !isNodeInterface(type)) {\n        report.error(\n          `The \\`childOf\\` extension can only be used on types that implement the \\`Node\\` interface.\\n` +\n            `Check the type definition of \\`${type.getTypeName()}\\`.`\n        )\n        return\n      }\n\n      const { types, mimeTypes } = type.getExtension(`childOf`)\n\n      new Set(types).forEach(parentType => {\n        if (!parentTypesToChildren.has(parentType)) {\n          parentTypesToChildren.set(parentType, new Set())\n        }\n        parentTypesToChildren.get(parentType).add(type)\n      })\n      new Set(mimeTypes).forEach(mimeType => {\n        if (!mimeTypesToChildren.has(mimeType)) {\n          mimeTypesToChildren.set(mimeType, new Set())\n        }\n        mimeTypesToChildren.get(mimeType).add(type)\n      })\n    }\n  })\n\n  parentTypesToChildren.forEach((children, parent) => {\n    if (!schemaComposer.has(parent)) return\n    const typeComposer = schemaComposer.getAnyTC(parent)\n    if (\n      typeComposer instanceof InterfaceTypeComposer &&\n      !isNodeInterface(typeComposer)\n    ) {\n      report.error(\n        `With the \\`childOf\\` extension, children fields can only be added to ` +\n          `interfaces which implement the \\`Node\\` interface.\\n` +\n          `Check the type definition of \\`${typeComposer.getTypeName()}\\`.`\n      )\n      return\n    }\n    children.forEach(child => {\n      typeComposer.addFields(createChildrenField(child.getTypeName()))\n      typeComposer.addFields(createChildField(child.getTypeName()))\n    })\n  })\n\n  mimeTypesToChildren.forEach((children, mimeType) => {\n    const parentTypes = typesHandlingMimeTypes.get(mimeType)\n    if (parentTypes) {\n      parentTypes.forEach(typeComposer => {\n        if (\n          typeComposer instanceof InterfaceTypeComposer &&\n          !isNodeInterface(typeComposer)\n        ) {\n          report.error(\n            `With the \\`childOf\\` extension, children fields can only be added to ` +\n              `interfaces which implement the \\`Node\\` interface.\\n` +\n              `Check the type definition of \\`${typeComposer.getTypeName()}\\`.`\n          )\n          return\n        }\n        children.forEach(child => {\n          typeComposer.addFields(createChildrenField(child.getTypeName()))\n          typeComposer.addFields(createChildField(child.getTypeName()))\n        })\n      })\n    }\n  })\n}\n\nconst isExplicitChild = ({ typeComposer, childTypeComposer }) => {\n  if (!childTypeComposer.hasExtension(`childOf`)) {\n    return false\n  }\n  const childOfExtension = childTypeComposer.getExtension(`childOf`)\n  const { types: parentMimeTypes = [] } =\n    typeComposer.getExtension(`mimeTypes`) ?? {}\n\n  return (\n    childOfExtension?.types?.includes(typeComposer.getTypeName()) ||\n    childOfExtension?.mimeTypes?.some(mimeType =>\n      parentMimeTypes.includes(mimeType)\n    )\n  )\n}\n\nconst addInferredChildOfExtensions = ({ schemaComposer }) => {\n  schemaComposer.forEach(typeComposer => {\n    if (\n      typeComposer instanceof ObjectTypeComposer &&\n      typeComposer.hasInterface(`Node`)\n    ) {\n      addInferredChildOfExtension({\n        schemaComposer,\n        typeComposer,\n      })\n    }\n  })\n}\n\nconst addInferredChildOfExtension = ({ schemaComposer, typeComposer }) => {\n  const shouldInfer = typeComposer.getExtension(`infer`)\n  // With `@dontInfer`, only parent-child\n  // relations explicitly set with the `@childOf` extension are added.\n  if (shouldInfer === false) return\n\n  const parentTypeName = typeComposer.getTypeName()\n\n  // This is expensive.\n  // TODO: We should probably collect this info during inference metadata pass\n  const childNodeTypes = new Set()\n  for (const node of getDataStore().iterateNodesByType(parentTypeName)) {\n    const children = (node.children || []).map(getNode)\n    for (const childNode of children) {\n      if (childNode?.internal?.type) {\n        childNodeTypes.add(childNode.internal.type)\n      }\n    }\n  }\n\n  childNodeTypes.forEach(typeName => {\n    const childTypeComposer = schemaComposer.getAnyTC(typeName)\n    let childOfExtension = childTypeComposer.getExtension(`childOf`)\n\n    if (isExplicitChild({ typeComposer, childTypeComposer })) {\n      return\n    }\n    // Set `@childOf` extension automatically\n    // This will cause convenience children fields like `childImageSharp`\n    // to be added in `addConvenienceChildrenFields` method.\n    // Also required for proper printing of the `@childOf` directive in the snapshot plugin\n    if (!childOfExtension) {\n      childOfExtension = {}\n    }\n    if (!childOfExtension.types) {\n      childOfExtension.types = []\n    }\n    childOfExtension.types.push(parentTypeName)\n    childTypeComposer.setExtension(`childOf`, childOfExtension)\n  })\n}\n\nconst createChildrenField = typeName => {\n  return {\n    [fieldNames.convenienceChildren(typeName)]: {\n      type: () => [typeName],\n      description: `Returns all children nodes filtered by type ${typeName}`,\n      resolve(source, args, context) {\n        const { path } = context\n        return context.nodeModel.getNodesByIds(\n          { ids: source.children, type: typeName },\n          { path }\n        )\n      },\n    },\n  }\n}\n\nconst createChildField = typeName => {\n  return {\n    [fieldNames.convenienceChild(typeName)]: {\n      type: () => typeName,\n      description:\n        `Returns the first child node of type ${typeName} ` +\n        `or null if there are no children of given type on this node`,\n      resolve(source, args, context) {\n        const { path } = context\n        const result = context.nodeModel.getNodesByIds(\n          { ids: source.children, type: typeName },\n          { path }\n        )\n        if (result && result.length > 0) {\n          return result[0]\n        } else {\n          return null\n        }\n      },\n    },\n  }\n}\n\nconst addTypeToRootQuery = ({ schemaComposer, typeComposer }) => {\n  const filterInputTC = getFilterInput({\n    schemaComposer,\n    typeComposer,\n  })\n  const paginationTC = getPagination({\n    schemaComposer,\n    typeComposer,\n  })\n\n  const typeName = typeComposer.getTypeName()\n  // not strictly correctly, result is `npmPackage` and `allNpmPackage` from type `NPMPackage`\n  const queryName = fieldNames.query(typeName)\n  const queryNamePlural = fieldNames.queryAll(typeName)\n\n  schemaComposer.Query.addFields({\n    [queryName]: {\n      type: typeComposer,\n      args: {\n        ...filterInputTC.getFields(),\n      },\n      resolve: findOne(typeName),\n    },\n    [queryNamePlural]: {\n      type: paginationTC,\n      args: {\n        filter: filterInputTC,\n        sort:\n          _CFLAGS_.GATSBY_MAJOR === `5`\n            ? getSortInputNestedObjects({ schemaComposer, typeComposer })\n            : getSortInput({\n                schemaComposer,\n                typeComposer,\n              }),\n\n        skip: `Int`,\n        limit: `Int`,\n      },\n      resolve: findManyPaginated(typeName),\n    },\n  }).makeFieldNonNull(queryNamePlural)\n}\n\nconst parseTypes = ({\n  doc,\n  plugin,\n  createdFrom,\n  schemaComposer,\n  parentSpan,\n}) => {\n  const types = []\n  doc.definitions.forEach(def => {\n    const name = def.name.value\n    checkIsAllowedTypeName(name)\n\n    if (schemaComposer.has(name)) {\n      // We don't check if ast.kind matches composer type, but rely\n      // that this will throw when something is wrong and get\n      // reported by `reportParsingError`.\n\n      // Keep the original type composer around\n      const typeComposer = schemaComposer.get(name)\n\n      // After this, the parsed type composer will be registered as the composer\n      // handling the type name (requires cleanup after merging, see below)\n      const parsedType = schemaComposer.typeMapper.makeSchemaDef(def)\n\n      // Merging types require implemented interfaces to already exist.\n      // Depending on type creation order, interface might have not been\n      // processed yet. We check if interface already exist and create\n      // placeholder for it, if it doesn't exist yet.\n      if (parsedType.getInterfaces) {\n        parsedType.getInterfaces().forEach(iface => {\n          const ifaceName = iface.getTypeName()\n          if (!schemaComposer.has(ifaceName)) {\n            const tmpComposer = schemaComposer.createInterfaceTC(ifaceName)\n            tmpComposer.setExtension(`isPlaceholder`, true)\n          }\n        })\n      }\n\n      // Merge the parsed type with the original\n      mergeTypes({\n        schemaComposer,\n        typeComposer,\n        type: parsedType,\n        plugin,\n        createdFrom,\n        parentSpan,\n      })\n\n      // Cleanup:\n      // Set the original type composer (with the merged fields added)\n      // as the correct composer for the type name and remove the temporary one\n      // `graphql-compose` doesn't make that easy ðŸ¤¯\n      // TODO: clean this up when this issue is fixed:\n      //  https://github.com/graphql-compose/graphql-compose/issues/311\n      schemaComposer.set(typeComposer.getTypeName(), typeComposer)\n      schemaComposer.set(typeComposer._gqType, typeComposer)\n      schemaComposer.delete(parsedType._gqType)\n      schemaComposer.delete(parsedType)\n    } else {\n      const parsedType = schemaComposer.typeMapper.makeSchemaDef(def)\n      types.push(parsedType)\n    }\n  })\n  return types\n}\n\nconst stringifyArray = arr =>\n  `[${arr.map(item =>\n    Array.isArray(item) ? stringifyArray(item) : item.toString()\n  )}]`\n\n// TODO: Import this directly from graphql-compose once we update to v7\nconst isNamedTypeComposer = type =>\n  type instanceof ObjectTypeComposer ||\n  type instanceof InputTypeComposer ||\n  type instanceof ScalarTypeComposer ||\n  type instanceof EnumTypeComposer ||\n  type instanceof InterfaceTypeComposer ||\n  type instanceof UnionTypeComposer\n\nconst validate = (type, value) => {\n  if (type instanceof GraphQLNonNull) {\n    if (value == null) {\n      throw new Error(`Expected non-null field value.`)\n    }\n    return validate(type.ofType, value)\n  } else if (type instanceof GraphQLList) {\n    if (!Array.isArray(value)) {\n      throw new Error(`Expected array field value.`)\n    }\n    return value.map(v => validate(type.ofType, v))\n  } else {\n    return type.parseValue(value)\n  }\n}\n\nconst isNodeInterface = interfaceTypeComposer =>\n  interfaceTypeComposer.hasInterface(`Node`)\n\nconst checkQueryableInterfaces = ({ schemaComposer }) => {\n  const queryableInterfaces = new Set()\n  schemaComposer.forEach(type => {\n    if (type instanceof InterfaceTypeComposer && isNodeInterface(type)) {\n      queryableInterfaces.add(type.getTypeName())\n    }\n  })\n  const incorrectTypes = new Set()\n  schemaComposer.forEach(type => {\n    if (type instanceof ObjectTypeComposer) {\n      const interfaces = type.getInterfaces()\n      if (\n        interfaces.some(iface =>\n          queryableInterfaces.has(iface.getTypeName())\n        ) &&\n        !type.hasInterface(`Node`)\n      ) {\n        incorrectTypes.add(type.getTypeName())\n      }\n    }\n  })\n  if (incorrectTypes.size) {\n    report.panic(\n      `Types implementing queryable interfaces must also implement the \\`Node\\` ` +\n        `interface. Check the type definition of ` +\n        `${Array.from(incorrectTypes)\n          .map(t => `\\`${t}\\``)\n          .join(`, `)}.`\n    )\n  }\n}\n\nconst mergeFields = ({ typeComposer, fields }) =>\n  Object.entries(fields).forEach(([fieldName, fieldConfig]) => {\n    if (typeComposer.hasField(fieldName)) {\n      typeComposer.extendField(fieldName, fieldConfig)\n    } else {\n      typeComposer.setField(fieldName, fieldConfig)\n    }\n  })\n\nconst mergeResolveType = ({ typeComposer, type }) => {\n  if (\n    (type instanceof GraphQLInterfaceType ||\n      type instanceof GraphQLUnionType) &&\n    type.resolveType\n  ) {\n    typeComposer.setResolveType(type.resolveType)\n  }\n  if (\n    (type instanceof InterfaceTypeComposer ||\n      type instanceof UnionTypeComposer) &&\n    type.getResolveType()\n  ) {\n    typeComposer.setResolveType(type.getResolveType())\n  }\n  if (!typeComposer.getResolveType()) {\n    typeComposer.setResolveType(node => node?.internal?.type)\n  }\n}\n"],"mappings":"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"}