{"version":3,"file":"derived-types.js","names":["getDerivedTypes","typeComposer","derivedTypes","getExtension","Set","deleteFieldsOfDerivedTypes","getFieldNames","forEach","fieldName","fieldType","getField","type","has","getTypeName","removeField","removeTypeFromSchemaComposer","schemaComposer","delete","_gqType","clearDerivedTypes","typeName","values","derivedTypeComposer","getAnyTC","ObjectTypeComposer","InterfaceTypeComposer","inputTypeComposer","getInputTypeComposer","removeInputTypeComposer","setExtension","addDerivedType","derivedTypeName","add"],"sources":["../../../src/schema/types/derived-types.ts"],"sourcesContent":["/**\n * Derived types are types that make sense only when their base type exists\n *\n * Take this node for example:\n * {\n *   internal: { type: 'Foo' },\n *   fields: {\n *     bar: \"string\",\n *   }\n * }\n *\n * It will produce following types:\n * Foo\n * FooFields\n *\n * FooInputFilter\n * FooSortInput\n *\n * FooFieldsInputFilter\n * FooFieldsSortFilter\n * etc\n *\n * Derived types:\n *   Foo: FooFields, FooInputFilter, FooSortInput\n *   FooFields: FooFieldsInputFilter, FooFieldsSortFilter\n *\n * Caveats:\n *   Only types created via inference are marked as derived. So if in the example above\n *   user explicitly defines `FooFields` type (via `createTypes` call) it won't be considered\n *   a derived type\n */\nimport {\n  ObjectTypeComposer,\n  InterfaceTypeComposer,\n  ScalarTypeComposer,\n  SchemaComposer,\n  InputTypeComposer,\n  EnumTypeComposer,\n  UnionTypeComposer,\n} from \"graphql-compose\"\n\ntype AllTypeComposer =\n  | ObjectTypeComposer\n  | InputTypeComposer\n  | EnumTypeComposer\n  | InterfaceTypeComposer\n  | UnionTypeComposer\n  | ScalarTypeComposer\n\nconst getDerivedTypes = ({\n  typeComposer,\n}: {\n  typeComposer: AllTypeComposer\n}): Set<string> => {\n  const derivedTypes = typeComposer.getExtension(`derivedTypes`)\n  if (derivedTypes) {\n    return derivedTypes as Set<string>\n  }\n\n  return new Set()\n}\n\nexport const deleteFieldsOfDerivedTypes = ({ typeComposer }): void => {\n  const derivedTypes = getDerivedTypes({ typeComposer })\n\n  typeComposer.getFieldNames().forEach(fieldName => {\n    const fieldType = typeComposer.getField(fieldName).type\n\n    if (derivedTypes.has(fieldType.getTypeName())) {\n      typeComposer.removeField(fieldName)\n    }\n  })\n}\n\nconst removeTypeFromSchemaComposer = ({\n  schemaComposer,\n  typeComposer,\n}): void => {\n  schemaComposer.delete(typeComposer.getTypeName())\n  schemaComposer.delete((typeComposer as any)._gqType)\n  schemaComposer.delete(typeComposer)\n}\n\nexport const clearDerivedTypes = ({\n  schemaComposer,\n  typeComposer,\n}: {\n  schemaComposer: SchemaComposer<any>\n  typeComposer: AllTypeComposer\n}): void => {\n  const derivedTypes = getDerivedTypes({ typeComposer })\n\n  for (const typeName of derivedTypes.values()) {\n    const derivedTypeComposer = schemaComposer.getAnyTC(typeName)\n    clearDerivedTypes({ schemaComposer, typeComposer: derivedTypeComposer })\n    removeTypeFromSchemaComposer({\n      schemaComposer,\n      typeComposer: derivedTypeComposer,\n    })\n  }\n\n  if (\n    typeComposer instanceof ObjectTypeComposer ||\n    typeComposer instanceof InterfaceTypeComposer\n  ) {\n    const inputTypeComposer = typeComposer.getInputTypeComposer()\n    removeTypeFromSchemaComposer({\n      schemaComposer,\n      typeComposer: inputTypeComposer,\n    })\n    typeComposer.removeInputTypeComposer()\n  }\n\n  typeComposer.setExtension(`derivedTypes`, new Set())\n}\n\nexport const addDerivedType = ({\n  typeComposer,\n  derivedTypeName,\n}: {\n  typeComposer: AllTypeComposer\n  derivedTypeName: string\n}): void => {\n  const derivedTypes = getDerivedTypes({ typeComposer })\n  typeComposer.setExtension(`derivedTypes`, derivedTypes.add(derivedTypeName))\n}\n"],"mappings":";;;;AA+BA;AA/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAmBA,MAAMA,eAAe,GAAG,CAAC;EACvBC;AAGF,CAAC,KAAkB;EACjB,MAAMC,YAAY,GAAGD,YAAY,CAACE,YAAY,CAAE,cAAa,CAAC;EAC9D,IAAID,YAAY,EAAE;IAChB,OAAOA,YAAY;EACrB;EAEA,OAAO,IAAIE,GAAG,EAAE;AAClB,CAAC;AAEM,MAAMC,0BAA0B,GAAG,CAAC;EAAEJ;AAAa,CAAC,KAAW;EACpE,MAAMC,YAAY,GAAGF,eAAe,CAAC;IAAEC;EAAa,CAAC,CAAC;EAEtDA,YAAY,CAACK,aAAa,EAAE,CAACC,OAAO,CAACC,SAAS,IAAI;IAChD,MAAMC,SAAS,GAAGR,YAAY,CAACS,QAAQ,CAACF,SAAS,CAAC,CAACG,IAAI;IAEvD,IAAIT,YAAY,CAACU,GAAG,CAACH,SAAS,CAACI,WAAW,EAAE,CAAC,EAAE;MAC7CZ,YAAY,CAACa,WAAW,CAACN,SAAS,CAAC;IACrC;EACF,CAAC,CAAC;AACJ,CAAC;AAAA;AAED,MAAMO,4BAA4B,GAAG,CAAC;EACpCC,cAAc;EACdf;AACF,CAAC,KAAW;EACVe,cAAc,CAACC,MAAM,CAAChB,YAAY,CAACY,WAAW,EAAE,CAAC;EACjDG,cAAc,CAACC,MAAM,CAAEhB,YAAY,CAASiB,OAAO,CAAC;EACpDF,cAAc,CAACC,MAAM,CAAChB,YAAY,CAAC;AACrC,CAAC;AAEM,MAAMkB,iBAAiB,GAAG,CAAC;EAChCH,cAAc;EACdf;AAIF,CAAC,KAAW;EACV,MAAMC,YAAY,GAAGF,eAAe,CAAC;IAAEC;EAAa,CAAC,CAAC;EAEtD,KAAK,MAAMmB,QAAQ,IAAIlB,YAAY,CAACmB,MAAM,EAAE,EAAE;IAC5C,MAAMC,mBAAmB,GAAGN,cAAc,CAACO,QAAQ,CAACH,QAAQ,CAAC;IAC7DD,iBAAiB,CAAC;MAAEH,cAAc;MAAEf,YAAY,EAAEqB;IAAoB,CAAC,CAAC;IACxEP,4BAA4B,CAAC;MAC3BC,cAAc;MACdf,YAAY,EAAEqB;IAChB,CAAC,CAAC;EACJ;EAEA,IACErB,YAAY,YAAYuB,kCAAkB,IAC1CvB,YAAY,YAAYwB,qCAAqB,EAC7C;IACA,MAAMC,iBAAiB,GAAGzB,YAAY,CAAC0B,oBAAoB,EAAE;IAC7DZ,4BAA4B,CAAC;MAC3BC,cAAc;MACdf,YAAY,EAAEyB;IAChB,CAAC,CAAC;IACFzB,YAAY,CAAC2B,uBAAuB,EAAE;EACxC;EAEA3B,YAAY,CAAC4B,YAAY,CAAE,cAAa,EAAE,IAAIzB,GAAG,EAAE,CAAC;AACtD,CAAC;AAAA;AAEM,MAAM0B,cAAc,GAAG,CAAC;EAC7B7B,YAAY;EACZ8B;AAIF,CAAC,KAAW;EACV,MAAM7B,YAAY,GAAGF,eAAe,CAAC;IAAEC;EAAa,CAAC,CAAC;EACtDA,YAAY,CAAC4B,YAAY,CAAE,cAAa,EAAE3B,YAAY,CAAC8B,GAAG,CAACD,eAAe,CAAC,CAAC;AAC9E,CAAC;AAAA"}