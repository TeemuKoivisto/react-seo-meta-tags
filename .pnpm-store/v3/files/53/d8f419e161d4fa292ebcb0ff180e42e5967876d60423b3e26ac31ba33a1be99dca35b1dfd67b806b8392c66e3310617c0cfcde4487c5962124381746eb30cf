{"version":3,"file":"error-parser.js","names":["errorParser","message","filePath","undefined","location","error","handlers","regex","cb","match","id","context","sourceMessage","variableName","variableType","inputType","expectedType","fieldName","fieldType","field","type","desc","value","received","variable","operation","Error","structured","matched","locInGraphQlToLocInFile","locationOfGraphQLDocInSourceFile","graphqlLocation","line","start","column"],"sources":["../../src/query/error-parser.ts"],"sourcesContent":["import { IMatch } from \"../types\"\nimport { SourceLocation } from \"graphql\"\n\ninterface IErrorParser {\n  message: string\n  filePath: string | undefined\n  location:\n    | {\n        start: SourceLocation\n        end?: SourceLocation\n      }\n    | undefined\n  error?: Error\n}\n\nconst errorParser = ({\n  message,\n  filePath = undefined,\n  location = undefined,\n  error = undefined,\n}: IErrorParser): IMatch => {\n  // Handle GraphQL errors. A list of regexes to match certain\n  // errors to specific callbacks\n  const handlers = [\n    {\n      regex: /Variable \"(.+)\" of required type \"(.+)\" was not provided\\./m,\n      cb: (match): IMatch => {\n        return {\n          id: `85920`,\n          context: {\n            sourceMessage: match[0],\n            variableName: match[1],\n            variableType: match[2],\n          },\n        }\n      },\n    },\n    {\n      regex:\n        /Variable \"(.+)\" of type \"(.+)\" used in position expecting type \"(.+)\"\\./m,\n      cb: (match): IMatch => {\n        return {\n          id: `85921`,\n          context: {\n            sourceMessage: match[0],\n            variableName: match[1],\n            inputType: match[2],\n            expectedType: match[3],\n          },\n        }\n      },\n    },\n    {\n      regex:\n        /Field \"(.+)\" must not have a selection since type \"(.+)\" has no subfields\\./m,\n      cb: (match): IMatch => {\n        return {\n          id: `85922`,\n          context: {\n            sourceMessage: match[0],\n            fieldName: match[1],\n            fieldType: match[2],\n          },\n        }\n      },\n    },\n    {\n      regex: /Cannot query field \"(.+)\" on type \"(.+)\"\\./m,\n      cb: (match): IMatch => {\n        return {\n          id: `85923`,\n          context: {\n            sourceMessage: match[0],\n            field: match[1],\n            type: match[2],\n          },\n        }\n      },\n    },\n    {\n      regex: /(.+) cannot represent (.+) value: \"(.+)\"/m,\n      cb: (match): IMatch => {\n        return {\n          id: `85924`,\n          context: {\n            sourceMessage: match[0],\n            type: match[1],\n            desc: match[2],\n            value: match[3],\n          },\n        }\n      },\n    },\n    {\n      regex: /Cannot return null for non-nullable field (.+)/m,\n      cb: (match): IMatch => {\n        return {\n          id: `85925`,\n          context: {\n            sourceMessage: match[0],\n            field: match[1],\n          },\n        }\n      },\n    },\n    {\n      regex: /Must provide Source\\. Received: (.+)/m,\n      cb: (match): IMatch => {\n        return {\n          id: `85926`,\n          context: {\n            sourceMessage: match[0],\n            received: match[1],\n          },\n        }\n      },\n    },\n    {\n      regex: /Variable \"(.+)\" is never used in operation \"(.+)\".*/ms,\n      cb: (match): IMatch => {\n        return {\n          id: `85927`,\n          context: {\n            sourceMessage: match[0],\n            variable: match[1],\n            operation: match[2],\n          },\n        }\n      },\n    },\n    // Match anything with a generic catch-all error handler\n    {\n      regex: /[\\s\\S]*/gm,\n      cb: (match): IMatch => {\n        if (error instanceof Error) {\n          return {\n            id: `85901`,\n            error, // show stack trace\n            context: { sourceMessage: match[0] },\n          }\n        } else {\n          return {\n            id: `85901`,\n            context: { sourceMessage: match[0] },\n          }\n        }\n      },\n    },\n  ]\n\n  let structured\n\n  for (const { regex, cb } of handlers) {\n    const matched = message?.match(regex)\n    if (matched) {\n      structured = {\n        ...cb(matched),\n        ...{ location },\n        ...{ filePath },\n      }\n      break\n    }\n  }\n\n  return structured\n}\n\nexport default errorParser\n\ninterface ILocOfGraphQLDocInSrcFile {\n  start: SourceLocation\n  end: SourceLocation\n  fileName: boolean\n}\n\nexport const locInGraphQlToLocInFile = (\n  locationOfGraphQLDocInSourceFile: ILocOfGraphQLDocInSrcFile,\n  graphqlLocation: SourceLocation\n): SourceLocation => {\n  return {\n    line:\n      graphqlLocation.line + locationOfGraphQLDocInSourceFile.start.line - 1,\n    column:\n      (graphqlLocation.line === 1\n        ? locationOfGraphQLDocInSourceFile.start.column\n        : 0) + graphqlLocation.column,\n  }\n}\n"],"mappings":"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"}