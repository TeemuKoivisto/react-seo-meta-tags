{"version":3,"file":"develop-preload-headers.js","names":["appendPreloadHeaders","requestPath","res","append","page","findPageByPath","store","getState","pagePathsToPreload","getPageMode","includes","path","unshift","staticQueriesToPreload","Set","pagePath","join","encodeURI","fixedPagePath","pageData","readPageData","program","directory","staticQueryHash","staticQueryHashes","add","e"],"sources":["../../src/utils/develop-preload-headers.ts"],"sourcesContent":["import { Response } from \"express\"\nimport * as path from \"path\"\nimport { fixedPagePath } from \"gatsby-core-utils\"\nimport { findPageByPath } from \"./find-page-by-path\"\nimport { readPageData } from \"./page-data\"\nimport { store } from \"../redux\"\nimport { getPageMode } from \"./page-mode\"\n\n/**\n * Add preload link headers to responses for .html files. This allows browser to schedule fetching critical resources\n * to render a page faster. Without them it would result in network waterfall (fetch js script -> parse and execute -> start downloading data)\n * With them we can start downloading data before JS executes.\n */\nexport async function appendPreloadHeaders(\n  requestPath: string,\n  res: Response\n): Promise<void> {\n  // add common.js and socket.io.js preload headers\n  // TODO: make socket.io part not blocking - we don't need it anymore to render the page\n  res.append(`Link`, `</commons.js>; rel=preload; as=script`)\n  res.append(`Link`, `</socket.io/socket.io.js>; rel=preload; as=script`)\n\n  const page = findPageByPath(store.getState(), requestPath, true)\n  // we fallback to 404 pages - so there should always be a page (at worst dev-404)\n  // this is just sanity check to not crash server in case it doesn't find anything\n  if (page) {\n    // add app-data.json preload\n    res.append(\n      `Link`,\n      `</page-data/app-data.json>; rel=preload; as=fetch ; crossorigin`\n    )\n\n    // add page-data.json preload\n    // our runtime also demands 404 and dev-404 page-data to be fetched to even render (see cache-dir/app.js)\n    const pagePathsToPreload = [`/404.html`, `/dev-404-page/`]\n    if (\n      getPageMode(page) !== `SSR` &&\n      !pagePathsToPreload.includes(page.path)\n    ) {\n      // let's make sure page path is first one (order shouldn't matter, just for reasonable order)\n      pagePathsToPreload.unshift(page.path)\n    }\n\n    const staticQueriesToPreload = new Set<string>()\n    for (const pagePath of pagePathsToPreload) {\n      res.append(\n        `Link`,\n        `</${path.join(\n          `page-data`,\n          encodeURI(fixedPagePath(pagePath)),\n          `page-data.json`\n        )}>; rel=preload; as=fetch ; crossorigin`\n      )\n\n      try {\n        const pageData = await readPageData(\n          path.join(store.getState().program.directory, `public`),\n          pagePath\n        )\n\n        // iterate over needed static queries and add them to Set of static queries to preload\n        // Set will guarantee uniqueness in case queries are shared by requested page and 404 page.\n        for (const staticQueryHash of pageData.staticQueryHashes) {\n          staticQueriesToPreload.add(staticQueryHash)\n        }\n      } catch (e) {\n        // there might be timing reasons why this fails - page-data file is not created yet\n        // as page was just recently added (so page exists already but page-data doesn't yet)\n        // in those cases we just do nothing\n      }\n    }\n\n    // append accumulated static queries from pages we load\n    for (const staticQueryHash of staticQueriesToPreload) {\n      res.append(\n        `Link`,\n        `</page-data/sq/d/${staticQueryHash}.json>; rel=preload; as=fetch ; crossorigin`\n      )\n    }\n  } else {\n    // should we track cases when there is actually nothing returned to find cases\n    // where we don't add preload headers if above assumption turns out to be wrong?\n  }\n}\n"],"mappings":";;;;AACA;AACA;AACA;AACA;AACA;AACA;AAAyC;AAAA;AAEzC;AACA;AACA;AACA;AACA;AACO,eAAeA,oBAAoB,CACxCC,WAAmB,EACnBC,GAAa,EACE;EACf;EACA;EACAA,GAAG,CAACC,MAAM,CAAE,MAAK,EAAG,uCAAsC,CAAC;EAC3DD,GAAG,CAACC,MAAM,CAAE,MAAK,EAAG,mDAAkD,CAAC;EAEvE,MAAMC,IAAI,GAAG,IAAAC,8BAAc,EAACC,YAAK,CAACC,QAAQ,EAAE,EAAEN,WAAW,EAAE,IAAI,CAAC;EAChE;EACA;EACA,IAAIG,IAAI,EAAE;IACR;IACAF,GAAG,CAACC,MAAM,CACP,MAAK,EACL,iEAAgE,CAClE;;IAED;IACA;IACA,MAAMK,kBAAkB,GAAG,CAAE,WAAU,EAAG,gBAAe,CAAC;IAC1D,IACE,IAAAC,qBAAW,EAACL,IAAI,CAAC,KAAM,KAAI,IAC3B,CAACI,kBAAkB,CAACE,QAAQ,CAACN,IAAI,CAACO,IAAI,CAAC,EACvC;MACA;MACAH,kBAAkB,CAACI,OAAO,CAACR,IAAI,CAACO,IAAI,CAAC;IACvC;IAEA,MAAME,sBAAsB,GAAG,IAAIC,GAAG,EAAU;IAChD,KAAK,MAAMC,QAAQ,IAAIP,kBAAkB,EAAE;MACzCN,GAAG,CAACC,MAAM,CACP,MAAK,EACL,KAAIQ,IAAI,CAACK,IAAI,CACX,WAAU,EACXC,SAAS,CAAC,IAAAC,8BAAa,EAACH,QAAQ,CAAC,CAAC,EACjC,gBAAe,CAChB,wCAAuC,CAC1C;MAED,IAAI;QACF,MAAMI,QAAQ,GAAG,MAAM,IAAAC,sBAAY,EACjCT,IAAI,CAACK,IAAI,CAACV,YAAK,CAACC,QAAQ,EAAE,CAACc,OAAO,CAACC,SAAS,EAAG,QAAO,CAAC,EACvDP,QAAQ,CACT;;QAED;QACA;QACA,KAAK,MAAMQ,eAAe,IAAIJ,QAAQ,CAACK,iBAAiB,EAAE;UACxDX,sBAAsB,CAACY,GAAG,CAACF,eAAe,CAAC;QAC7C;MACF,CAAC,CAAC,OAAOG,CAAC,EAAE;QACV;QACA;QACA;MAAA;IAEJ;;IAEA;IACA,KAAK,MAAMH,eAAe,IAAIV,sBAAsB,EAAE;MACpDX,GAAG,CAACC,MAAM,CACP,MAAK,EACL,oBAAmBoB,eAAgB,6CAA4C,CACjF;IACH;EACF,CAAC,MAAM;IACL;IACA;EAAA;AAEJ"}