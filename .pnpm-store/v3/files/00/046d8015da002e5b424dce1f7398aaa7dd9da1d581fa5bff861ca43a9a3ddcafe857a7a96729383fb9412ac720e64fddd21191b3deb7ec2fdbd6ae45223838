{"version":3,"file":"index.modern.js","sources":["../src/index.ts"],"sourcesContent":["import {\n    JSXAttribute,\n    JSXIdentifier,\n    JSXNamespacedName,\n    JSXOpeningElement,\n} from \"@babel/types\";\nimport { NodePath as CoreNodePath } from \"@babel/core\";\nimport { NodePath as TraverseNodePath } from \"@babel/traverse\";\n\nexport function parseIdentifier(\n    identifier: JSXIdentifier | JSXNamespacedName\n): string {\n    if (identifier.type === `JSXIdentifier`) {\n        return identifier.name;\n    }\n    return parseIdentifier(identifier.name);\n}\n\n/**\n * Get all attribute values of a JSX element. This only includes values that can be statically-analysed.\n * Pass the `onError` callback to be notified if an attribute cannot be resolved.\n *\n * @param nodePath The NodePath of the JSX opening element\n * @param onError Called with the attribute name and path if it is present but cannot be resolved\n * @param include If present, only these props are evaluated. Does not apply to spread attributes.\n */\nexport function getAttributeValues(\n    nodePath:\n        | CoreNodePath<JSXOpeningElement>\n        | TraverseNodePath<JSXOpeningElement>,\n    onError?: (\n        attributeName: string,\n        attributePath?: CoreNodePath<JSXAttribute>\n    ) => void,\n    include?: Set<string>\n): Record<string, unknown> {\n    let result: Record<string, unknown> = {};\n\n    nodePath.traverse({\n        JSXSpreadAttribute(attrPath) {\n            const spreadValues = attrPath.get(`argument`).evaluate();\n            if (spreadValues.confident) {\n                result = { ...result, ...spreadValues.value };\n            } else {\n                onError?.(`<spread attributes>`);\n            }\n        },\n        JSXAttribute(attrPath) {\n            const prop = parseIdentifier(attrPath.node.name);\n            if (include && !include.has(prop)) {\n                return;\n            }\n            const { value, confident } = getAttributeValue(attrPath);\n            if (confident) {\n                result[prop] = value;\n            } else {\n                onError?.(prop, attrPath);\n            }\n        },\n    });\n\n    return result;\n}\n\n/**\n * Attempt to get the value of a JSX attribute. Returns an object with the\n * properties `confident`, which is false if the value cannot be resolved\n * in the current scope, and `value` which is the value if it can be.\n *\n * If the attribute is empty, then the returned value is `true`, e.g.\n * `<Image eager />` would return `true` for the `eager` attribute.\n *\n * @param nodePath The NodePath of the JSXAttribute\n */\nexport function getAttributeValue<T = unknown>(\n    nodePath: CoreNodePath<JSXAttribute> | TraverseNodePath<JSXAttribute>\n): {\n    confident: boolean;\n    value: T | true;\n} {\n    let valueNode = nodePath.get(`value`);\n    if (Array.isArray(valueNode)) {\n        valueNode = valueNode[0];\n    }\n    if (!valueNode.node) {\n        // empty attributes are truthy\n        return { confident: true, value: true };\n    } else if (valueNode.node.type === `JSXExpressionContainer`) {\n        const expression = valueNode.get(`expression`);\n\n        if (Array.isArray(expression)) {\n            return expression[0]?.evaluate();\n        }\n\n        return expression.evaluate();\n    } else {\n        return valueNode.evaluate();\n    }\n}\n"],"names":["parseIdentifier","identifier","type","name","getAttributeValues","nodePath","onError","include","result","traverse","JSXSpreadAttribute","attrPath","spreadValues","get","evaluate","confident","value","JSXAttribute","prop","node","has","getAttributeValue","valueNode","Array","isArray","expression"],"mappings":"SASgBA,gBACZC;AAEA,MAAIA,UAAU,CAACC,IAAX,oBAAJ,EAAyC;AACrC,WAAOD,UAAU,CAACE,IAAlB;AACH;;AACD,SAAOH,eAAe,CAACC,UAAU,CAACE,IAAZ,CAAtB;AACH;AAED;;;;;;;;;SAQgBC,mBACZC,UAGAC,SAIAC;AAEA,MAAIC,MAAM,GAA4B,EAAtC;AAEAH,EAAAA,QAAQ,CAACI,QAAT,CAAkB;AACdC,IAAAA,kBAAkB,CAACC,QAAD;AACd,YAAMC,YAAY,GAAGD,QAAQ,CAACE,GAAT,WAAA,EAAyBC,QAAzB,EAArB;;AACA,UAAIF,YAAY,CAACG,SAAjB,EAA4B;AACxBP,QAAAA,MAAM,GAAG,EAAE,GAAGA,MAAL;AAAa,aAAGI,YAAY,CAACI;AAA7B,SAAT;AACH,OAFD,MAEO;AACHV,QAAAA,OAAO,wBAAA,CAAP;AACH;AACJ,KARa;;AASdW,IAAAA,YAAY,CAACN,QAAD;AACR,YAAMO,IAAI,GAAGlB,eAAe,CAACW,QAAQ,CAACQ,IAAT,CAAchB,IAAf,CAA5B;;AACA,UAAII,OAAO,IAAI,CAACA,OAAO,CAACa,GAAR,CAAYF,IAAZ,CAAhB,EAAmC;AAC/B;AACH;;AACD,YAAM;AAAEF,QAAAA,KAAF;AAASD,QAAAA;AAAT,UAAuBM,iBAAiB,CAACV,QAAD,CAA9C;;AACA,UAAII,SAAJ,EAAe;AACXP,QAAAA,MAAM,CAACU,IAAD,CAAN,GAAeF,KAAf;AACH,OAFD,MAEO;AACHV,QAAAA,OAAO,GAAGY,IAAH,EAASP,QAAT,CAAP;AACH;AACJ;;AApBa,GAAlB;AAuBA,SAAOH,MAAP;AACH;AAED;;;;;;;;;;;SAUgBa,kBACZhB;AAKA,MAAIiB,SAAS,GAAGjB,QAAQ,CAACQ,GAAT,QAAA,CAAhB;;AACA,MAAIU,KAAK,CAACC,OAAN,CAAcF,SAAd,CAAJ,EAA8B;AAC1BA,IAAAA,SAAS,GAAGA,SAAS,CAAC,CAAD,CAArB;AACH;;AACD,MAAI,CAACA,SAAS,CAACH,IAAf,EAAqB;AACjB;AACA,WAAO;AAAEJ,MAAAA,SAAS,EAAE,IAAb;AAAmBC,MAAAA,KAAK,EAAE;AAA1B,KAAP;AACH,GAHD,MAGO,IAAIM,SAAS,CAACH,IAAV,CAAejB,IAAf,6BAAJ,EAAsD;AACzD,UAAMuB,UAAU,GAAGH,SAAS,CAACT,GAAV,aAAA,CAAnB;;AAEA,QAAIU,KAAK,CAACC,OAAN,CAAcC,UAAd,CAAJ,EAA+B;AAC3B,aAAOA,UAAU,CAAC,CAAD,CAAV,EAAeX,QAAf,EAAP;AACH;;AAED,WAAOW,UAAU,CAACX,QAAX,EAAP;AACH,GARM,MAQA;AACH,WAAOQ,SAAS,CAACR,QAAV,EAAP;AACH;AACJ;;;;"}