{"version":3,"file":"gatsby-webpack-virtual-modules.js","names":["fileContentLookup","instances","VIRTUAL_MODULES_BASE_PATH","GatsbyWebpackVirtualModules","apply","compiler","virtualModules","VirtualModulesPlugin","push","writeModule","bind","getAbsolutePathForVirtualModule","filePath","path","join","process","cwd","fileContents","adjustedFilePath","fs","outputFileSync","forEach","instance"],"sources":["../../src/utils/gatsby-webpack-virtual-modules.ts"],"sourcesContent":["import VirtualModulesPlugin from \"webpack-virtual-modules\"\nimport * as path from \"path\"\nimport * as fs from \"fs-extra\"\n/*\n * This module allows creating virtual (in memory only) modules / files\n * that webpack compilation can access without the need to write module\n * body to actual filesystem.\n *\n * It's useful for intermediate artifacts that are not part of final builds,\n * but are used in some way to generate final ones (for example `async-requires.js`).\n *\n * Using virtual modules allow us to avoid unnecessary I/O to write/read those modules,\n * but more importantly using virtual modules give us immediate invalidation events\n * in webpack watching mode (as opposed to debounced/delayed events when filesystem is used).\n * Instant invalidation events make it much easier to work with various state transitions\n * in response to external events that are happening while `gatsby develop` is running.\n */\n\ninterface IGatsbyWebpackVirtualModulesContext {\n  writeModule: VirtualModulesPlugin[\"writeModule\"]\n}\n\nconst fileContentLookup: Record<string, string> = {}\nconst instances: Array<IGatsbyWebpackVirtualModulesContext> = []\n\nexport const VIRTUAL_MODULES_BASE_PATH = `.cache/_this_is_virtual_fs_path_`\n\nexport class GatsbyWebpackVirtualModules {\n  apply(compiler): void {\n    const virtualModules = new VirtualModulesPlugin(fileContentLookup)\n    virtualModules.apply(compiler)\n    instances.push({\n      writeModule: virtualModules.writeModule.bind(virtualModules),\n    })\n  }\n}\n\nexport function getAbsolutePathForVirtualModule(filePath: string): string {\n  return path.join(process.cwd(), VIRTUAL_MODULES_BASE_PATH, filePath)\n}\n\nexport function writeModule(filePath: string, fileContents: string): void {\n  const adjustedFilePath = getAbsolutePathForVirtualModule(filePath)\n\n  if (fileContentLookup[adjustedFilePath] === fileContents) {\n    // we already have this, no need to cause invalidation\n    return\n  }\n\n  // workaround webpack marking virtual modules as deleted because those files don't really exist\n  // so we create those files just so watchpack doesn't mark them as initially missing\n  fs.outputFileSync(adjustedFilePath, fileContents)\n\n  fileContentLookup[adjustedFilePath] = fileContents\n\n  instances.forEach(instance => {\n    instance.writeModule(adjustedFilePath, fileContents)\n  })\n}\n"],"mappings":";;;;;;;AAAA;AACA;AACA;AAA8B;AAAA;AAoB9B,MAAMA,iBAAyC,GAAG,CAAC,CAAC;AACpD,MAAMC,SAAqD,GAAG,EAAE;AAEzD,MAAMC,yBAAyB,GAAI,kCAAiC;AAAA;AAEpE,MAAMC,2BAA2B,CAAC;EACvCC,KAAK,CAACC,QAAQ,EAAQ;IACpB,MAAMC,cAAc,GAAG,IAAIC,8BAAoB,CAACP,iBAAiB,CAAC;IAClEM,cAAc,CAACF,KAAK,CAACC,QAAQ,CAAC;IAC9BJ,SAAS,CAACO,IAAI,CAAC;MACbC,WAAW,EAAEH,cAAc,CAACG,WAAW,CAACC,IAAI,CAACJ,cAAc;IAC7D,CAAC,CAAC;EACJ;AACF;AAAC;AAEM,SAASK,+BAA+B,CAACC,QAAgB,EAAU;EACxE,OAAOC,IAAI,CAACC,IAAI,CAACC,OAAO,CAACC,GAAG,EAAE,EAAEd,yBAAyB,EAAEU,QAAQ,CAAC;AACtE;AAEO,SAASH,WAAW,CAACG,QAAgB,EAAEK,YAAoB,EAAQ;EACxE,MAAMC,gBAAgB,GAAGP,+BAA+B,CAACC,QAAQ,CAAC;EAElE,IAAIZ,iBAAiB,CAACkB,gBAAgB,CAAC,KAAKD,YAAY,EAAE;IACxD;IACA;EACF;;EAEA;EACA;EACAE,EAAE,CAACC,cAAc,CAACF,gBAAgB,EAAED,YAAY,CAAC;EAEjDjB,iBAAiB,CAACkB,gBAAgB,CAAC,GAAGD,YAAY;EAElDhB,SAAS,CAACoB,OAAO,CAACC,QAAQ,IAAI;IAC5BA,QAAQ,CAACb,WAAW,CAACS,gBAAgB,EAAED,YAAY,CAAC;EACtD,CAAC,CAAC;AACJ"}