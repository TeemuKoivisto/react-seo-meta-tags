{"version":3,"file":"detect-node-mutations.js","names":["reported","Set","genericProxy","createProxyHandler","nodeInternalProxy","onGet","key","value","undefined","onSet","target","nodeProxy","memoizedProxy","referenceMap","WeakMap","handler","alreadyWrapped","get","wrapped","Proxy","set","result","error","Error","captureStackTrace","stack","has","add","codeFrame","getNonGatsbyCodeFrameFormatted","reporter","warn","replace","fieldDescriptor","Object","getOwnPropertyDescriptor","writable","shouldWrapNodesInProxies","process","env","GATSBY_DETECT_NODE_MUTATIONS","enableNodeMutationsDetection","wrapNode","node","wrapNodes","nodes","length","map"],"sources":["../../src/utils/detect-node-mutations.ts"],"sourcesContent":["import reporter from \"gatsby-cli/lib/reporter\"\nimport { getNonGatsbyCodeFrameFormatted } from \"./stack-trace-utils\"\nimport type { IGatsbyNode } from \"../redux/types\"\n\nconst reported = new Set<string>()\n\nconst genericProxy = createProxyHandler()\nconst nodeInternalProxy = createProxyHandler({\n  onGet(key, value) {\n    if (key === `fieldOwners` || key === `content`) {\n      // all allowed in here\n      return value\n    }\n    return undefined\n  },\n  onSet(target, key, value) {\n    if (key === `fieldOwners` || key === `content`) {\n      target[key] = value\n      return true\n    }\n    return undefined\n  },\n})\n\nconst nodeProxy = createProxyHandler({\n  onGet(key, value) {\n    if (key === `internal`) {\n      return memoizedProxy(value, nodeInternalProxy)\n    } else if (key === `fields` || key === `children`) {\n      // all allowed in here\n      return value\n    }\n    return undefined\n  },\n  onSet(target, key, value) {\n    if (key === `fields` || key === `children`) {\n      target[key] = value\n      return true\n    }\n    return undefined\n  },\n})\n\n/**\n * Every time we create proxy for object, we store it in WeakMap,\n * so that we reuse it for that object instead of creating new Proxy.\n * This also ensures reference equality: `memoizedProxy(obj) === memoizedProxy(obj)`.\n * If we didn't reuse already created proxy above comparison would return false.\n */\nconst referenceMap = new WeakMap<any, any>()\nfunction memoizedProxy<T>(target: T, handler: ProxyHandler<any>): T {\n  const alreadyWrapped = referenceMap.get(target)\n  if (alreadyWrapped) {\n    return alreadyWrapped\n  } else {\n    const wrapped = new Proxy(target, handler)\n    referenceMap.set(target, wrapped)\n    return wrapped\n  }\n}\n\nfunction createProxyHandler({\n  onGet,\n  onSet,\n}: {\n  onGet?: (key: string | symbol, value: any) => any\n  onSet?: (target: any, key: string | symbol, value: any) => boolean | undefined\n} = {}): ProxyHandler<any> {\n  function set(target, key, value): boolean {\n    if (onSet) {\n      const result = onSet(target, key, value)\n      if (result !== undefined) {\n        return result\n      }\n    }\n\n    const error = new Error(`Stack trace:`)\n    Error.captureStackTrace(error, set)\n\n    if (error.stack && !reported.has(error.stack)) {\n      reported.add(error.stack)\n      const codeFrame = getNonGatsbyCodeFrameFormatted({\n        stack: error.stack,\n      })\n      reporter.warn(\n        `Node mutation detected\\n\\n${\n          codeFrame ? `${codeFrame}\\n\\n` : ``\n        }${error.stack.replace(/^Error:?\\s*/, ``)}`\n      )\n    }\n    return true\n  }\n\n  function get(target, key): any {\n    const value = target[key]\n\n    if (onGet) {\n      const result = onGet(key, value)\n      if (result !== undefined) {\n        return result\n      }\n    }\n\n    const fieldDescriptor = Object.getOwnPropertyDescriptor(target, key)\n    if (fieldDescriptor && !fieldDescriptor.writable) {\n      // this is to prevent errors like:\n      // ```\n      // TypeError: 'get' on proxy: property 'constants' is a read - only and\n      // non - configurable data property on the proxy target but the proxy\n      // did not return its actual value\n      // (expected '[object Object]' but got '[object Object]')\n      // ```\n      return value\n    }\n\n    if (typeof value === `object` && value !== null) {\n      return memoizedProxy(value, genericProxy)\n    }\n\n    return value\n  }\n\n  return {\n    get,\n    set,\n  }\n}\n\nlet shouldWrapNodesInProxies = !!process.env.GATSBY_DETECT_NODE_MUTATIONS\nexport function enableNodeMutationsDetection(): void {\n  shouldWrapNodesInProxies = true\n\n  reporter.warn(\n    `Node mutation detection is enabled. Remember to disable it after you are finished with diagnostic as it will cause build performance degradation.`\n  )\n}\n\nexport function wrapNode<T extends IGatsbyNode | undefined>(node: T): T {\n  if (node && shouldWrapNodesInProxies) {\n    return memoizedProxy(node, nodeProxy)\n  } else {\n    return node\n  }\n}\n\nexport function wrapNodes<T extends Array<IGatsbyNode> | undefined>(\n  nodes: T\n): T {\n  if (nodes && shouldWrapNodesInProxies && nodes.length > 0) {\n    return nodes.map(node => memoizedProxy(node, nodeProxy)) as T\n  } else {\n    return nodes\n  }\n}\n"],"mappings":"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"}