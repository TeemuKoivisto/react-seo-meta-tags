{"version":3,"file":"page-data.js","names":["readPageData","publicDir","pagePath","filePath","generatePageDataPath","rawPageData","fs","readFile","JSON","parse","removePageData","existsSync","remove","Promise","resolve","pageDataExists","lmdbPageQueryResultsCache","getLMDBPageQueryResultsCache","GatsbyCacheLmdbImpl","require","default","name","encoding","init","savePageQueryResultsPromise","waitUntilPageQueryResultsAreStored","savePageQueryResult","stringifiedResult","set","readPageQueryResult","get","Error","writePageData","pageData","slicesUsedByTemplates","slices","result","path","outputFilePath","body","constructPageDataString","pageDataSize","Buffer","byteLength","store","dispatch","type","payload","size","pageDataHash","createContentDigest","ensureFileContent","writeSliceData","componentChunkName","staticQueryHashes","toString","join","sliceData","stringify","sliceDataSize","sliceName","sliceDataHash","readSliceData","isFlushPending","isFlushing","isFlushEnqueued","staleNodeManifests","maxManifestIdsToLog","flush","parentSpan","pendingPageDataWrites","pages","program","staticQueriesByTemplate","queries","slicesByTemplate","nodeManifests","getState","isBuild","_","pagePaths","sliceNames","writePageDataActivity","nodeManifestPagePathMap","processNodeManifests","length","reporter","warn","map","n","manifestId","slice","createProgress","id","start","flushQueue","fastq","task","cb","page","shouldClearPendingWrite","process","env","GATSBY_QUERY_ON_DEMAND","query","trackedQueries","hasFlag","dirty","FLAG_DIRTY_NEW_PAGE","setImmediate","getPageMode","componentPath","directory","websocketManager","emitPageData","e","panicOnBuild","tick","emitSliceData","push","idle","drain","end","enqueueFlush","isWebpackStatusPending","handleStalePageData","pathExists","activity","activityTimer","pageDataFilesFromPreviousBuilds","reject","results","Set","stream","fsWalkStream","on","data","add","expectedPageDataFiles","forEach","deletionPromises","pageDataFilePath","has","all","modifyPageDataForErrorMessage","input","optionalData","pageContext","optionalErrors","errors","graphql","getServerDataError","getServerData","matchPath","slicesMap"],"sources":["../../src/utils/page-data.ts"],"sourcesContent":["import { walkStream as fsWalkStream, Entry } from \"@nodelib/fs.walk\"\nimport fs from \"fs-extra\"\nimport reporter from \"gatsby-cli/lib/reporter\"\nimport fastq from \"fastq\"\nimport path from \"path\"\nimport { createContentDigest, generatePageDataPath } from \"gatsby-core-utils\"\nimport { websocketManager } from \"./websocket-manager\"\nimport { isWebpackStatusPending } from \"./webpack-status\"\nimport { store } from \"../redux\"\nimport type { IGatsbySlice, IGatsbyState } from \"../redux/types\"\nimport { hasFlag, FLAG_DIRTY_NEW_PAGE } from \"../redux/reducers/queries\"\nimport type GatsbyCacheLmdb from \"./cache-lmdb\"\nimport {\n  constructPageDataString,\n  reverseFixedPagePath,\n  IPageData,\n  IPageDataInput,\n} from \"./page-data-helpers\"\nimport { Span } from \"opentracing\"\n\nexport { reverseFixedPagePath }\nimport { processNodeManifests } from \"../utils/node-manifest\"\nimport { IExecutionResult } from \"../query/types\"\nimport { getPageMode } from \"./page-mode\"\nimport { ICollectedSlices } from \"./babel/find-slices\"\nimport { ensureFileContent } from \"./ensure-file-content\"\n\nexport interface IPageDataWithQueryResult extends IPageData {\n  result: IExecutionResult\n}\n\nexport interface ISliceData {\n  componentChunkName: string\n  result: IExecutionResult\n  staticQueryHashes: Array<string>\n}\n\nexport async function readPageData(\n  publicDir: string,\n  pagePath: string\n): Promise<IPageDataWithQueryResult> {\n  const filePath = generatePageDataPath(publicDir, pagePath)\n  const rawPageData = await fs.readFile(filePath, `utf-8`)\n  return JSON.parse(rawPageData)\n}\n\nexport async function removePageData(\n  publicDir: string,\n  pagePath: string\n): Promise<void> {\n  const filePath = generatePageDataPath(publicDir, pagePath)\n\n  if (fs.existsSync(filePath)) {\n    return await fs.remove(filePath)\n  }\n\n  return Promise.resolve()\n}\n\nexport function pageDataExists(publicDir: string, pagePath: string): boolean {\n  return fs.existsSync(generatePageDataPath(publicDir, pagePath))\n}\n\nlet lmdbPageQueryResultsCache: GatsbyCacheLmdb\nfunction getLMDBPageQueryResultsCache(): GatsbyCacheLmdb {\n  if (!lmdbPageQueryResultsCache) {\n    const GatsbyCacheLmdbImpl = require(`./cache-lmdb`).default\n    lmdbPageQueryResultsCache = new GatsbyCacheLmdbImpl({\n      name: `internal-tmp-query-results`,\n      encoding: `string`,\n    }).init()\n  }\n  return lmdbPageQueryResultsCache\n}\n\nlet savePageQueryResultsPromise = Promise.resolve()\n\nexport function waitUntilPageQueryResultsAreStored(): Promise<void> {\n  return savePageQueryResultsPromise\n}\n\nexport async function savePageQueryResult(\n  pagePath: string,\n  stringifiedResult: string\n): Promise<void> {\n  savePageQueryResultsPromise = getLMDBPageQueryResultsCache().set(\n    pagePath,\n    stringifiedResult\n  ) as Promise<void>\n}\n\nexport async function readPageQueryResult(pagePath: string): Promise<string> {\n  const stringifiedResult = await getLMDBPageQueryResultsCache().get(pagePath)\n  if (typeof stringifiedResult === `string`) {\n    return stringifiedResult\n  }\n  throw new Error(`Couldn't find temp query result for \"${pagePath}\".`)\n}\n\nexport async function writePageData(\n  publicDir: string,\n  pageData: IPageDataInput,\n  slicesUsedByTemplates: Map<string, ICollectedSlices>,\n  slices: IGatsbyState[\"slices\"]\n): Promise<string> {\n  const result = await readPageQueryResult(pageData.path)\n\n  const outputFilePath = generatePageDataPath(publicDir, pageData.path)\n\n  const body = constructPageDataString(\n    pageData,\n    result,\n    slicesUsedByTemplates,\n    slices\n  )\n\n  // transform asset size to kB (from bytes) to fit 64 bit to numbers\n  const pageDataSize = Buffer.byteLength(body) / 1000\n\n  store.dispatch({\n    type: `ADD_PAGE_DATA_STATS`,\n    payload: {\n      pagePath: pageData.path,\n      filePath: outputFilePath,\n      size: pageDataSize,\n      pageDataHash: createContentDigest(body),\n    },\n  })\n\n  await ensureFileContent(outputFilePath, body)\n  return body\n}\n\nexport async function writeSliceData(\n  publicDir: string,\n  { componentChunkName, name }: IGatsbySlice,\n  staticQueryHashes: Array<string>\n): Promise<string> {\n  const result = JSON.parse(\n    (await readPageQueryResult(`slice--${name}`)).toString()\n  )\n\n  const outputFilePath = path.join(publicDir, `slice-data`, `${name}.json`)\n\n  const sliceData: ISliceData = {\n    componentChunkName,\n    result,\n    staticQueryHashes,\n  }\n\n  const body = JSON.stringify(sliceData)\n\n  const sliceDataSize = Buffer.byteLength(body) / 1000\n\n  store.dispatch({\n    type: `ADD_SLICE_DATA_STATS`,\n    payload: {\n      sliceName: name,\n      filePath: outputFilePath,\n      size: sliceDataSize,\n      sliceDataHash: createContentDigest(body),\n    },\n  })\n\n  await ensureFileContent(outputFilePath, body)\n  return body\n}\n\nexport async function readSliceData(\n  publicDir: string,\n  sliceName: string\n): Promise<IPageDataWithQueryResult> {\n  const filePath = path.join(publicDir, `slice-data`, `${sliceName}.json`)\n  const rawPageData = await fs.readFile(filePath, `utf-8`)\n  return JSON.parse(rawPageData)\n}\n\nlet isFlushPending = false\nlet isFlushing = false\n\nexport function isFlushEnqueued(): boolean {\n  return isFlushPending\n}\n\nlet staleNodeManifests = false\nconst maxManifestIdsToLog = 50\n\ntype IDataTask =\n  | {\n      type: \"page\"\n      pagePath: string\n    }\n  | {\n      type: \"slice\"\n      sliceName: string\n    }\n\nexport async function flush(parentSpan?: Span): Promise<void> {\n  if (isFlushing) {\n    // We're already in the middle of a flush\n    return\n  }\n  await waitUntilPageQueryResultsAreStored()\n  isFlushPending = false\n  isFlushing = true\n  const {\n    pendingPageDataWrites,\n    pages,\n    program,\n    staticQueriesByTemplate,\n    queries,\n    slices,\n    slicesByTemplate,\n    nodeManifests,\n  } = store.getState()\n  const isBuild = program?._?.[0] !== `develop`\n\n  const { pagePaths, sliceNames } = pendingPageDataWrites\n  let writePageDataActivity\n\n  let nodeManifestPagePathMap\n\n  if (pagePaths.size > 0) {\n    // we process node manifests in this location because we need to add the manifestId to the page data.\n    // We use this manifestId to determine if the page data is up to date when routing. Here we create a map of \"pagePath\": \"manifestId\" while processing and writing node manifest files.\n    // We only do this when there are pending page-data writes because otherwise we could flush pending createNodeManifest calls before page-data.json files are written. Which means those page-data files wouldn't have the corresponding manifest id's written to them.\n    nodeManifestPagePathMap = await processNodeManifests()\n  } else if (nodeManifests.length > 0 && staleNodeManifests) {\n    staleNodeManifests = false\n\n    reporter.warn(\n      `[gatsby] node manifests were created but no page-data.json files were written, so manifest ID's were not added to page-data.json files. This may be a bug or it may be due to a source plugin creating a node manifest for a node that did not change. Node manifest IDs: ${nodeManifests\n        .map(n => n.manifestId)\n        .slice(0, maxManifestIdsToLog)\n        .join(`,`)}${\n        nodeManifests.length > maxManifestIdsToLog\n          ? ` There were ${\n              nodeManifests.length - maxManifestIdsToLog\n            } additional ID's that were not logged due to output length.`\n          : ``\n      }`\n    )\n\n    nodeManifestPagePathMap = await processNodeManifests()\n  } else if (nodeManifests.length > 0) {\n    staleNodeManifests = true\n  }\n\n  if (pagePaths.size > 0 || sliceNames.size > 0) {\n    writePageDataActivity = reporter.createProgress(\n      `Writing page-data.json and slice-data.json files to public directory`,\n      pagePaths.size + sliceNames.size,\n      0,\n      { id: `write-page-data-public-directory`, parentSpan }\n    )\n    writePageDataActivity.start()\n  }\n\n  const flushQueue = fastq<void, IDataTask, boolean>(async (task, cb) => {\n    if (task.type === `page`) {\n      const { pagePath } = task\n      const page = pages.get(pagePath)\n\n      let shouldClearPendingWrite = true\n\n      // It's a gloomy day in Bombay, let me tell you a short story...\n      // Once upon a time, writing page-data.json files were atomic\n      // After this change (#24808), they are not and this means that\n      // between adding a pending write for a page and actually flushing\n      // them, a page might not exist anymore щ（ﾟДﾟщ）\n      // This is why we need this check\n      if (page) {\n        if (page.path && nodeManifestPagePathMap) {\n          page.manifestId = nodeManifestPagePathMap.get(page.path)\n        }\n\n        if (!isBuild && process.env.GATSBY_QUERY_ON_DEMAND) {\n          // check if already did run query for this page\n          // with query-on-demand we might have pending page-data write due to\n          // changes in static queries assigned to page template, but we might not\n          // have query result for it\n          const query = queries.trackedQueries.get(page.path)\n          if (!query) {\n            // this should not happen ever\n            throw new Error(\n              `We have a page, but we don't have registered query for it (???)`\n            )\n          }\n\n          if (hasFlag(query.dirty, FLAG_DIRTY_NEW_PAGE)) {\n            // query results are not written yet\n            setImmediate(() => cb(null, true))\n            return\n          }\n        }\n\n        // In develop we rely on QUERY_ON_DEMAND so we just go through\n        // In build we only build these page-json for SSG pages\n        if (!isBuild || (isBuild && getPageMode(page) === `SSG`)) {\n          const staticQueryHashes =\n            staticQueriesByTemplate.get(page.componentPath) || []\n\n          try {\n            const result = await writePageData(\n              path.join(program.directory, `public`),\n              {\n                ...page,\n                staticQueryHashes,\n              },\n              slicesByTemplate,\n              slices\n            )\n\n            if (!isBuild) {\n              websocketManager.emitPageData({\n                id: pagePath,\n                result: JSON.parse(result) as IPageDataWithQueryResult,\n              })\n            }\n          } catch (e) {\n            shouldClearPendingWrite = false\n            reporter.panicOnBuild(\n              `Failed to write page-data for \"\"${page.path}`,\n              e\n            )\n          }\n          writePageDataActivity.tick()\n        }\n      }\n\n      if (shouldClearPendingWrite) {\n        store.dispatch({\n          type: `CLEAR_PENDING_PAGE_DATA_WRITE`,\n          payload: {\n            page: pagePath,\n          },\n        })\n      }\n    } else if (task.type === `slice`) {\n      const { sliceName } = task\n      const slice = slices.get(sliceName)\n      if (slice) {\n        const staticQueryHashes =\n          staticQueriesByTemplate.get(slice.componentPath) || []\n\n        const result = await writeSliceData(\n          path.join(program.directory, `public`),\n          slice,\n          staticQueryHashes\n        )\n\n        writePageDataActivity.tick()\n\n        if (!isBuild) {\n          websocketManager.emitSliceData({\n            id: sliceName,\n            result: JSON.parse(result) as IPageDataWithQueryResult,\n          })\n        }\n      }\n\n      store.dispatch({\n        type: `CLEAR_PENDING_SLICE_DATA_WRITE`,\n        payload: {\n          name: sliceName,\n        },\n      })\n    }\n\n    // `setImmediate` below is a workaround against stack overflow\n    // occurring when there are many non-SSG pages\n    setImmediate(() => cb(null, true))\n    return\n  }, 25)\n\n  for (const pagePath of pagePaths) {\n    flushQueue.push({ type: `page`, pagePath }, () => {})\n  }\n  for (const sliceName of sliceNames) {\n    flushQueue.push({ type: `slice`, sliceName }, () => {})\n  }\n\n  if (!flushQueue.idle()) {\n    await new Promise(resolve => {\n      flushQueue.drain = resolve as () => unknown\n    })\n  }\n  if (writePageDataActivity) {\n    writePageDataActivity.end()\n  }\n\n  isFlushing = false\n\n  return\n}\n\nexport function enqueueFlush(parentSpan?: Span): void {\n  if (isWebpackStatusPending()) {\n    isFlushPending = true\n  } else {\n    flush(parentSpan)\n  }\n}\n\nexport async function handleStalePageData(parentSpan: Span): Promise<void> {\n  if (!(await fs.pathExists(`public/page-data`))) {\n    return\n  }\n\n  // public directory might have stale page-data files from previous builds\n  // we get the list of those and compare against expected page-data files\n  // and remove ones that shouldn't be there anymore\n\n  const activity = reporter.activityTimer(`Cleaning up stale page-data`, {\n    parentSpan,\n  })\n  activity.start()\n\n  const pageDataFilesFromPreviousBuilds = await new Promise<Set<string>>(\n    (resolve, reject) => {\n      const results = new Set<string>()\n\n      const stream = fsWalkStream(`public/page-data`)\n\n      stream.on(`data`, (data: Entry) => {\n        if (data.name === `page-data.json`) {\n          results.add(data.path)\n        }\n      })\n\n      stream.on(`error`, e => {\n        reject(e)\n      })\n\n      stream.on(`end`, () => resolve(results))\n    }\n  )\n\n  const expectedPageDataFiles = new Set<string>()\n  store.getState().pages.forEach(page => {\n    expectedPageDataFiles.add(generatePageDataPath(`public`, page.path))\n  })\n\n  const deletionPromises: Array<Promise<void>> = []\n  pageDataFilesFromPreviousBuilds.forEach(pageDataFilePath => {\n    if (!expectedPageDataFiles.has(pageDataFilePath)) {\n      deletionPromises.push(fs.remove(pageDataFilePath))\n    }\n  })\n\n  await Promise.all(deletionPromises)\n\n  activity.end()\n}\n\ninterface IModifyPageDataForErrorMessage {\n  errors: {\n    graphql?: IPageDataWithQueryResult[\"result\"][\"errors\"]\n    getServerData?: IPageDataWithQueryResult[\"getServerDataError\"]\n  }\n  graphqlExtensions?: IPageDataWithQueryResult[\"result\"][\"extensions\"]\n  pageContext?: IPageDataWithQueryResult[\"result\"][\"pageContext\"]\n  path: IPageDataWithQueryResult[\"path\"]\n  matchPath: IPageDataWithQueryResult[\"matchPath\"]\n  slicesMap: IPageDataWithQueryResult[\"slicesMap\"]\n}\n\nexport function modifyPageDataForErrorMessage(\n  input: IPageDataWithQueryResult\n): IModifyPageDataForErrorMessage {\n  const optionalData = {\n    ...(input.result?.pageContext\n      ? { pageContext: input.result.pageContext }\n      : {}),\n    ...(input.result?.pageContext\n      ? { pageContext: input.result.pageContext }\n      : {}),\n  }\n\n  const optionalErrors = {\n    ...(input.result?.errors ? { graphql: input.result.errors } : {}),\n    ...(input.getServerDataError\n      ? { getServerData: input.getServerDataError }\n      : {}),\n  }\n\n  return {\n    errors: {\n      ...optionalErrors,\n    },\n    path: input.path,\n    matchPath: input.matchPath,\n    slicesMap: input.slicesMap,\n    ...optionalData,\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAK4B;AAI5B;AAEA;AAEA;AAYO,eAAeA,YAAY,CAChCC,SAAiB,EACjBC,QAAgB,EACmB;EACnC,MAAMC,QAAQ,GAAG,IAAAC,qCAAoB,EAACH,SAAS,EAAEC,QAAQ,CAAC;EAC1D,MAAMG,WAAW,GAAG,MAAMC,gBAAE,CAACC,QAAQ,CAACJ,QAAQ,EAAG,OAAM,CAAC;EACxD,OAAOK,IAAI,CAACC,KAAK,CAACJ,WAAW,CAAC;AAChC;AAEO,eAAeK,cAAc,CAClCT,SAAiB,EACjBC,QAAgB,EACD;EACf,MAAMC,QAAQ,GAAG,IAAAC,qCAAoB,EAACH,SAAS,EAAEC,QAAQ,CAAC;EAE1D,IAAII,gBAAE,CAACK,UAAU,CAACR,QAAQ,CAAC,EAAE;IAC3B,OAAO,MAAMG,gBAAE,CAACM,MAAM,CAACT,QAAQ,CAAC;EAClC;EAEA,OAAOU,OAAO,CAACC,OAAO,EAAE;AAC1B;AAEO,SAASC,cAAc,CAACd,SAAiB,EAAEC,QAAgB,EAAW;EAC3E,OAAOI,gBAAE,CAACK,UAAU,CAAC,IAAAP,qCAAoB,EAACH,SAAS,EAAEC,QAAQ,CAAC,CAAC;AACjE;AAEA,IAAIc,yBAA0C;AAC9C,SAASC,4BAA4B,GAAoB;EACvD,IAAI,CAACD,yBAAyB,EAAE;IAC9B,MAAME,mBAAmB,GAAGC,OAAO,CAAE,cAAa,CAAC,CAACC,OAAO;IAC3DJ,yBAAyB,GAAG,IAAIE,mBAAmB,CAAC;MAClDG,IAAI,EAAG,4BAA2B;MAClCC,QAAQ,EAAG;IACb,CAAC,CAAC,CAACC,IAAI,EAAE;EACX;EACA,OAAOP,yBAAyB;AAClC;AAEA,IAAIQ,2BAA2B,GAAGX,OAAO,CAACC,OAAO,EAAE;AAE5C,SAASW,kCAAkC,GAAkB;EAClE,OAAOD,2BAA2B;AACpC;AAEO,eAAeE,mBAAmB,CACvCxB,QAAgB,EAChByB,iBAAyB,EACV;EACfH,2BAA2B,GAAGP,4BAA4B,EAAE,CAACW,GAAG,CAC9D1B,QAAQ,EACRyB,iBAAiB,CACD;AACpB;AAEO,eAAeE,mBAAmB,CAAC3B,QAAgB,EAAmB;EAC3E,MAAMyB,iBAAiB,GAAG,MAAMV,4BAA4B,EAAE,CAACa,GAAG,CAAC5B,QAAQ,CAAC;EAC5E,IAAI,OAAOyB,iBAAiB,KAAM,QAAO,EAAE;IACzC,OAAOA,iBAAiB;EAC1B;EACA,MAAM,IAAII,KAAK,CAAE,wCAAuC7B,QAAS,IAAG,CAAC;AACvE;AAEO,eAAe8B,aAAa,CACjC/B,SAAiB,EACjBgC,QAAwB,EACxBC,qBAAoD,EACpDC,MAA8B,EACb;EACjB,MAAMC,MAAM,GAAG,MAAMP,mBAAmB,CAACI,QAAQ,CAACI,IAAI,CAAC;EAEvD,MAAMC,cAAc,GAAG,IAAAlC,qCAAoB,EAACH,SAAS,EAAEgC,QAAQ,CAACI,IAAI,CAAC;EAErE,MAAME,IAAI,GAAG,IAAAC,wCAAuB,EAClCP,QAAQ,EACRG,MAAM,EACNF,qBAAqB,EACrBC,MAAM,CACP;;EAED;EACA,MAAMM,YAAY,GAAGC,MAAM,CAACC,UAAU,CAACJ,IAAI,CAAC,GAAG,IAAI;EAEnDK,YAAK,CAACC,QAAQ,CAAC;IACbC,IAAI,EAAG,qBAAoB;IAC3BC,OAAO,EAAE;MACP7C,QAAQ,EAAE+B,QAAQ,CAACI,IAAI;MACvBlC,QAAQ,EAAEmC,cAAc;MACxBU,IAAI,EAAEP,YAAY;MAClBQ,YAAY,EAAE,IAAAC,oCAAmB,EAACX,IAAI;IACxC;EACF,CAAC,CAAC;EAEF,MAAM,IAAAY,oCAAiB,EAACb,cAAc,EAAEC,IAAI,CAAC;EAC7C,OAAOA,IAAI;AACb;AAEO,eAAea,cAAc,CAClCnD,SAAiB,EACjB;EAAEoD,kBAAkB;EAAEhC;AAAmB,CAAC,EAC1CiC,iBAAgC,EACf;EACjB,MAAMlB,MAAM,GAAG5B,IAAI,CAACC,KAAK,CACvB,CAAC,MAAMoB,mBAAmB,CAAE,UAASR,IAAK,EAAC,CAAC,EAAEkC,QAAQ,EAAE,CACzD;EAED,MAAMjB,cAAc,GAAGD,aAAI,CAACmB,IAAI,CAACvD,SAAS,EAAG,YAAW,EAAG,GAAEoB,IAAK,OAAM,CAAC;EAEzE,MAAMoC,SAAqB,GAAG;IAC5BJ,kBAAkB;IAClBjB,MAAM;IACNkB;EACF,CAAC;EAED,MAAMf,IAAI,GAAG/B,IAAI,CAACkD,SAAS,CAACD,SAAS,CAAC;EAEtC,MAAME,aAAa,GAAGjB,MAAM,CAACC,UAAU,CAACJ,IAAI,CAAC,GAAG,IAAI;EAEpDK,YAAK,CAACC,QAAQ,CAAC;IACbC,IAAI,EAAG,sBAAqB;IAC5BC,OAAO,EAAE;MACPa,SAAS,EAAEvC,IAAI;MACflB,QAAQ,EAAEmC,cAAc;MACxBU,IAAI,EAAEW,aAAa;MACnBE,aAAa,EAAE,IAAAX,oCAAmB,EAACX,IAAI;IACzC;EACF,CAAC,CAAC;EAEF,MAAM,IAAAY,oCAAiB,EAACb,cAAc,EAAEC,IAAI,CAAC;EAC7C,OAAOA,IAAI;AACb;AAEO,eAAeuB,aAAa,CACjC7D,SAAiB,EACjB2D,SAAiB,EACkB;EACnC,MAAMzD,QAAQ,GAAGkC,aAAI,CAACmB,IAAI,CAACvD,SAAS,EAAG,YAAW,EAAG,GAAE2D,SAAU,OAAM,CAAC;EACxE,MAAMvD,WAAW,GAAG,MAAMC,gBAAE,CAACC,QAAQ,CAACJ,QAAQ,EAAG,OAAM,CAAC;EACxD,OAAOK,IAAI,CAACC,KAAK,CAACJ,WAAW,CAAC;AAChC;AAEA,IAAI0D,cAAc,GAAG,KAAK;AAC1B,IAAIC,UAAU,GAAG,KAAK;AAEf,SAASC,eAAe,GAAY;EACzC,OAAOF,cAAc;AACvB;AAEA,IAAIG,kBAAkB,GAAG,KAAK;AAC9B,MAAMC,mBAAmB,GAAG,EAAE;AAYvB,eAAeC,KAAK,CAACC,UAAiB,EAAiB;EAAA;EAC5D,IAAIL,UAAU,EAAE;IACd;IACA;EACF;EACA,MAAMvC,kCAAkC,EAAE;EAC1CsC,cAAc,GAAG,KAAK;EACtBC,UAAU,GAAG,IAAI;EACjB,MAAM;IACJM,qBAAqB;IACrBC,KAAK;IACLC,OAAO;IACPC,uBAAuB;IACvBC,OAAO;IACPvC,MAAM;IACNwC,gBAAgB;IAChBC;EACF,CAAC,GAAGhC,YAAK,CAACiC,QAAQ,EAAE;EACpB,MAAMC,OAAO,GAAG,CAAAN,OAAO,aAAPA,OAAO,qCAAPA,OAAO,CAAEO,CAAC,+CAAV,WAAa,CAAC,CAAC,MAAM,SAAQ;EAE7C,MAAM;IAAEC,SAAS;IAAEC;EAAW,CAAC,GAAGX,qBAAqB;EACvD,IAAIY,qBAAqB;EAEzB,IAAIC,uBAAuB;EAE3B,IAAIH,SAAS,CAAChC,IAAI,GAAG,CAAC,EAAE;IACtB;IACA;IACA;IACAmC,uBAAuB,GAAG,MAAM,IAAAC,kCAAoB,GAAE;EACxD,CAAC,MAAM,IAAIR,aAAa,CAACS,MAAM,GAAG,CAAC,IAAInB,kBAAkB,EAAE;IACzDA,kBAAkB,GAAG,KAAK;IAE1BoB,iBAAQ,CAACC,IAAI,CACV,6QAA4QX,aAAa,CACvRY,GAAG,CAACC,CAAC,IAAIA,CAAC,CAACC,UAAU,CAAC,CACtBC,KAAK,CAAC,CAAC,EAAExB,mBAAmB,CAAC,CAC7BX,IAAI,CAAE,GAAE,CAAE,GACXoB,aAAa,CAACS,MAAM,GAAGlB,mBAAmB,GACrC,eACCS,aAAa,CAACS,MAAM,GAAGlB,mBACxB,6DAA4D,GAC5D,EACN,EAAC,CACH;IAEDgB,uBAAuB,GAAG,MAAM,IAAAC,kCAAoB,GAAE;EACxD,CAAC,MAAM,IAAIR,aAAa,CAACS,MAAM,GAAG,CAAC,EAAE;IACnCnB,kBAAkB,GAAG,IAAI;EAC3B;EAEA,IAAIc,SAAS,CAAChC,IAAI,GAAG,CAAC,IAAIiC,UAAU,CAACjC,IAAI,GAAG,CAAC,EAAE;IAC7CkC,qBAAqB,GAAGI,iBAAQ,CAACM,cAAc,CAC5C,sEAAqE,EACtEZ,SAAS,CAAChC,IAAI,GAAGiC,UAAU,CAACjC,IAAI,EAChC,CAAC,EACD;MAAE6C,EAAE,EAAG,kCAAiC;MAAExB;IAAW,CAAC,CACvD;IACDa,qBAAqB,CAACY,KAAK,EAAE;EAC/B;EAEA,MAAMC,UAAU,GAAG,IAAAC,cAAK,EAA2B,OAAOC,IAAI,EAAEC,EAAE,KAAK;IACrE,IAAID,IAAI,CAACnD,IAAI,KAAM,MAAK,EAAE;MACxB,MAAM;QAAE5C;MAAS,CAAC,GAAG+F,IAAI;MACzB,MAAME,IAAI,GAAG5B,KAAK,CAACzC,GAAG,CAAC5B,QAAQ,CAAC;MAEhC,IAAIkG,uBAAuB,GAAG,IAAI;;MAElC;MACA;MACA;MACA;MACA;MACA;MACA,IAAID,IAAI,EAAE;QACR,IAAIA,IAAI,CAAC9D,IAAI,IAAI8C,uBAAuB,EAAE;UACxCgB,IAAI,CAACT,UAAU,GAAGP,uBAAuB,CAACrD,GAAG,CAACqE,IAAI,CAAC9D,IAAI,CAAC;QAC1D;QAEA,IAAI,CAACyC,OAAO,IAAIuB,OAAO,CAACC,GAAG,CAACC,sBAAsB,EAAE;UAClD;UACA;UACA;UACA;UACA,MAAMC,KAAK,GAAG9B,OAAO,CAAC+B,cAAc,CAAC3E,GAAG,CAACqE,IAAI,CAAC9D,IAAI,CAAC;UACnD,IAAI,CAACmE,KAAK,EAAE;YACV;YACA,MAAM,IAAIzE,KAAK,CACZ,iEAAgE,CAClE;UACH;UAEA,IAAI,IAAA2E,gBAAO,EAACF,KAAK,CAACG,KAAK,EAAEC,4BAAmB,CAAC,EAAE;YAC7C;YACAC,YAAY,CAAC,MAAMX,EAAE,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;YAClC;UACF;QACF;;QAEA;QACA;QACA,IAAI,CAACpB,OAAO,IAAKA,OAAO,IAAI,IAAAgC,qBAAW,EAACX,IAAI,CAAC,KAAM,KAAK,EAAE;UACxD,MAAM7C,iBAAiB,GACrBmB,uBAAuB,CAAC3C,GAAG,CAACqE,IAAI,CAACY,aAAa,CAAC,IAAI,EAAE;UAEvD,IAAI;YACF,MAAM3E,MAAM,GAAG,MAAMJ,aAAa,CAChCK,aAAI,CAACmB,IAAI,CAACgB,OAAO,CAACwC,SAAS,EAAG,QAAO,CAAC,EACtC;cACE,GAAGb,IAAI;cACP7C;YACF,CAAC,EACDqB,gBAAgB,EAChBxC,MAAM,CACP;YAED,IAAI,CAAC2C,OAAO,EAAE;cACZmC,kCAAgB,CAACC,YAAY,CAAC;gBAC5BrB,EAAE,EAAE3F,QAAQ;gBACZkC,MAAM,EAAE5B,IAAI,CAACC,KAAK,CAAC2B,MAAM;cAC3B,CAAC,CAAC;YACJ;UACF,CAAC,CAAC,OAAO+E,CAAC,EAAE;YACVf,uBAAuB,GAAG,KAAK;YAC/Bd,iBAAQ,CAAC8B,YAAY,CAClB,mCAAkCjB,IAAI,CAAC9D,IAAK,EAAC,EAC9C8E,CAAC,CACF;UACH;UACAjC,qBAAqB,CAACmC,IAAI,EAAE;QAC9B;MACF;MAEA,IAAIjB,uBAAuB,EAAE;QAC3BxD,YAAK,CAACC,QAAQ,CAAC;UACbC,IAAI,EAAG,+BAA8B;UACrCC,OAAO,EAAE;YACPoD,IAAI,EAAEjG;UACR;QACF,CAAC,CAAC;MACJ;IACF,CAAC,MAAM,IAAI+F,IAAI,CAACnD,IAAI,KAAM,OAAM,EAAE;MAChC,MAAM;QAAEc;MAAU,CAAC,GAAGqC,IAAI;MAC1B,MAAMN,KAAK,GAAGxD,MAAM,CAACL,GAAG,CAAC8B,SAAS,CAAC;MACnC,IAAI+B,KAAK,EAAE;QACT,MAAMrC,iBAAiB,GACrBmB,uBAAuB,CAAC3C,GAAG,CAAC6D,KAAK,CAACoB,aAAa,CAAC,IAAI,EAAE;QAExD,MAAM3E,MAAM,GAAG,MAAMgB,cAAc,CACjCf,aAAI,CAACmB,IAAI,CAACgB,OAAO,CAACwC,SAAS,EAAG,QAAO,CAAC,EACtCrB,KAAK,EACLrC,iBAAiB,CAClB;QAED4B,qBAAqB,CAACmC,IAAI,EAAE;QAE5B,IAAI,CAACvC,OAAO,EAAE;UACZmC,kCAAgB,CAACK,aAAa,CAAC;YAC7BzB,EAAE,EAAEjC,SAAS;YACbxB,MAAM,EAAE5B,IAAI,CAACC,KAAK,CAAC2B,MAAM;UAC3B,CAAC,CAAC;QACJ;MACF;MAEAQ,YAAK,CAACC,QAAQ,CAAC;QACbC,IAAI,EAAG,gCAA+B;QACtCC,OAAO,EAAE;UACP1B,IAAI,EAAEuC;QACR;MACF,CAAC,CAAC;IACJ;;IAEA;IACA;IACAiD,YAAY,CAAC,MAAMX,EAAE,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;IAClC;EACF,CAAC,EAAE,EAAE,CAAC;EAEN,KAAK,MAAMhG,QAAQ,IAAI8E,SAAS,EAAE;IAChCe,UAAU,CAACwB,IAAI,CAAC;MAAEzE,IAAI,EAAG,MAAK;MAAE5C;IAAS,CAAC,EAAE,MAAM,CAAC,CAAC,CAAC;EACvD;EACA,KAAK,MAAM0D,SAAS,IAAIqB,UAAU,EAAE;IAClCc,UAAU,CAACwB,IAAI,CAAC;MAAEzE,IAAI,EAAG,OAAM;MAAEc;IAAU,CAAC,EAAE,MAAM,CAAC,CAAC,CAAC;EACzD;EAEA,IAAI,CAACmC,UAAU,CAACyB,IAAI,EAAE,EAAE;IACtB,MAAM,IAAI3G,OAAO,CAACC,OAAO,IAAI;MAC3BiF,UAAU,CAAC0B,KAAK,GAAG3G,OAAwB;IAC7C,CAAC,CAAC;EACJ;EACA,IAAIoE,qBAAqB,EAAE;IACzBA,qBAAqB,CAACwC,GAAG,EAAE;EAC7B;EAEA1D,UAAU,GAAG,KAAK;EAElB;AACF;AAEO,SAAS2D,YAAY,CAACtD,UAAiB,EAAQ;EACpD,IAAI,IAAAuD,qCAAsB,GAAE,EAAE;IAC5B7D,cAAc,GAAG,IAAI;EACvB,CAAC,MAAM;IACLK,KAAK,CAACC,UAAU,CAAC;EACnB;AACF;AAEO,eAAewD,mBAAmB,CAACxD,UAAgB,EAAiB;EACzE,IAAI,EAAE,MAAM/D,gBAAE,CAACwH,UAAU,CAAE,kBAAiB,CAAC,CAAC,EAAE;IAC9C;EACF;;EAEA;EACA;EACA;;EAEA,MAAMC,QAAQ,GAAGzC,iBAAQ,CAAC0C,aAAa,CAAE,6BAA4B,EAAE;IACrE3D;EACF,CAAC,CAAC;EACF0D,QAAQ,CAACjC,KAAK,EAAE;EAEhB,MAAMmC,+BAA+B,GAAG,MAAM,IAAIpH,OAAO,CACvD,CAACC,OAAO,EAAEoH,MAAM,KAAK;IACnB,MAAMC,OAAO,GAAG,IAAIC,GAAG,EAAU;IAEjC,MAAMC,MAAM,GAAG,IAAAC,cAAY,EAAE,kBAAiB,CAAC;IAE/CD,MAAM,CAACE,EAAE,CAAE,MAAK,EAAGC,IAAW,IAAK;MACjC,IAAIA,IAAI,CAACnH,IAAI,KAAM,gBAAe,EAAE;QAClC8G,OAAO,CAACM,GAAG,CAACD,IAAI,CAACnG,IAAI,CAAC;MACxB;IACF,CAAC,CAAC;IAEFgG,MAAM,CAACE,EAAE,CAAE,OAAM,EAAEpB,CAAC,IAAI;MACtBe,MAAM,CAACf,CAAC,CAAC;IACX,CAAC,CAAC;IAEFkB,MAAM,CAACE,EAAE,CAAE,KAAI,EAAE,MAAMzH,OAAO,CAACqH,OAAO,CAAC,CAAC;EAC1C,CAAC,CACF;EAED,MAAMO,qBAAqB,GAAG,IAAIN,GAAG,EAAU;EAC/CxF,YAAK,CAACiC,QAAQ,EAAE,CAACN,KAAK,CAACoE,OAAO,CAACxC,IAAI,IAAI;IACrCuC,qBAAqB,CAACD,GAAG,CAAC,IAAArI,qCAAoB,EAAE,QAAO,EAAE+F,IAAI,CAAC9D,IAAI,CAAC,CAAC;EACtE,CAAC,CAAC;EAEF,MAAMuG,gBAAsC,GAAG,EAAE;EACjDX,+BAA+B,CAACU,OAAO,CAACE,gBAAgB,IAAI;IAC1D,IAAI,CAACH,qBAAqB,CAACI,GAAG,CAACD,gBAAgB,CAAC,EAAE;MAChDD,gBAAgB,CAACrB,IAAI,CAACjH,gBAAE,CAACM,MAAM,CAACiI,gBAAgB,CAAC,CAAC;IACpD;EACF,CAAC,CAAC;EAEF,MAAMhI,OAAO,CAACkI,GAAG,CAACH,gBAAgB,CAAC;EAEnCb,QAAQ,CAACL,GAAG,EAAE;AAChB;AAcO,SAASsB,6BAA6B,CAC3CC,KAA+B,EACC;EAAA;EAChC,MAAMC,YAAY,GAAG;IACnB,IAAI,iBAAAD,KAAK,CAAC7G,MAAM,0CAAZ,cAAc+G,WAAW,GACzB;MAAEA,WAAW,EAAEF,KAAK,CAAC7G,MAAM,CAAC+G;IAAY,CAAC,GACzC,CAAC,CAAC,CAAC;IACP,IAAI,kBAAAF,KAAK,CAAC7G,MAAM,2CAAZ,eAAc+G,WAAW,GACzB;MAAEA,WAAW,EAAEF,KAAK,CAAC7G,MAAM,CAAC+G;IAAY,CAAC,GACzC,CAAC,CAAC;EACR,CAAC;EAED,MAAMC,cAAc,GAAG;IACrB,IAAI,kBAAAH,KAAK,CAAC7G,MAAM,2CAAZ,eAAciH,MAAM,GAAG;MAAEC,OAAO,EAAEL,KAAK,CAAC7G,MAAM,CAACiH;IAAO,CAAC,GAAG,CAAC,CAAC,CAAC;IACjE,IAAIJ,KAAK,CAACM,kBAAkB,GACxB;MAAEC,aAAa,EAAEP,KAAK,CAACM;IAAmB,CAAC,GAC3C,CAAC,CAAC;EACR,CAAC;EAED,OAAO;IACLF,MAAM,EAAE;MACN,GAAGD;IACL,CAAC;IACD/G,IAAI,EAAE4G,KAAK,CAAC5G,IAAI;IAChBoH,SAAS,EAAER,KAAK,CAACQ,SAAS;IAC1BC,SAAS,EAAET,KAAK,CAACS,SAAS;IAC1B,GAAGR;EACL,CAAC;AACH"}