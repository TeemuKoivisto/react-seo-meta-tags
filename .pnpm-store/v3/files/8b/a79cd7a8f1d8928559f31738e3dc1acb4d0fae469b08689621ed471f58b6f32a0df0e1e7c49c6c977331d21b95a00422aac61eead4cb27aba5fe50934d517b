{"version":3,"file":"actions.js","names":["callApi","store","event","callRealApi","payload","addNodeMutation","assign","nodeMutationBatch","push","extractQueries","sendParent","waitingActions"],"sources":["../../../src/state-machines/waiting/actions.ts"],"sourcesContent":["import {\n  AssignAction,\n  assign,\n  ActionFunctionMap,\n  sendParent,\n  AnyEventObject,\n  ActionFunction,\n} from \"xstate\"\nimport { IWaitingContext } from \"./types\"\nimport { AnyAction } from \"redux\"\nimport { callRealApi } from \"../../utils/call-deferred-api\"\n\nexport const callApi: ActionFunction<IWaitingContext, AnyEventObject> = (\n  { store },\n  event\n) => callRealApi(event.payload, store)\n\n/**\n * Event handler used when we're not ready to process node mutations.\n * Instead we add it to a batch to process when we're next idle\n */\nexport const addNodeMutation: AssignAction<IWaitingContext, AnyAction> = assign(\n  {\n    nodeMutationBatch: ({ nodeMutationBatch = [] }, { payload }) => {\n      // It's not pretty, but it's much quicker than concat\n      nodeMutationBatch.push(payload)\n      return nodeMutationBatch\n    },\n  }\n)\n\nexport const extractQueries = sendParent<IWaitingContext, AnyEventObject>(\n  `EXTRACT_QUERIES_NOW`\n)\n\nexport const waitingActions: ActionFunctionMap<IWaitingContext, AnyAction> = {\n  addNodeMutation,\n  extractQueries,\n  callApi,\n}\n"],"mappings":";;;;AAAA;AAUA;AAEO,MAAMA,OAAwD,GAAG,CACtE;EAAEC;AAAM,CAAC,EACTC,KAAK,KACF,IAAAC,4BAAW,EAACD,KAAK,CAACE,OAAO,EAAEH,KAAK,CAAC;;AAEtC;AACA;AACA;AACA;AAHA;AAIO,MAAMI,eAAyD,GAAG,IAAAC,cAAM,EAC7E;EACEC,iBAAiB,EAAE,CAAC;IAAEA,iBAAiB,GAAG;EAAG,CAAC,EAAE;IAAEH;EAAQ,CAAC,KAAK;IAC9D;IACAG,iBAAiB,CAACC,IAAI,CAACJ,OAAO,CAAC;IAC/B,OAAOG,iBAAiB;EAC1B;AACF,CAAC,CACF;AAAA;AAEM,MAAME,cAAc,GAAG,IAAAC,kBAAU,EACrC,qBAAoB,CACtB;AAAA;AAEM,MAAMC,cAA6D,GAAG;EAC3EN,eAAe;EACfI,cAAc;EACdT;AACF,CAAC;AAAA"}