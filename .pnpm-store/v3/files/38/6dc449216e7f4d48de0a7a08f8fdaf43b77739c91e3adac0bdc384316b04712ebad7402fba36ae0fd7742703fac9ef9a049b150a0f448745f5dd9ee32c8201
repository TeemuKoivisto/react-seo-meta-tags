{"version":3,"file":"index.js","names":["process","env","GATSBY_EXPERIMENTAL_QUERY_CONCURRENCY","console","info","concurrency","Number","calcDirtyQueryIds","state","trackedQueries","trackedComponents","deletedQueries","queries","queriesWithBabelErrors","Set","component","values","hasFlag","errors","FLAG_ERROR_EXTRACTION","queryId","pages","add","dirtyQueryIds","query","has","dirty","push","groupQueryIds","queryIds","grouped","p","startsWith","store","getState","staticQueryIds","static","pageQueryIds","page","map","path","get","filter","Boolean","sliceQueryIds","slice","createQueue","createJobFn","activity","graphqlRunner","graphqlTracing","GraphQLRunner","worker","cb","job","setImmediate","undefined","queryRunner","span","then","result","tick","catch","error","fastq","processQueries","onQueryDone","Promise","resolve","reject","fastQueue","forEach","err","res","kill","idle","drain","createStaticQueryJob","staticQueryComponents","hash","id","componentPath","queryType","context","createSliceQueryJob","sliceName","substring","sliceDef","slices","components","onDevelopStaticQueryDone","websocketManager","emitStaticQueryData","processStaticQueries","processedQueries","NODE_ENV","createPageDependencyBatcher","flush","processSliceQueries","processPageQueries","createPageQueryJob"],"sources":["../../src/query/index.ts"],"sourcesContent":["import _ from \"lodash\"\nimport fastq from \"fastq\"\nimport { IProgressReporter } from \"gatsby-cli/lib/reporter/reporter-progress\"\nimport { store } from \"../redux\"\nimport { IGatsbyPage, IGatsbyState } from \"../redux/types\"\nimport { hasFlag, FLAG_ERROR_EXTRACTION } from \"../redux/reducers/queries\"\nimport { IQueryJob, queryRunner } from \"./query-runner\"\nimport {\n  IStaticQueryResult,\n  websocketManager,\n} from \"../utils/websocket-manager\"\nimport { GraphQLRunner } from \"./graphql-runner\"\nimport { IGroupedQueryIds } from \"../services\"\nimport { createPageDependencyBatcher } from \"../redux/actions/add-page-dependency\"\n\nif (process.env.GATSBY_EXPERIMENTAL_QUERY_CONCURRENCY) {\n  console.info(\n    `GATSBY_EXPERIMENTAL_QUERY_CONCURRENCY: Running with concurrency set to \\`${process.env.GATSBY_EXPERIMENTAL_QUERY_CONCURRENCY}\\``\n  )\n}\n\nconst concurrency =\n  Number(process.env.GATSBY_EXPERIMENTAL_QUERY_CONCURRENCY) || 4\n\n/**\n * Calculates the set of dirty query IDs (page.paths, or staticQuery.id's).\n *\n * Dirty state is tracked in `queries` reducer, here we simply filter\n * them from all tracked queries.\n */\nexport function calcDirtyQueryIds(state: IGatsbyState): Array<string> {\n  const { trackedQueries, trackedComponents, deletedQueries } = state.queries\n\n  const queriesWithBabelErrors = new Set()\n  for (const component of trackedComponents.values()) {\n    if (hasFlag(component.errors, FLAG_ERROR_EXTRACTION)) {\n      for (const queryId of component.pages) {\n        queriesWithBabelErrors.add(queryId)\n      }\n    }\n  }\n  // Note: trackedQueries contains both - page and static query ids\n  const dirtyQueryIds: Array<string> = []\n  for (const [queryId, query] of trackedQueries) {\n    if (deletedQueries.has(queryId)) {\n      continue\n    }\n    if (query.dirty > 0 && !queriesWithBabelErrors.has(queryId)) {\n      dirtyQueryIds.push(queryId)\n    }\n  }\n  return dirtyQueryIds\n}\n\nexport { calcDirtyQueryIds as calcInitialDirtyQueryIds }\n\n/**\n * Groups queryIds by whether they are static or page queries.\n */\nexport function groupQueryIds(queryIds: Array<string>): IGroupedQueryIds {\n  const grouped = _.groupBy(queryIds, p => {\n    if (p.startsWith(`sq--`)) {\n      return `static`\n    } else if (p.startsWith(`slice--`)) {\n      return `slice`\n    } else {\n      return `page`\n    }\n  })\n\n  const { pages } = store.getState()\n\n  return {\n    staticQueryIds: grouped?.static || [],\n    pageQueryIds:\n      grouped?.page\n        ?.map(path => pages.get(path) as IGatsbyPage)\n        ?.filter(Boolean) || [],\n    sliceQueryIds: grouped?.slice || [],\n  }\n}\n\nfunction createQueue<QueryIDType>({\n  createJobFn,\n  state,\n  activity,\n  graphqlRunner,\n  graphqlTracing,\n}: {\n  createJobFn: (\n    state: IGatsbyState,\n    queryId: QueryIDType\n  ) => IQueryJob | undefined\n  state: IGatsbyState\n  activity: IProgressReporter\n  graphqlRunner: GraphQLRunner\n  graphqlTracing: boolean\n}): fastq.queue<QueryIDType, any> {\n  if (!graphqlRunner) {\n    graphqlRunner = new GraphQLRunner(store, { graphqlTracing })\n  }\n  state = state || store.getState()\n\n  function worker(queryId: QueryIDType, cb): void {\n    const job = createJobFn(state, queryId)\n    if (!job) {\n      setImmediate(() => cb(null, undefined))\n      return\n    }\n    queryRunner(graphqlRunner, job, activity?.span)\n      .then(result => {\n        if (activity.tick) {\n          activity.tick()\n        }\n        // Note: we need setImmediate to ensure garbage collection has a chance\n        //  to get started during query running\n        setImmediate(() => cb(null, { job, result }))\n      })\n      .catch(error => {\n        cb(error)\n      })\n  }\n  // Note: fastq.promise version is much slower\n  return fastq(worker, concurrency)\n}\n\nasync function processQueries<QueryIDType>({\n  queryIds,\n  createJobFn,\n  onQueryDone,\n  state,\n  activity,\n  graphqlRunner,\n  graphqlTracing,\n}: {\n  queryIds: Array<QueryIDType>\n  createJobFn: (\n    state: IGatsbyState,\n    queryId: QueryIDType\n  ) => IQueryJob | undefined\n  onQueryDone:\n    | (({ job, result }: { job: IQueryJob; result: unknown }) => void)\n    | undefined\n  state: IGatsbyState\n  activity: IProgressReporter\n  graphqlRunner: GraphQLRunner\n  graphqlTracing: boolean\n}): Promise<void> {\n  return new Promise((resolve, reject) => {\n    const fastQueue = createQueue({\n      createJobFn,\n      state,\n      activity,\n      graphqlRunner,\n      graphqlTracing,\n    })\n\n    queryIds.forEach((queryId: QueryIDType) => {\n      fastQueue.push(queryId, (err, res) => {\n        if (err) {\n          fastQueue.kill()\n          reject(err)\n          return\n        }\n        if (res && onQueryDone) {\n          onQueryDone(res)\n        }\n      })\n    })\n\n    if (!fastQueue.idle()) {\n      fastQueue.drain = (): any => resolve()\n    } else {\n      resolve()\n    }\n  })\n}\n\nfunction createStaticQueryJob(\n  state: IGatsbyState,\n  queryId: string\n): IQueryJob | undefined {\n  const component = state.staticQueryComponents.get(queryId)\n\n  if (!component) {\n    return undefined\n  }\n\n  const { hash, id, query, componentPath } = component\n\n  return {\n    id: queryId,\n    query,\n    queryType: `static`,\n    hash,\n    componentPath,\n    context: { path: id },\n  }\n}\n\nfunction createSliceQueryJob(\n  state: IGatsbyState,\n  queryId: string\n): IQueryJob | undefined {\n  const sliceName = queryId.substring(7) // remove \"slice--\" prefix\n\n  const sliceDef = state.slices.get(sliceName)\n  if (!sliceDef) {\n    return undefined\n  }\n\n  const component = state.components.get(sliceDef.componentPath)\n\n  if (!component) {\n    return undefined\n  }\n\n  const { componentPath, context } = sliceDef\n  const { query } = component\n\n  return {\n    id: queryId,\n    query,\n    queryType: `slice`,\n    componentPath,\n    context: {\n      path: queryId,\n      ...context,\n    },\n  }\n}\n\nfunction onDevelopStaticQueryDone({\n  job,\n  result,\n}: {\n  job: IQueryJob\n  result: IStaticQueryResult[\"result\"]\n}): void {\n  if (!job.hash) {\n    return\n  }\n\n  websocketManager.emitStaticQueryData({\n    result,\n    id: job.hash,\n  })\n}\n\nexport async function processStaticQueries(\n  queryIds: IGroupedQueryIds[\"staticQueryIds\"],\n  { state, activity, graphqlRunner, graphqlTracing }\n): Promise<void> {\n  const processedQueries = await processQueries<string>({\n    queryIds,\n    createJobFn: createStaticQueryJob,\n    onQueryDone:\n      process.env.NODE_ENV === `production`\n        ? undefined\n        : onDevelopStaticQueryDone,\n    state,\n    activity,\n    graphqlRunner,\n    graphqlTracing,\n  })\n\n  // at this point, we're done grabbing page dependencies, so we need to\n  // flush out the batcher in case there are any left\n  createPageDependencyBatcher.flush()\n\n  return processedQueries\n}\n\nexport async function processSliceQueries(\n  queryIds: IGroupedQueryIds[\"sliceQueryIds\"],\n  { state, activity, graphqlRunner, graphqlTracing }\n): Promise<void> {\n  const processedQueries = await processQueries<string>({\n    queryIds,\n    createJobFn: createSliceQueryJob,\n    onQueryDone: undefined, // maybe this will later need same HMR stuff as static query\n    state,\n    activity,\n    graphqlRunner,\n    graphqlTracing,\n  })\n\n  // at this point, we're done grabbing page dependencies, so we need to\n  // flush out the batcher in case there are any left\n  createPageDependencyBatcher.flush()\n\n  return processedQueries\n}\n\nexport async function processPageQueries(\n  queryIds: IGroupedQueryIds[\"pageQueryIds\"],\n  { state, activity, graphqlRunner, graphqlTracing }\n): Promise<void> {\n  const processedQueries = await processQueries<IGatsbyPage>({\n    queryIds,\n    createJobFn: createPageQueryJob,\n    onQueryDone: undefined,\n    state,\n    activity,\n    graphqlRunner,\n    graphqlTracing,\n  })\n\n  // at this point, we're done grabbing page dependencies, so we need to\n  // flush out the batcher in case there are any left\n  createPageDependencyBatcher.flush()\n\n  return processedQueries\n}\n\nfunction createPageQueryJob(\n  state: IGatsbyState,\n  page: IGatsbyPage\n): IQueryJob | undefined {\n  const component = state.components.get(page.componentPath)\n\n  if (!component) {\n    return undefined\n  }\n\n  const { path, componentPath, context } = page\n  const { query } = component\n\n  return {\n    id: path,\n    query,\n    queryType: `page`,\n    componentPath,\n    context: {\n      ...page,\n      ...context,\n    },\n  }\n}\n"],"mappings":"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"}