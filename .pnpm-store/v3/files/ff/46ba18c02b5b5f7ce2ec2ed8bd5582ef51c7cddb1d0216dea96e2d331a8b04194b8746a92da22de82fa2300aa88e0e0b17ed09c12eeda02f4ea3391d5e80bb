{"version":3,"file":"inference-metadata.js","names":["ignoredFields","Set","NodeInterfaceFields","initialTypeMetadata","incrementalReducer","state","action","type","typeDefs","Array","isArray","payload","ignoredTypes","reduce","typesWithoutInference","forEach","ignore","nodes","typeName","clearExistingMetadata","ignored","initialMetadata","addNodes","types","disable","node","oldNode","internal","deleteNode","addNode","addedField","previousFields","fields","dirty","Object","keys","StepsEnum","initialState","step","initialBuild","typeMap","inferenceMetadataReducer","incrementalBuild"],"sources":["../../../src/redux/reducers/inference-metadata.ts"],"sourcesContent":["// Tracking structure of nodes to utilize this metadata for schema inference\n// Type descriptors stay relevant at any point in time making incremental inference trivial\nimport { omit } from \"lodash\"\nimport {\n  addNode,\n  addNodes,\n  deleteNode,\n  ignore,\n  disable,\n} from \"../../schema/infer/inference-metadata\"\nimport { NodeInterfaceFields } from \"../../schema/types/node-interface\"\nimport { typesWithoutInference } from \"../../schema/types/type-defs\"\n\nimport { IGatsbyState, ActionsUnion } from \"../types\"\n\nconst ignoredFields: Set<string> = new Set(NodeInterfaceFields)\n\nconst initialTypeMetadata = (): { ignoredFields: Set<string> } => {\n  return { ignoredFields }\n}\n\nconst incrementalReducer = (\n  state: IGatsbyState[\"inferenceMetadata\"][\"typeMap\"] = {},\n  action: ActionsUnion\n): IGatsbyState[\"inferenceMetadata\"][\"typeMap\"] => {\n  switch (action.type) {\n    case `CREATE_TYPES`: {\n      const typeDefs = Array.isArray(action.payload)\n        ? action.payload\n        : [action.payload]\n      const ignoredTypes = typeDefs.reduce(typesWithoutInference, [])\n      ignoredTypes.forEach(type => {\n        state[type] = ignore(state[type] || initialTypeMetadata())\n      })\n      return state\n    }\n\n    case `BUILD_TYPE_METADATA`: {\n      // Overwrites existing metadata\n      const { nodes, typeName, clearExistingMetadata } = action.payload\n      if (!state[typeName]?.ignored) {\n        const initialMetadata =\n          clearExistingMetadata || !state[typeName]\n            ? initialTypeMetadata()\n            : state[typeName]\n\n        state[typeName] = addNodes(initialMetadata, nodes)\n      }\n      return state\n    }\n\n    case `DISABLE_TYPE_INFERENCE`: {\n      // Note: types disabled here will be re-enabled after BUILD_TYPE_METADATA\n      const types = action.payload\n      types.forEach(type => {\n        state[type] = disable(state[type] || initialTypeMetadata())\n      })\n      return state\n    }\n\n    case `CREATE_NODE`: {\n      const { payload: node, oldNode } = action\n      const { type } = node.internal\n      if (oldNode) {\n        state[type] = deleteNode(state[type] || initialTypeMetadata(), oldNode)\n      }\n      state[type] = addNode(state[type] || initialTypeMetadata(), node)\n      return state\n    }\n\n    case `DELETE_NODE`: {\n      const node = action.payload\n      if (!node) return state\n      const { type } = node.internal\n      state[type] = deleteNode(state[type] || initialTypeMetadata(), node)\n      return state\n    }\n\n    case `ADD_FIELD_TO_NODE`: {\n      const { payload: node, addedField } = action\n      const { type } = node.internal\n\n      // Must unregister previous fields first.\n      // Can't simply add { fields: { [addedField]: node.fields[addedField] } }\n      // because it will count `fields` key twice for the same node\n      const previousFields = omit(node.fields, [addedField])\n      state[type] = deleteNode(state[type], { ...node, fields: previousFields })\n      state[type] = addNode(state[type], { ...node, fields: node.fields })\n\n      // TODO: there might be an edge case when the same field is \"added\" twice.\n      //   Then we'll count it twice in metadata. The only way to avoid it as I see it\n      //   is to pass original node before modifications along with a new node\n      //   in action payload and utilize original `node.fields` in deleteNode call above\n      return state\n    }\n\n    case `ADD_CHILD_NODE_TO_PARENT_NODE`: {\n      // Marking parent type as dirty so that it rebuilds\n      const { type } = action.payload.internal\n      state[type].dirty = true\n      return state\n    }\n\n    case `SET_SCHEMA`: {\n      Object.keys(state).forEach(type => {\n        state[type].dirty = false\n      })\n      return state\n    }\n\n    default:\n      return state\n  }\n}\n\nenum StepsEnum {\n  initialBuild = `initialBuild`,\n  incrementalBuild = `incrementalBuild`,\n}\n\nconst initialState = (): IGatsbyState[\"inferenceMetadata\"] => {\n  return {\n    step: StepsEnum.initialBuild, // `initialBuild` | `incrementalBuild`\n    typeMap: {},\n  }\n}\n\nexport const inferenceMetadataReducer = (\n  state: IGatsbyState[\"inferenceMetadata\"] = initialState(),\n  action: ActionsUnion\n): IGatsbyState[\"inferenceMetadata\"] => {\n  switch (action.type) {\n    case `CREATE_NODE`:\n    case `DELETE_NODE`:\n    case `ADD_CHILD_NODE_TO_PARENT_NODE`:\n    case `ADD_FIELD_TO_NODE`: {\n      // Perf: disable incremental inference until the first schema build.\n      // There are plugins which create and delete lots of nodes during bootstrap,\n      // which makes this reducer to do a lot of unnecessary work.\n      // Instead we defer the initial metadata creation until the first schema build\n      // and then enable incremental updates explicitly\n      if (state.step === StepsEnum.initialBuild) {\n        return state\n      }\n      state.typeMap = incrementalReducer(state.typeMap, action)\n      return state\n    }\n\n    case `START_INCREMENTAL_INFERENCE`: {\n      return {\n        ...state,\n        step: StepsEnum.incrementalBuild,\n      }\n    }\n\n    case `DELETE_CACHE`: {\n      return initialState()\n    }\n\n    default: {\n      state.typeMap = incrementalReducer(state.typeMap, action)\n      return state\n    }\n  }\n}\n"],"mappings":";;;;;;AAGA;AAOA;AACA;AAIA,MAAMA,aAA0B,GAAG,IAAIC,GAAG,CAACC,kCAAmB,CAAC;AAE/D,MAAMC,mBAAmB,GAAG,MAAsC;EAChE,OAAO;IAAEH;EAAc,CAAC;AAC1B,CAAC;AAED,MAAMI,kBAAkB,GAAG,CACzBC,KAAmD,GAAG,CAAC,CAAC,EACxDC,MAAoB,KAC6B;EACjD,QAAQA,MAAM,CAACC,IAAI;IACjB,KAAM,cAAa;MAAE;QACnB,MAAMC,QAAQ,GAAGC,KAAK,CAACC,OAAO,CAACJ,MAAM,CAACK,OAAO,CAAC,GAC1CL,MAAM,CAACK,OAAO,GACd,CAACL,MAAM,CAACK,OAAO,CAAC;QACpB,MAAMC,YAAY,GAAGJ,QAAQ,CAACK,MAAM,CAACC,+BAAqB,EAAE,EAAE,CAAC;QAC/DF,YAAY,CAACG,OAAO,CAACR,IAAI,IAAI;UAC3BF,KAAK,CAACE,IAAI,CAAC,GAAG,IAAAS,yBAAM,EAACX,KAAK,CAACE,IAAI,CAAC,IAAIJ,mBAAmB,EAAE,CAAC;QAC5D,CAAC,CAAC;QACF,OAAOE,KAAK;MACd;IAEA,KAAM,qBAAoB;MAAE;QAAA;QAC1B;QACA,MAAM;UAAEY,KAAK;UAAEC,QAAQ;UAAEC;QAAsB,CAAC,GAAGb,MAAM,CAACK,OAAO;QACjE,IAAI,qBAACN,KAAK,CAACa,QAAQ,CAAC,4CAAf,gBAAiBE,OAAO,GAAE;UAC7B,MAAMC,eAAe,GACnBF,qBAAqB,IAAI,CAACd,KAAK,CAACa,QAAQ,CAAC,GACrCf,mBAAmB,EAAE,GACrBE,KAAK,CAACa,QAAQ,CAAC;UAErBb,KAAK,CAACa,QAAQ,CAAC,GAAG,IAAAI,2BAAQ,EAACD,eAAe,EAAEJ,KAAK,CAAC;QACpD;QACA,OAAOZ,KAAK;MACd;IAEA,KAAM,wBAAuB;MAAE;QAC7B;QACA,MAAMkB,KAAK,GAAGjB,MAAM,CAACK,OAAO;QAC5BY,KAAK,CAACR,OAAO,CAACR,IAAI,IAAI;UACpBF,KAAK,CAACE,IAAI,CAAC,GAAG,IAAAiB,0BAAO,EAACnB,KAAK,CAACE,IAAI,CAAC,IAAIJ,mBAAmB,EAAE,CAAC;QAC7D,CAAC,CAAC;QACF,OAAOE,KAAK;MACd;IAEA,KAAM,aAAY;MAAE;QAClB,MAAM;UAAEM,OAAO,EAAEc,IAAI;UAAEC;QAAQ,CAAC,GAAGpB,MAAM;QACzC,MAAM;UAAEC;QAAK,CAAC,GAAGkB,IAAI,CAACE,QAAQ;QAC9B,IAAID,OAAO,EAAE;UACXrB,KAAK,CAACE,IAAI,CAAC,GAAG,IAAAqB,6BAAU,EAACvB,KAAK,CAACE,IAAI,CAAC,IAAIJ,mBAAmB,EAAE,EAAEuB,OAAO,CAAC;QACzE;QACArB,KAAK,CAACE,IAAI,CAAC,GAAG,IAAAsB,0BAAO,EAACxB,KAAK,CAACE,IAAI,CAAC,IAAIJ,mBAAmB,EAAE,EAAEsB,IAAI,CAAC;QACjE,OAAOpB,KAAK;MACd;IAEA,KAAM,aAAY;MAAE;QAClB,MAAMoB,IAAI,GAAGnB,MAAM,CAACK,OAAO;QAC3B,IAAI,CAACc,IAAI,EAAE,OAAOpB,KAAK;QACvB,MAAM;UAAEE;QAAK,CAAC,GAAGkB,IAAI,CAACE,QAAQ;QAC9BtB,KAAK,CAACE,IAAI,CAAC,GAAG,IAAAqB,6BAAU,EAACvB,KAAK,CAACE,IAAI,CAAC,IAAIJ,mBAAmB,EAAE,EAAEsB,IAAI,CAAC;QACpE,OAAOpB,KAAK;MACd;IAEA,KAAM,mBAAkB;MAAE;QACxB,MAAM;UAAEM,OAAO,EAAEc,IAAI;UAAEK;QAAW,CAAC,GAAGxB,MAAM;QAC5C,MAAM;UAAEC;QAAK,CAAC,GAAGkB,IAAI,CAACE,QAAQ;;QAE9B;QACA;QACA;QACA,MAAMI,cAAc,GAAG,oBAAKN,IAAI,CAACO,MAAM,EAAE,CAACF,UAAU,CAAC,CAAC;QACtDzB,KAAK,CAACE,IAAI,CAAC,GAAG,IAAAqB,6BAAU,EAACvB,KAAK,CAACE,IAAI,CAAC,EAAE;UAAE,GAAGkB,IAAI;UAAEO,MAAM,EAAED;QAAe,CAAC,CAAC;QAC1E1B,KAAK,CAACE,IAAI,CAAC,GAAG,IAAAsB,0BAAO,EAACxB,KAAK,CAACE,IAAI,CAAC,EAAE;UAAE,GAAGkB,IAAI;UAAEO,MAAM,EAAEP,IAAI,CAACO;QAAO,CAAC,CAAC;;QAEpE;QACA;QACA;QACA;QACA,OAAO3B,KAAK;MACd;IAEA,KAAM,+BAA8B;MAAE;QACpC;QACA,MAAM;UAAEE;QAAK,CAAC,GAAGD,MAAM,CAACK,OAAO,CAACgB,QAAQ;QACxCtB,KAAK,CAACE,IAAI,CAAC,CAAC0B,KAAK,GAAG,IAAI;QACxB,OAAO5B,KAAK;MACd;IAEA,KAAM,YAAW;MAAE;QACjB6B,MAAM,CAACC,IAAI,CAAC9B,KAAK,CAAC,CAACU,OAAO,CAACR,IAAI,IAAI;UACjCF,KAAK,CAACE,IAAI,CAAC,CAAC0B,KAAK,GAAG,KAAK;QAC3B,CAAC,CAAC;QACF,OAAO5B,KAAK;MACd;IAEA;MACE,OAAOA,KAAK;EAAA;AAElB,CAAC;AAAA,IAEI+B,SAAS;AAAA,WAATA,SAAS;EAATA,SAAS;EAATA,SAAS;AAAA,GAATA,SAAS,KAATA,SAAS;AAKd,MAAMC,YAAY,GAAG,MAAyC;EAC5D,OAAO;IACLC,IAAI,EAAEF,SAAS,CAACG,YAAY;IAAE;IAC9BC,OAAO,EAAE,CAAC;EACZ,CAAC;AACH,CAAC;AAEM,MAAMC,wBAAwB,GAAG,CACtCpC,KAAwC,GAAGgC,YAAY,EAAE,EACzD/B,MAAoB,KACkB;EACtC,QAAQA,MAAM,CAACC,IAAI;IACjB,KAAM,aAAY;IAClB,KAAM,aAAY;IAClB,KAAM,+BAA8B;IACpC,KAAM,mBAAkB;MAAE;QACxB;QACA;QACA;QACA;QACA;QACA,IAAIF,KAAK,CAACiC,IAAI,KAAKF,SAAS,CAACG,YAAY,EAAE;UACzC,OAAOlC,KAAK;QACd;QACAA,KAAK,CAACmC,OAAO,GAAGpC,kBAAkB,CAACC,KAAK,CAACmC,OAAO,EAAElC,MAAM,CAAC;QACzD,OAAOD,KAAK;MACd;IAEA,KAAM,6BAA4B;MAAE;QAClC,OAAO;UACL,GAAGA,KAAK;UACRiC,IAAI,EAAEF,SAAS,CAACM;QAClB,CAAC;MACH;IAEA,KAAM,cAAa;MAAE;QACnB,OAAOL,YAAY,EAAE;MACvB;IAEA;MAAS;QACPhC,KAAK,CAACmC,OAAO,GAAGpC,kBAAkB,CAACC,KAAK,CAACmC,OAAO,EAAElC,MAAM,CAAC;QACzD,OAAOD,KAAK;MACd;EAAC;AAEL,CAAC;AAAA"}