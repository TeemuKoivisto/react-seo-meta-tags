{"version":3,"file":"index.js","sources":["../src/lib/history.js","../src/lib/hooks-create-context.js","../src/lib/hooks-use-context.js","../src/lib/redirect.js","../src/lib/utils.js","../src/lib/link.js","../src/lib/error-boundary.js","../src/lib/location-provider.js","../src/lib/focus-handler.js","../src/lib/router.js","../src/hooks/use-location.js","../src/lib/location.js","../src/lib/match.js","../src/lib/location-server.js","../src/hooks/use-match.js","../src/hooks/use-navigate.js","../src/hooks/use-params.js"],"sourcesContent":["const getLocation = source => {\n  const { search, hash, href, origin, protocol, host, hostname, port } =\n    source.location\n  let { pathname } = source.location\n\n  if (!pathname && href && canUseDOM) {\n    const url = new URL(href)\n    pathname = url.pathname\n  }\n\n  return {\n    pathname: encodeURI(decodeURI(pathname)),\n    search,\n    hash,\n    href,\n    origin,\n    protocol,\n    host,\n    hostname,\n    port,\n    state: source.history.state,\n    key: (source.history.state && source.history.state.key) || \"initial\",\n  }\n}\n\nconst createHistory = (source, options) => {\n  let listeners = []\n  let location = getLocation(source)\n  let transitioning = false\n  let resolveTransition = () => {}\n\n  return {\n    get location() {\n      return location\n    },\n\n    get transitioning() {\n      return transitioning\n    },\n\n    _onTransitionComplete() {\n      transitioning = false\n      resolveTransition()\n    },\n\n    listen(listener) {\n      listeners.push(listener)\n\n      const popstateListener = () => {\n        location = getLocation(source)\n        listener({ location, action: \"POP\" })\n      }\n\n      source.addEventListener(\"popstate\", popstateListener)\n\n      return () => {\n        source.removeEventListener(\"popstate\", popstateListener)\n        listeners = listeners.filter(fn => fn !== listener)\n      }\n    },\n\n    navigate(to, { state, replace = false } = {}) {\n      if (typeof to === \"number\") {\n        source.history.go(to)\n      } else {\n        state = { ...state, key: Date.now() + \"\" }\n        // try...catch iOS Safari limits to 100 pushState calls\n        try {\n          if (transitioning || replace) {\n            source.history.replaceState(state, null, to)\n          } else {\n            source.history.pushState(state, null, to)\n          }\n        } catch (e) {\n          source.location[replace ? \"replace\" : \"assign\"](to)\n        }\n      }\n\n      location = getLocation(source)\n      transitioning = true\n      const transition = new Promise(res => (resolveTransition = res))\n      listeners.forEach(listener => listener({ location, action: \"PUSH\" }))\n      return transition\n    },\n  }\n}\n\n// Stores history entries in memory for testing or other platforms like Native\nconst createMemorySource = (initialPath = \"/\") => {\n  const searchIndex = initialPath.indexOf(\"?\")\n  const initialLocation = {\n    pathname:\n      searchIndex > -1 ? initialPath.substr(0, searchIndex) : initialPath,\n    search: searchIndex > -1 ? initialPath.substr(searchIndex) : \"\",\n  }\n  let index = 0\n  const stack = [initialLocation]\n  const states = [null]\n\n  return {\n    get location() {\n      return stack[index]\n    },\n    addEventListener(name, fn) {},\n    removeEventListener(name, fn) {},\n    history: {\n      get entries() {\n        return stack\n      },\n      get index() {\n        return index\n      },\n      get state() {\n        return states[index]\n      },\n      pushState(state, _, uri) {\n        const [pathname, search = \"\"] = uri.split(\"?\")\n        index++\n        stack.push({ pathname, search: search.length ? `?${search}` : search })\n        states.push(state)\n      },\n      replaceState(state, _, uri) {\n        const [pathname, search = \"\"] = uri.split(\"?\")\n        stack[index] = { pathname, search }\n        states[index] = state\n      },\n      go(to) {\n        const newIndex = index + to\n\n        if (newIndex < 0 || newIndex > states.length - 1) {\n          return\n        }\n\n        index = newIndex\n      },\n    },\n  }\n}\n\n// global history - uses window.history as the source if available, otherwise a\n// memory history\nconst canUseDOM = !!(\n  typeof window !== \"undefined\" &&\n  window.document &&\n  window.document.createElement\n)\nconst getSource = () => {\n  return canUseDOM ? window : createMemorySource()\n}\n\nconst globalSource = getSource()\nconst globalHistory = createHistory(globalSource)\nconst { navigate } = globalHistory\n\nexport { globalHistory, navigate, createHistory, createMemorySource }\n","/* eslint-disable no-undef */\n\nimport React from \"react\"\n\nconst createServerContext = (name, defaultValue = null) => {\n  if (!globalThis.__SERVER_CONTEXT) {\n    globalThis.__SERVER_CONTEXT = {}\n  }\n\n  if (!globalThis.__SERVER_CONTEXT[name]) {\n    globalThis.__SERVER_CONTEXT[name] = React.createServerContext(\n      name,\n      defaultValue\n    )\n  }\n\n  return globalThis.__SERVER_CONTEXT[name]\n}\n\nfunction createServerOrClientContext(name, defaultValue) {\n  if (React.createServerContext) {\n    return createServerContext(name, defaultValue)\n  }\n\n  return React.createContext(defaultValue)\n}\n\nexport const BaseContext = createServerOrClientContext(\"Base\", {\n  baseuri: \"/\",\n  basepath: \"/\",\n})\nexport const LocationContext = createServerOrClientContext(\"Location\")\n","import * as React from \"react\"\nimport { BaseContext, LocationContext } from \"./hooks-create-context\"\n\nexport const useBaseContext = () => React.useContext(BaseContext)\nexport const useLocationContext = () => React.useContext(LocationContext)\n","import * as React from \"react\"\nimport PropTypes from \"prop-types\"\nimport { navigate } from \"./history\"\nimport { resolve, insertParams } from \"./utils\"\nimport { useBaseContext, useLocationContext } from \"./hooks-use-context\"\n\nfunction RedirectRequest(uri) {\n  this.uri = uri\n}\n\nconst isRedirect = o => o instanceof RedirectRequest\n\nconst redirectTo = to => {\n  throw new RedirectRequest(to)\n}\n\nfunction RedirectImpl(props) {\n  const { to, replace = true, state, noThrow, baseuri } = props\n\n  React.useEffect(() => {\n    Promise.resolve().then(() => {\n      const resolvedTo = resolve(to, baseuri)\n      navigate(insertParams(resolvedTo, props), { replace, state })\n    })\n  }, [])\n\n  const resolvedTo = resolve(to, baseuri)\n\n  if (!noThrow) {\n    redirectTo(insertParams(resolvedTo, props))\n  }\n\n  return null\n}\n\nconst Redirect = props => {\n  const locationContext = useLocationContext()\n  const { baseuri } = useBaseContext()\n\n  return <RedirectImpl {...locationContext} baseuri={baseuri} {...props} />\n}\n\nRedirect.propTypes = {\n  from: PropTypes.string,\n  to: PropTypes.string.isRequired,\n}\n\nexport { Redirect, isRedirect, redirectTo }\n","import * as React from \"react\"\nimport invariant from \"invariant\"\nimport { Redirect } from \"./redirect\"\n\n/**\n * startsWith(string, search) - Check if `string` starts with `search`\n */\nconst startsWith = (string, search) => {\n  return string.substr(0, search.length) === search\n}\n\n/**\n * pick(routes, uri)\n\n  Ranks and picks the best route to match. Each segment gets the highest\n  amount of points, then the type of segment gets an additional amount of\n  points where\n\n      static > dynamic > splat > root\n\n  This way we don't have to worry about the order of our routes, let the\n  computers do it.\n\n  A route looks like this\n\n      { path, default, value }\n\n  And a returned match looks like:\n\n      { route, params, uri }\n\n  I know, I should use TypeScript not comments for these types. \n */\nconst pick = (routes, uri) => {\n  let match\n  let default_\n\n  const [uriPathname] = uri.split(\"?\")\n  const uriSegments = segmentize(uriPathname)\n  const isRootUri = uriSegments[0] === \"\"\n  const ranked = rankRoutes(routes)\n\n  for (let i = 0, l = ranked.length; i < l; i++) {\n    let missed = false\n    const route = ranked[i].route\n\n    if (route.default) {\n      default_ = {\n        route,\n        params: {},\n        uri,\n      }\n      continue\n    }\n\n    const routeSegments = segmentize(route.path)\n    const params = {}\n    const max = Math.max(uriSegments.length, routeSegments.length)\n    let index = 0\n\n    for (; index < max; index++) {\n      const routeSegment = routeSegments[index]\n      const uriSegment = uriSegments[index]\n\n      if (isSplat(routeSegment)) {\n        // Hit a splat, just grab the rest, and return a match\n        // uri:   /files/documents/work\n        // route: /files/*\n        const param = routeSegment.slice(1) || \"*\"\n        params[param] = uriSegments\n          .slice(index)\n          .map(decodeURIComponent)\n          .join(\"/\")\n        break\n      }\n\n      if (uriSegment === undefined) {\n        // URI is shorter than the route, no match\n        // uri:   /users\n        // route: /users/:userId\n        missed = true\n        break\n      }\n\n      const dynamicMatch = paramRe.exec(routeSegment)\n\n      if (dynamicMatch && !isRootUri) {\n        const matchIsNotReserved = reservedNames.indexOf(dynamicMatch[1]) === -1\n        invariant(\n          matchIsNotReserved,\n          `<Router> dynamic segment \"${dynamicMatch[1]}\" is a reserved name. Please use a different name in path \"${route.path}\".`\n        )\n        const value = decodeURIComponent(uriSegment)\n        params[dynamicMatch[1]] = value\n      } else if (routeSegment !== uriSegment) {\n        // Current segments don't match, not dynamic, not splat, so no match\n        // uri:   /users/123/settings\n        // route: /users/:id/profile\n        missed = true\n        break\n      }\n    }\n\n    if (!missed) {\n      match = {\n        route,\n        params,\n        uri: \"/\" + uriSegments.slice(0, index).join(\"/\"),\n      }\n      break\n    }\n  }\n\n  return match || default_ || null\n}\n\n/**\n * match(path, uri) - Matches just one path to a uri, also lol\n */\nconst match = (path, uri) => pick([{ path }], uri)\n\n/**\n * resolve(to, basepath)\n\n  Resolves URIs as though every path is a directory, no files.  Relative URIs\n  in the browser can feel awkward because not only can you be \"in a directory\"\n  you can be \"at a file\", too. For example\n\n      browserSpecResolve('foo', '/bar/') => /bar/foo\n      browserSpecResolve('foo', '/bar') => /foo\n\n  But on the command line of a file system, it's not as complicated, you can't\n  `cd` from a file, only directories.  This way, links have to know less about\n  their current path. To go deeper you can do this:\n\n      <Link to=\"deeper\"/>\n      // instead of\n      <Link to=`{${props.uri}/deeper}`/>\n\n  Just like `cd`, if you want to go deeper from the command line, you do this:\n\n      cd deeper\n      // not\n      cd $(pwd)/deeper\n\n  By treating every path as a directory, linking to relative paths should\n  require less contextual information and (fingers crossed) be more intuitive.\n */\nconst resolve = (to, base) => {\n  // /foo/bar, /baz/qux => /foo/bar\n  if (startsWith(to, \"/\")) {\n    return to\n  }\n\n  const [toPathname, toQuery] = to.split(\"?\")\n  const [basePathname] = base.split(\"?\")\n\n  const toSegments = segmentize(toPathname)\n  const baseSegments = segmentize(basePathname)\n\n  // ?a=b, /users?b=c => /users?a=b\n  if (toSegments[0] === \"\") {\n    return addQuery(basePathname, toQuery)\n  }\n\n  // profile, /users/789 => /users/789/profile\n  if (!startsWith(toSegments[0], \".\")) {\n    const pathname = baseSegments.concat(toSegments).join(\"/\")\n    return addQuery((basePathname === \"/\" ? \"\" : \"/\") + pathname, toQuery)\n  }\n\n  // ./         /users/123  =>  /users/123\n  // ../        /users/123  =>  /users\n  // ../..      /users/123  =>  /\n  // ../../one  /a/b/c/d    =>  /a/b/one\n  // .././one   /a/b/c/d    =>  /a/b/c/one\n  const allSegments = baseSegments.concat(toSegments)\n  const segments = []\n  for (let i = 0, l = allSegments.length; i < l; i++) {\n    const segment = allSegments[i]\n    if (segment === \"..\") segments.pop()\n    else if (segment !== \".\") segments.push(segment)\n  }\n\n  return addQuery(\"/\" + segments.join(\"/\"), toQuery)\n}\n\nconst insertParams = (path, params) => {\n  const [pathBase, query = \"\"] = path.split(\"?\")\n  const segments = segmentize(pathBase)\n  let constructedPath =\n    \"/\" +\n    segments\n      .map(segment => {\n        const match = paramRe.exec(segment)\n        return match ? params[match[1]] : segment\n      })\n      .join(\"/\")\n  const { location: { search = \"\" } = {} } = params\n  const searchSplit = search.split(\"?\")[1] || \"\"\n  constructedPath = addQuery(constructedPath, query, searchSplit)\n  return constructedPath\n}\n\nconst validateRedirect = (from, to) => {\n  const filter = segment => isDynamic(segment)\n  const fromString = segmentize(from).filter(filter).sort().join(\"/\")\n  const toString = segmentize(to).filter(filter).sort().join(\"/\")\n  return fromString === toString\n}\n\nconst paramRe = /^:(.+)/\n\nconst SEGMENT_POINTS = 4\nconst STATIC_POINTS = 3\nconst DYNAMIC_POINTS = 2\nconst SPLAT_PENALTY = 1\nconst ROOT_POINTS = 1\n\nconst isRootSegment = segment => segment === \"\"\nconst isDynamic = segment => paramRe.test(segment)\nconst isSplat = segment => segment && segment[0] === \"*\"\n\nconst rankRoute = (route, index) => {\n  const score = route.default\n    ? 0\n    : segmentize(route.path).reduce((score, segment) => {\n        score += SEGMENT_POINTS\n        if (isRootSegment(segment)) score += ROOT_POINTS\n        else if (isDynamic(segment)) score += DYNAMIC_POINTS\n        else if (isSplat(segment)) score -= SEGMENT_POINTS + SPLAT_PENALTY\n        else score += STATIC_POINTS\n        return score\n      }, 0)\n  return { route, score, index }\n}\n\nconst rankRoutes = routes =>\n  routes\n    .map(rankRoute)\n    .sort((a, b) =>\n      a.score < b.score ? 1 : a.score > b.score ? -1 : a.index - b.index\n    )\n\nconst segmentize = uri =>\n  uri\n    // strip starting/ending slashes\n    .replace(/(^\\/+|\\/+$)/g, \"\")\n    .split(\"/\")\n\nconst addQuery = (pathname, ...query) => {\n  query = query.filter(q => q && q.length > 0)\n  return pathname + (query && query.length > 0 ? `?${query.join(\"&\")}` : \"\")\n}\n\nconst reservedNames = [\"uri\", \"path\"]\n\n/**\n * Shallow compares two objects.\n * @param {Object} obj1 The first object to compare.\n * @param {Object} obj2 The second object to compare.\n */\nconst shallowCompare = (obj1, obj2) => {\n  const obj1Keys = Object.keys(obj1)\n  return (\n    obj1Keys.length === Object.keys(obj2).length &&\n    obj1Keys.every(key => obj2.hasOwnProperty(key) && obj1[key] === obj2[key])\n  )\n}\n\nconst stripSlashes = str => str.replace(/(^\\/+|\\/+$)/g, \"\")\n\nconst createRoute = basepath => element => {\n  if (!element) {\n    return null\n  }\n\n  if (element.type === React.Fragment && element.props.children) {\n    return React.Children.map(element.props.children, createRoute(basepath))\n  }\n  invariant(\n    element.props.path || element.props.default || element.type === Redirect,\n    `<Router>: Children of <Router> must have a \\`path\\` or \\`default\\` prop, or be a \\`<Redirect>\\`. None found on element type \\`${element.type}\\``\n  )\n\n  invariant(\n    !(element.type === Redirect && (!element.props.from || !element.props.to)),\n    `<Redirect from=\"${element.props.from}\" to=\"${element.props.to}\"/> requires both \"from\" and \"to\" props when inside a <Router>.`\n  )\n\n  invariant(\n    !(\n      element.type === Redirect &&\n      !validateRedirect(element.props.from, element.props.to)\n    ),\n    `<Redirect from=\"${element.props.from} to=\"${element.props.to}\"/> has mismatched dynamic segments, ensure both paths have the exact same dynamic segments.`\n  )\n\n  if (element.props.default) {\n    return { value: element, default: true }\n  }\n\n  const elementPath =\n    element.type === Redirect ? element.props.from : element.props.path\n\n  const path =\n    elementPath === \"/\"\n      ? basepath\n      : `${stripSlashes(basepath)}/${stripSlashes(elementPath)}`\n\n  return {\n    value: element,\n    default: element.props.default,\n    path: element.props.children ? `${stripSlashes(path)}/*` : path,\n  }\n}\n\nconst shouldNavigate = event =>\n  !event.defaultPrevented &&\n  event.button === 0 &&\n  !(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey)\n\nexport {\n  startsWith,\n  pick,\n  match,\n  resolve,\n  insertParams,\n  validateRedirect,\n  shallowCompare,\n  createRoute,\n  shouldNavigate,\n}\n","/* eslint-disable jsx-a11y/anchor-has-content */\nimport * as React from \"react\"\nimport PropTypes from \"prop-types\"\nimport { navigate } from \"./history\"\nimport { resolve, startsWith, shouldNavigate, shallowCompare } from \"./utils\"\nimport { useBaseContext, useLocationContext } from \"./hooks-use-context\"\n\nlet { forwardRef } = React\n\nif (typeof forwardRef === \"undefined\") {\n  forwardRef = C => C\n}\n\nconst k = () => {}\n\nexport const Link = forwardRef(({ innerRef, ...props }, ref) => {\n  const { baseuri } = useBaseContext()\n  const { location } = useLocationContext()\n\n  const { to, state, replace, getProps = k, ...anchorProps } = props\n  const href = resolve(to, baseuri)\n  const encodedHref = encodeURI(href)\n  const isCurrent = location.pathname === encodedHref\n  const isPartiallyCurrent = startsWith(location.pathname, encodedHref)\n\n  return (\n    <a\n      ref={ref || innerRef}\n      aria-current={isCurrent ? \"page\" : undefined}\n      {...anchorProps}\n      {...getProps({ isCurrent, isPartiallyCurrent, href, location })}\n      href={href}\n      onClick={event => {\n        if (anchorProps.onClick) anchorProps.onClick(event)\n        if (shouldNavigate(event)) {\n          event.preventDefault()\n          let shouldReplace = replace\n          if (typeof replace !== \"boolean\" && isCurrent) {\n            const { key, ...restState } = { ...location.state }\n            shouldReplace = shallowCompare({ ...state }, restState)\n          }\n          navigate(href, {\n            state,\n            replace: shouldReplace,\n          })\n        }\n      }}\n    />\n  )\n})\n\nLink.displayName = \"Link\"\n\nLink.propTypes = {\n  to: PropTypes.string.isRequired,\n}\n","// MIT LICENSE - Taken from: https://github.com/tatethurston/react-use-error-boundary/blob/525225a34d4ad50f52b5f5ac8731cdf6999cf8a8/src/index.tsx\n\nimport * as React from \"react\"\n\nclass ErrorBoundary extends React.Component {\n  displayName = \"ReactUseErrorBoundary\"\n\n  componentDidCatch(...args) {\n    // silence React warning:\n    // ErrorBoundary: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI\n    this.setState({})\n    this.props.onError(...args)\n  }\n\n  render() {\n    return this.props.children\n  }\n}\n\nconst noop = () => false\n\nconst errorBoundaryContext = React.createContext({\n  componentDidCatch: { current: undefined },\n  error: undefined,\n  setError: noop,\n})\n\nexport function ErrorBoundaryContext({ children }) {\n  const [error, setError] = React.useState()\n  const componentDidCatch = React.useRef()\n  const ctx = React.useMemo(\n    () => ({\n      componentDidCatch,\n      error,\n      setError,\n    }),\n    [error]\n  )\n  return (\n    <errorBoundaryContext.Provider value={ctx}>\n      <ErrorBoundary\n        error={error}\n        onError={(error, errorInfo) => {\n          setError(error)\n          componentDidCatch.current?.(error, errorInfo)\n        }}\n      >\n        {children}\n      </ErrorBoundary>\n    </errorBoundaryContext.Provider>\n  )\n}\nErrorBoundaryContext.displayName = \"ReactUseErrorBoundaryContext\"\n\nexport function withErrorBoundary(WrappedComponent) {\n  function WithErrorBoundary(props) {\n    return (\n      <ErrorBoundaryContext>\n        <WrappedComponent key=\"WrappedComponent\" {...props} />\n      </ErrorBoundaryContext>\n    )\n  }\n  WithErrorBoundary.displayName = `WithErrorBoundary(${\n    WrappedComponent.displayName ?? WrappedComponent.name ?? \"Component\"\n  })`\n\n  return WithErrorBoundary\n}\n\nexport function useErrorBoundary(componentDidCatch) {\n  const ctx = React.useContext(errorBoundaryContext)\n  ctx.componentDidCatch.current = componentDidCatch\n  const resetError = React.useCallback(() => {\n    ctx.setError(undefined)\n  }, [])\n\n  return [ctx.error, resetError]\n}\n","import * as React from \"react\"\nimport { globalHistory, navigate } from \"./history\"\nimport { isRedirect } from \"./redirect\"\nimport { LocationContext } from \"./hooks-create-context\"\nimport { withErrorBoundary, useErrorBoundary } from \"./error-boundary\"\n\nexport const LocationProvider = withErrorBoundary(\n  ({ history = globalHistory, children }) => {\n    const { location } = history\n\n    const [context, setContext] = React.useState({ location })\n    const [error] = useErrorBoundary()\n\n    React.useEffect(() => {\n      history._onTransitionComplete()\n    }, [context.location])\n\n    React.useEffect(() => {\n      let isCancelled = false\n      const unlisten = history.listen(({ location }) => {\n        Promise.resolve().then(() => {\n          requestAnimationFrame(() => {\n            if (!isCancelled) {\n              setContext({ location })\n            }\n          })\n        })\n      })\n      return () => {\n        isCancelled = true\n        unlisten()\n      }\n    }, [])\n\n    if (error) {\n      if (isRedirect(error)) {\n        navigate(error.uri, { replace: true })\n      } else {\n        throw error\n      }\n    }\n\n    return (\n      <LocationContext.Provider value={context}>\n        {typeof children === \"function\" ? children(context) : children || null}\n      </LocationContext.Provider>\n    )\n  }\n)\n","import * as React from \"react\"\n\nexport const FocusHandler = ({ uri, location, component, ...domProps }) => {\n  return (\n    <FocusHandlerImpl\n      {...domProps}\n      component={component}\n      uri={uri}\n      location={location}\n    />\n  )\n}\n\nlet focusHandlerCount = 0\n\nconst FocusHandlerImpl = ({\n  children,\n  style,\n  component: Comp = \"div\",\n  uri,\n  location,\n  ...domProps\n}) => {\n  const focusWrapperRef = React.useRef()\n  const initialRenderRef = React.useRef(true)\n  const uriRef = React.useRef(uri)\n  const pathnameRef = React.useRef(location.pathname)\n  const shouldFocusRef = React.useRef(false)\n\n  const _requestFocus = requestNode => {\n    if (shouldFocusRef.current && requestNode) {\n      requestNode.focus()\n    }\n  }\n\n  // Initial mount/unmount logic\n  React.useEffect(() => {\n    focusHandlerCount++\n    focus()\n\n    return () => {\n      focusHandlerCount--\n      if (focusHandlerCount === 0) {\n        initialRenderRef.current = true\n      }\n    }\n  }, [])\n\n  // Subsequent navigation logic\n  React.useEffect(() => {\n    let uriChanged = false\n    let pathnameChanged = false\n\n    if (uri !== uriRef.current) {\n      uriRef.current = uri\n      uriChanged = true\n    }\n\n    if (location.pathname !== pathnameRef.current) {\n      pathnameRef.current = location.pathname\n      pathnameChanged = true\n    }\n\n    const navigatedUpToMe = pathnameChanged && location.pathname === uri\n\n    shouldFocusRef.current = uriChanged || navigatedUpToMe\n\n    if (shouldFocusRef.current) {\n      focus()\n    }\n  }, [uri, location])\n\n  const focus = React.useCallback(() => {\n    if (process.env.NODE_ENV === \"test\") {\n      // TODO: Check if change for tests still needed\n      return\n    }\n\n    // Don't focus the <Comp /> on initial render\n    if (initialRenderRef.current) {\n      initialRenderRef.current = false\n    } else {\n      _requestFocus(focusWrapperRef.current)\n    }\n  }, [])\n\n  return (\n    <Comp\n      style={{ outline: \"none\", ...style }}\n      tabIndex=\"-1\"\n      ref={focusWrapperRef}\n      {...domProps}\n    >\n      {children}\n    </Comp>\n  )\n}\n","import * as React from \"react\"\nimport { BaseContext } from \"./hooks-create-context\"\nimport { createRoute, pick } from \"./utils\"\nimport { FocusHandler } from \"./focus-handler\"\nimport { useBaseContext, useLocationContext } from \"./hooks-use-context\"\n\nexport const Router = props => {\n  const baseContext = useBaseContext()\n  const locationContext = useLocationContext()\n\n  return <RouterImpl {...baseContext} {...locationContext} {...props} />\n}\n\nfunction RouterImpl(props) {\n  const {\n    location,\n    primary = true,\n    children,\n    basepath,\n    baseuri,\n    component = \"div\",\n    ...domProps\n  } = props\n\n  const routes = React.Children.toArray(children).reduce((array, child) => {\n    const routes = createRoute(basepath)(child)\n    return array.concat(routes)\n  }, [])\n  const { pathname } = location\n  const match = pick(routes, pathname)\n\n  if (match) {\n    const {\n      params,\n      uri,\n      route,\n      route: { value: element },\n    } = match\n\n    // remove the /* from the end for child routes relative paths\n    const normalizedBasePath = route.default\n      ? basepath\n      : route.path.replace(/\\*$/, \"\")\n\n    const props = {\n      ...params,\n      uri,\n      location,\n    }\n\n    const clone = React.cloneElement(\n      element,\n      props,\n      element.props.children ? (\n        <Router location={location} primary={primary}>\n          {element.props.children}\n        </Router>\n      ) : undefined\n    )\n\n    // using 'div' for < 16.3 support\n    const FocusWrapper = primary ? FocusHandler : component\n    // don't pass any props to 'div'\n    const wrapperProps = primary\n      ? { uri, location, component, ...domProps }\n      : domProps\n\n    return (\n      <BaseContext.Provider\n        value={{ baseuri: uri, basepath: normalizedBasePath }}\n      >\n        <FocusWrapper {...wrapperProps}>{clone}</FocusWrapper>\n      </BaseContext.Provider>\n    )\n  } else {\n    return null\n  }\n}\n","import { useLocationContext } from \"../lib/hooks-use-context\"\n\nexport const useLocation = () => {\n  const context = useLocationContext()\n\n  if (!context) {\n    throw new Error(\n      \"useLocation hook was used but a LocationContext.Provider was not found in the parent tree. Make sure this is used in a component that is a child of Router\"\n    )\n  }\n\n  return context.location\n}\n","import * as React from \"react\"\nimport { useLocationContext } from \"./hooks-use-context\"\nimport { LocationProvider } from \"./location-provider\"\n\nexport const Location = ({ children }) => {\n  const context = useLocationContext()\n\n  if (context) {\n    return children(context)\n  } else {\n    return <LocationProvider>{children}</LocationProvider>\n  }\n}\n","import { useBaseContext, useLocationContext } from \"./hooks-use-context\"\nimport { resolve, match } from \"./utils\"\n\nconst Match = ({ path, children }) => {\n  const { baseuri } = useBaseContext()\n  const { location } = useLocationContext()\n\n  const resolvedPath = resolve(path, baseuri)\n  const result = match(resolvedPath, location.pathname)\n  return children({\n    location,\n    match: result\n      ? {\n          ...result.params,\n          uri: result.uri,\n          path,\n        }\n      : null,\n  })\n}\n\nexport { Match }\n","import * as React from \"react\"\nimport { LocationContext } from \"./hooks-create-context\"\n\nexport const ServerLocation = ({ url, children }) => {\n  const searchIndex = url.indexOf(\"?\")\n  const searchExists = searchIndex > -1\n  let pathname\n  let search = \"\"\n  const hash = \"\"\n\n  if (searchExists) {\n    pathname = url.substring(0, searchIndex)\n    search = url.substring(searchIndex)\n  } else {\n    pathname = url\n  }\n\n  return (\n    <LocationContext.Provider\n      value={{\n        location: {\n          pathname,\n          search,\n          hash,\n        },\n      }}\n    >\n      {children}\n    </LocationContext.Provider>\n  )\n}\n","import { useBaseContext } from \"../lib/hooks-use-context\"\nimport { resolve, match } from \"../lib/utils\"\nimport { useLocation } from \"./use-location\"\n\nexport const useMatch = path => {\n  if (!path) {\n    throw new Error(\n      \"useMatch(path: string) requires an argument of a string to match against\"\n    )\n  }\n  const context = useBaseContext()\n\n  if (!context) {\n    throw new Error(\n      \"useMatch hook was used but a LocationContext.Provider was not found in the parent tree. Make sure this is used in a component that is a child of Router\"\n    )\n  }\n\n  const location = useLocation()\n\n  const resolvedPath = resolve(path, context.baseuri)\n  const result = match(resolvedPath, location.pathname)\n  return result\n    ? {\n        ...result.params,\n        uri: result.uri,\n        path,\n      }\n    : null\n}\n","export const useNavigate = () => {\n  throw new Error(\n    \"useNavigate is removed. Use import { navigate } from 'gatsby' instead\"\n  )\n}\n","import { useBaseContext } from \"../lib/hooks-use-context\"\nimport { match } from \"../lib/utils\"\nimport { useLocation } from \"./use-location\"\n\nexport const useParams = () => {\n  const context = useBaseContext()\n\n  if (!context) {\n    throw new Error(\n      \"useParams hook was used but a LocationContext.Provider was not found in the parent tree. Make sure this is used in a component that is a child of Router\"\n    )\n  }\n\n  const location = useLocation()\n\n  const results = match(context.basepath, location.pathname)\n\n  return results ? results.params : null\n}\n"],"names":["getLocation","source","location","search","hash","_source$location","href","origin","protocol","host","hostname","port","pathname","canUseDOM","URL","encodeURI","decodeURI","state","history","key","createHistory","options","listeners","transitioning","_onTransitionComplete","resolveTransition","listen","listener","push","popstateListener","action","addEventListener","removeEventListener","filter","fn","navigate","to","_temp","_ref","_ref$replace","replace","go","Date","now","replaceState","pushState","e","transition","Promise","res","forEach","initialPath","indexOf","searchIndex","substr","index","stack","initialLocation","states","name","entries","_","uri","split","_uri$split$","length","_uri$split2$","newIndex","window","document","createElement","globalHistory","createMemorySource","createServerOrClientContext","defaultValue","React","createServerContext","globalThis","__SERVER_CONTEXT","createContext","BaseContext","baseuri","basepath","LocationContext","useContext","useLocationContext","RedirectRequest","this","isRedirect","o","redirectTo","RedirectImpl","props","_props$replace","noThrow","useEffect","resolve","then","insertParams","resolvedTo","Redirect","locationContext","_useBaseContext","useBaseContext","propTypes","from","PropTypes","string","isRequired","startsWith","routes","_uri$split","uriSegments","segmentize","ranked","rankRoutes","i","l","missed","route","default_","params","routeSegments","path","max","Math","routeSegment","uriSegment","isSplat","slice","map","decodeURIComponent","join","undefined","paramRe","exec","dynamicMatch","isRootUri","reservedNames","invariant","matchIsNotReserved","value","match","pick","base","toPathname","toQuery","_to$split","basePathname","toSegments","baseSegments","addQuery","concat","allSegments","segments","segment","pop","query","_path$split$","_params$location","_params$location$sear","constructedPath","searchSplit","validateRedirect","isDynamic","sort","test","rankRoute","score","reduce","isRootSegment","SEGMENT_POINTS","a","b","q","shallowCompare","obj1","obj2","obj1Keys","Object","keys","every","hasOwnProperty","stripSlashes","str","createRoute","element","type","Fragment","children","Children","default","elementPath","_excluded","_excluded2","_excluded3","forwardRef","C","k","Link","ref","innerRef","_objectWithoutPropertiesLoose","_props$getProps","getProps","anchorProps","encodedHref","isPartiallyCurrent","_extends","isCurrent","onClick","event","defaultPrevented","button","metaKey","altKey","ctrlKey","shiftKey","shouldNavigate","preventDefault","shouldReplace","restState","displayName","ErrorBoundary","componentDidCatch","_this$props","setState","onError","apply","call","arguments","render","Component","errorBoundaryContext","current","error","setError","ErrorBoundaryContext","_React$useState","useState","useRef","ctx","useMemo","Provider","errorInfo","LocationProvider","WrappedComponent","WithErrorBoundary","_WrappedComponent$dis","_ref2","withErrorBoundary","_ref$history","context","setContext","useErrorBoundary","resetError","useCallback","isCancelled","unlisten","requestAnimationFrame","FocusHandler","component","domProps","FocusHandlerImpl","focusHandlerCount","style","Comp","_ref2$component","uriRef","pathnameRef","shouldFocusRef","focus","initialRenderRef","uriChanged","pathnameChanged","requestNode","process","env","NODE_ENV","focusWrapperRef","outline","tabIndex","baseContext","RouterImpl","primary","_props$primary","_props$component","toArray","array","child","normalizedBasePath","clone","cloneElement","Router","wrapperProps","FocusWrapper","useLocation","Error","resolvedPath","result","url","substring","results"],"mappings":"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"}